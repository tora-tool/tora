/** \file
 *  This C++ header file was generated by $ANTLR version 3.5.3-SNAPSHOT
 *
 *     -  From the grammar source file : OracleDML.g
 *     -                            On : 2015-09-27 21:38:23
 *     -                for the parser : OracleDMLParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
 * The parser OracleDML has the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 *
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 */
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram. 
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef	_OracleDML_H
#define _OracleDML_H
/* =============================================================================
 * Standard antlr3 C++ runtime definitions
 */
#include <antlr3.hpp>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */


       #include "OracleDMLTraits.hpp"
       #include "OracleDMLLexer.hpp"


// Include delegate definition header files
//
#include	"OracleDML_OracleDMLKeys.hpp"
#include	"OracleDML_OracleDMLCommons.hpp"





/* ========================
 * BACKTRACKING IS ENABLED
 * ========================
 */

namespace  Antlr3BackendImpl  {

typedef OracleDMLTraits OracleDMLImplTraits;

 struct synpred1_OracleDML {}; 
 struct synpred2_OracleDML {}; 
 struct synpred3_OracleDML {}; 
 struct synpred4_OracleDML {}; 
 struct synpred5_OracleDML {}; 
 struct synpred6_OracleDML {}; 
 struct synpred7_OracleDML {}; 
 struct synpred8_OracleDML {}; 
 struct synpred9_OracleDML {}; 
 struct synpred10_OracleDML {}; 
 struct synpred11_OracleDML {}; 
 struct synpred12_OracleDML {}; 
 struct synpred13_OracleDML {}; 
 struct synpred14_OracleDML {}; 
 struct synpred15_OracleDML {}; 
 struct synpred16_OracleDML {}; 
 struct synpred17_OracleDML {}; 
 struct synpred18_OracleDML {}; 
 struct synpred19_OracleDML {}; 
 struct synpred20_OracleDML {}; 
 struct synpred21_OracleDML {}; 
 struct synpred22_OracleDML {}; 
 struct synpred23_OracleDML {}; 
 struct synpred24_OracleDML {}; 
 struct synpred25_OracleDML {}; 
 struct synpred26_OracleDML {}; 
 struct synpred27_OracleDML {}; 
 struct synpred28_OracleDML {}; 
 struct synpred29_OracleDML {}; 
 struct synpred30_OracleDML {}; 
 struct synpred31_OracleDML {}; 
 struct synpred36_OracleDML {}; 
 struct synpred38_OracleDML {}; 
 struct synpred39_OracleDML {}; 
 struct synpred40_OracleDML {}; 
 struct synpred41_OracleDML {}; 
 struct synpred42_OracleDML {}; 
 struct synpred43_OracleDML {}; 
 struct synpred45_OracleDML {}; 
 struct synpred46_OracleDML {}; 
 struct synpred47_OracleDML {}; 
 struct synpred48_OracleDML {}; 
 struct synpred49_OracleDML {}; 
 struct synpred50_OracleDML {}; 
 struct synpred51_OracleDML {}; 

class OracleDMLTokens
{
public:
	/** Symbolic definitions of all the tokens that the parser will work with.
	 *
	 * Antlr will define EOF, but we can't use that as it it is too common in
	 * in C header files and that would be confusing. There is no way to filter this out at the moment
	 * so we just undef it here for now. That isn't the value we get back from C recognizers
	 * anyway. We are looking for ANTLR_TOKEN_EOF.
	 */
	enum Tokens : ANTLR_UINT32
	{
		EOF_TOKEN = OracleDMLImplTraits::CommonTokenType::TOKEN_EOF
		, ADD_VK = 4 
		, AFTER_VK = 5 
		, AGENT_VK = 6 
		, AGGREGATE_VK = 7 
		, ALIAS = 8 
		, AMPERSAND = 9 
		, ANALYZE_VK = 10 
		, ANY_ELEMENT = 11 
		, ANY_MODE = 12 
		, APPROXIMATE_NUM_LIT = 13 
		, ARGUMENT = 14 
		, ARGUMENTS = 15 
		, ASSIGN = 16 
		, ASSIGN_OP = 17 
		, ASSOCIATE_VK = 18 
		, ASTERISK = 19 
		, ATTRIBUTE_NAME = 20 
		, AT_SIGN = 21 
		, AT_VK = 22 
		, AUDIT_VK = 23 
		, AUTHID_VK = 24 
		, AUTOMATIC_VK = 25 
		, AUTONOMOUS_TRANSACTION_VK = 26 
		, AUTO_VK = 27 
		, BATCH_VK = 28 
		, BEFORE_VK = 29 
		, BFILE_VK = 30 
		, BINARY_DOUBLE_VK = 31 
		, BINARY_FLOAT_VK = 32 
		, BINARY_INTEGER_VK = 33 
		, BINDVAR = 34 
		, BIT_STRING_LIT = 35 
		, BIT_VK = 36 
		, BLOB_VK = 37 
		, BLOCK_VK = 38 
		, BODY_VK = 39 
		, BOOLEAN_VK = 40 
		, BOTH_VK = 41 
		, BREADTH_VK = 42 
		, BULK_VK = 43 
		, BYTE_VK = 44 
		, CACHE_VK = 45 
		, CALL_VK = 46 
		, CANONICAL_VK = 47 
		, CARRET_OPERATOR_PART = 48 
		, CASCADE_VK = 49 
		, CASCATED_ELEMENT = 50 
		, CAST_VK = 51 
		, CHARACTER_VK = 52 
		, CHAR_CS_VK = 53 
		, CHAR_SET_NAME = 54 
		, CHAR_STRING = 55 
		, CHAR_STRING_PERL = 56 
		, CHAR_VK = 57 
		, CHR_VK = 58 
		, CLOB_VK = 59 
		, CLOSE_VK = 60 
		, CLUSTER_VK = 61 
		, COLLECTION_MODE = 62 
		, COLLECTION_NAME = 63 
		, COLLECT_VK = 64 
		, COLON = 65 
		, COLUMNS = 66 
		, COLUMN_NAME = 67 
		, COMMA = 68 
		, COMMENT = 69 
		, COMMENT_VK = 70 
		, COMMITTED_VK = 71 
		, COMMIT_VK = 72 
		, COMPATIBILITY_VK = 73 
		, COMPILE_VK = 74 
		, COMPOUND_VK = 75 
		, CONCATENATION_OP = 76 
		, CONDITIONAL_INSERT = 77 
		, CONSTANT_VK = 78 
		, CONSTRAINT_NAME = 79 
		, CONSTRUCTOR_VK = 80 
		, CONTENT_VK = 81 
		, CONTEXT_VK = 82 
		, CONTINUE_VK = 83 
		, CONVERT_VK = 84 
		, CORRUPT_XID_ALL_VK = 85 
		, CORRUPT_XID_VK = 86 
		, COST_CLASS_NAME = 87 
		, COST_VK = 88 
		, COUNT_VK = 89 
		, CROSS_VK = 90 
		, CUBE_VK = 91 
		, CURRENT_USER_VK = 92 
		, CURRENT_VK = 93 
		, CURSOR_NAME = 94 
		, CUSTOMDATUM_VK = 95 
		, CUSTOM_TYPE = 96 
		, CYCLE_VK = 97 
		, C_VK = 98 
		, DATABASE_VK = 99 
		, DATETIME_OP = 100 
		, DAY_VK = 101 
		, DBTIMEZONE_VK = 102 
		, DB_ROLE_CHANGE_VK = 103 
		, DDL_VK = 104 
		, DEBUG_VK = 105 
		, DECIMAL_VK = 106 
		, DECOMPOSE_VK = 107 
		, DECREMENT_VK = 108 
		, DEC_VK = 109 
		, DEFAULTS_VK = 110 
		, DEFERRED_VK = 111 
		, DEFINER_VK = 112 
		, DELIMITED_ID = 113 
		, DENSE_RANK_VK = 114 
		, DEPTH_VK = 115 
		, DETERMINISTIC_VK = 116 
		, DIMENSION_VK = 117 
		, DIRECT_MODE = 118 
		, DISABLE_VK = 119 
		, DISASSOCIATE_VK = 120 
		, DOCUMENT_VK = 121 
		, DOT_ASTERISK = 122 
		, DOUBLE_ASTERISK = 123 
		, DOUBLE_PERIOD = 124 
		, DOUBLE_VK = 125 
		, DSINTERVAL_UNCONSTRAINED_VK = 126 
		, ELEMENT = 127 
		, ELEMENTS_MODE = 128 
		, ENABLE_VK = 129 
		, ENCODING_VK = 130 
		, ENTITYESCAPING_VK = 131 
		, EQUALS_OP = 132 
		, EVALNAME_VK = 133 
		, EXACT_NUM_LIT = 134 
		, EXCEPTIONS_VK = 135 
		, EXCEPTION_INIT_VK = 136 
		, EXCEPTION_NAME = 137 
		, EXCLAMATION_OPERATOR_PART = 138 
		, EXCLUDE_VK = 139 
		, EXECUTE_VK = 140 
		, EXIT_VK = 141 
		, EXPLAIN_STATEMENT = 142 
		, EXPR = 143 
		, EXPR_LIST = 144 
		, EXTERNAL_VK = 145 
		, EXTRACT_VK = 146 
		, FACTORING = 147 
		, FINAL_VK = 148 
		, FIRST_VALUE_VK = 149 
		, FIRST_VK = 150 
		, FLOAT_VK = 151 
		, FOLLOWING_VK = 152 
		, FOLLOWS_VK = 153 
		, FORALL_VK = 154 
		, FORCE_VK = 155 
		, FOR_MULTI_COLUMN = 156 
		, FOR_NOTATION = 157 
		, FOR_SINGLE_COLUMN = 158 
		, FULL_VK = 159 
		, FUNCTION_ENABLING_OVER = 160 
		, FUNCTION_ENABLING_USING = 161 
		, FUNCTION_ENABLING_WITHIN_OR_OVER = 162 
		, FUNCTION_NAME = 163 
		, GREATER_THAN_OP = 164 
		, GREATER_THAN_OR_EQUALS_OP = 165 
		, GROUPING_VK = 166 
		, GROUPIN_SET = 167 
		, GROUP_BY_CLAUSE = 168 
		, GROUP_BY_ELEMENT = 169 
		, HASH_VK = 170 
		, HEX_STRING_LIT = 171 
		, HIDE_VK = 172 
		, HIERARCHICAL = 173 
		, HOSTED_VARIABLE = 174 
		, HOSTED_VARIABLE_NAME = 175 
		, HOSTED_VARIABLE_ROUTINE_CALL = 176 
		, HOUR_VK = 177 
		, ID = 178 
		, IGNORE_VK = 179 
		, IMMEDIATE_VK = 180 
		, IMPLEMENTATION_TYPE_NAME = 181 
		, INCLUDE_VK = 182 
		, INCLUDING_VK = 183 
		, INCREMENT_VK = 184 
		, INDENT_VK = 185 
		, INDEX_NAME = 186 
		, INLINE_VK = 187 
		, INNER_VK = 188 
		, INOUT_VK = 189 
		, INSTANTIABLE_VK = 190 
		, INSTEAD_VK = 191 
		, INTEGER_VK = 192 
		, INTERVAL_DATATYPE = 193 
		, INTRODUCER = 194 
		, INT_VK = 195 
		, INVALIDATE_VK = 196 
		, ISOLATION_VK = 197 
		, IS_A_SET = 198 
		, IS_EMPTY = 199 
		, IS_INFINITE = 200 
		, IS_NAN = 201 
		, IS_NOT_A_SET = 202 
		, IS_NOT_EMPTY = 203 
		, IS_NOT_INFINITE = 204 
		, IS_NOT_NAN = 205 
		, IS_NOT_NULL = 206 
		, IS_NOT_OF_TYPE = 207 
		, IS_NOT_PRESENT = 208 
		, IS_NULL = 209 
		, IS_OF_TYPE = 210 
		, IS_PRESENT = 211 
		, ITERATE_VK = 212 
		, JAVA_VK = 213 
		, JOIN_DEF = 214 
		, KEEP_VK = 215 
		, LABEL_NAME = 216 
		, LANGUAGE_VK = 217 
		, LAST_VALUE_VK = 218 
		, LAST_VK = 219 
		, LEADING_VK = 220 
		, LEFT_BRACKET = 221 
		, LEFT_PAREN = 222 
		, LEFT_VK = 223 
		, LESS_THAN_OP = 224 
		, LESS_THAN_OR_EQUALS_OP = 225 
		, LIBRARY_VK = 226 
		, LIKE2_VK = 227 
		, LIKE4_VK = 228 
		, LIKEC_VK = 229 
		, LIMIT_VK = 230 
		, LINK_NAME = 231 
		, LOCAL_VK = 232 
		, LOCK_TABLE_ELEMENT = 233 
		, LOGIC_EXPR = 234 
		, LOGOFF_VK = 235 
		, LOGON_VK = 236 
		, LOG_VK = 237 
		, LONG_VK = 238 
		, LOOP_VK = 239 
		, MAIN_MODEL = 240 
		, MAIN_MODEL_NAME = 241 
		, MAP_VK = 242 
		, MAXVALUE_VK = 243 
		, MEASURES_VK = 244 
		, MEMBER_VK = 245 
		, MERGE_INSERT = 246 
		, MERGE_UPDATE = 247 
		, MERGE_VK = 248 
		, MINUS_SIGN = 249 
		, MINUTE_VK = 250 
		, MINVALUE_VK = 251 
		, MLSLABEL_VK = 252 
		, MODEL_COLUMN = 253 
		, MODEL_COLUMNS = 254 
		, MODEL_EXPRESSION = 255 
		, MODEL_RULE = 256 
		, MODEL_RULES = 257 
		, MODIFY_VK = 258 
		, MONTH_VK = 259 
		, MULTI_TABLE_MODE = 260 
		, NAME_VK = 261 
		, NATIONAL_CHAR_STRING_LIT = 262 
		, NATIVE_DATATYPE = 263 
		, NATURALN_VK = 264 
		, NATURAL_VK = 265 
		, NAV_VK = 266 
		, NCHAR_CS_VK = 267 
		, NCHAR_VK = 268 
		, NCLOB_VK = 269 
		, NESTED_VK = 270 
		, NEWLINE = 271 
		, NEW_VK = 272 
		, NOAUDIT_VK = 273 
		, NOCACHE_VK = 274 
		, NOCOPY_VK = 275 
		, NOCYCLE_VK = 276 
		, NOENTITYESCAPING_VK = 277 
		, NOMAXVALUE_VK = 278 
		, NOMINVALUE_VK = 279 
		, NOORDER_VK = 280 
		, NOSCHEMACHECK_VK = 281 
		, NOT_BETWEEN = 282 
		, NOT_EQUAL_OP = 283 
		, NOT_IN = 284 
		, NOT_LIKE = 285 
		, NO_VK = 286 
		, NULLS_VK = 287 
		, NUMBER_VK = 288 
		, NUMERIC_VK = 289 
		, NVARCHAR2_VK = 290 
		, OBJECT_VK = 291 
		, OFF_VK = 292 
		, OLD_VK = 293 
		, ONLY_VK = 294 
		, OPEN_VK = 295 
		, ORADATA_VK = 296 
		, ORDER_BY_ELEMENT = 297 
		, ORDER_BY_ELEMENTS = 298 
		, ORDINALITY_VK = 299 
		, OUT_VK = 300 
		, OVERRIDING_VK = 301 
		, OVER_VK = 302 
		, PACKAGE_NAME = 303 
		, PACKAGE_VK = 304 
		, PARALLEL_ENABLE_VK = 305 
		, PARAMETERS_VK = 306 
		, PARAMETER_NAME = 307 
		, PARENT_VK = 308 
		, PARTITION_VK = 309 
		, PASSING_VK = 310 
		, PERCENT = 311 
		, PERCENT_FOUND_VK = 312 
		, PERCENT_ISOPEN_VK = 313 
		, PERCENT_NOTFOUND_VK = 314 
		, PERCENT_ROWCOUNT_VK = 315 
		, PERCENT_ROWTYPE_VK = 316 
		, PERCENT_TYPE_VK = 317 
		, PERIOD = 318 
		, PIPELINED_VK = 319 
		, PIVOT_ALIAS = 320 
		, PIVOT_ELEMENT = 321 
		, PIVOT_IN_ELEMENT = 322 
		, PIVOT_VK = 323 
		, PLSQL_NON_RESERVED_CAST = 324 
		, PLSQL_NON_RESERVED_CONNECT_BY_ROOT = 325 
		, PLSQL_NON_RESERVED_ELSIF = 326 
		, PLSQL_NON_RESERVED_MODEL = 327 
		, PLSQL_NON_RESERVED_MULTISET = 328 
		, PLSQL_NON_RESERVED_PIVOT = 329 
		, PLSQL_NON_RESERVED_UNPIVOT = 330 
		, PLSQL_NON_RESERVED_USING = 331 
		, PLSQL_RESERVED_CLUSTERS = 332 
		, PLSQL_RESERVED_COLAUTH = 333 
		, PLSQL_RESERVED_COMPRESS = 334 
		, PLSQL_RESERVED_CRASH = 335 
		, PLSQL_RESERVED_EXCLUSIVE = 336 
		, PLSQL_RESERVED_IDENTIFIED = 337 
		, PLSQL_RESERVED_IF = 338 
		, PLSQL_RESERVED_INDEX = 339 
		, PLSQL_RESERVED_INDEXES = 340 
		, PLSQL_RESERVED_LOCK = 341 
		, PLSQL_RESERVED_MINUS = 342 
		, PLSQL_RESERVED_MODE = 343 
		, PLSQL_RESERVED_NOCOMPRESS = 344 
		, PLSQL_RESERVED_NOWAIT = 345 
		, PLSQL_RESERVED_RESOURCE = 346 
		, PLSQL_RESERVED_SHARE = 347 
		, PLSQL_RESERVED_START = 348 
		, PLSQL_RESERVED_TABAUTH = 349 
		, PLSQL_RESERVED_VIEWS = 350 
		, PLS_INTEGER_VK = 351 
		, PLUS_SIGN = 352 
		, POSITIVEN_VK = 353 
		, POSITIVE_VK = 354 
		, PRAGMA_VK = 355 
		, PRECEDING_VK = 356 
		, PRECISION = 357 
		, PRECISION_VK = 358 
		, PREDICTION_FUNCTION = 359 
		, PROCEDURE_NAME = 360 
		, PROMPT = 361 
		, QS_ANGLE = 362 
		, QS_BRACE = 363 
		, QS_BRACK = 364 
		, QS_OTHER = 365 
		, QS_OTHER_CH = 366 
		, QS_PAREN = 367 
		, QUERY_NAME = 368 
		, QUESTION_MARK = 369 
		, QUOTE = 370 
		, RAISE_VK = 371 
		, RANGE_VK = 372 
		, RAW_VK = 373 
		, READ_VK = 374 
		, REAL_VK = 375 
		, RECORD_NAME = 376 
		, REFERENCE_MODEL_NAME = 377 
		, REFERENCE_VK = 378 
		, REFERENCING_VK = 379 
		, REF_VK = 380 
		, REGULAR_ID = 381 
		, REJECT_VK = 382 
		, RELIES_ON_VK = 383 
		, RENAME_VK = 384 
		, REPLACE_VK = 385 
		, RESPECT_VK = 386 
		, RESTRICT_REFERENCES_VK = 387 
		, RESULT_CACHE_VK = 388 
		, RETURN_VK = 389 
		, REUSE_VK = 390 
		, REVERSE_VK = 391 
		, RIGHT_BRACKET = 392 
		, RIGHT_PAREN = 393 
		, RIGHT_VK = 394 
		, ROLLBACK_SEGMENT_NAME = 395 
		, ROLLBACK_VK = 396 
		, ROLLUP_VK = 397 
		, ROUTINE_CALL = 398 
		, ROUTINE_NAME = 399 
		, ROWID_VK = 400 
		, ROWS_VK = 401 
		, ROW_VK = 402 
		, RULES_VK = 403 
		, SAMPLE_VK = 404 
		, SAVEPOINT_NAME = 405 
		, SAVEPOINT_VK = 406 
		, SCHEMACHECK_VK = 407 
		, SCHEMA_NAME = 408 
		, SCHEMA_VK = 409 
		, SCN_VK = 410 
		, SEARCHED_CASE = 411 
		, SEARCH_VK = 412 
		, SECOND_VK = 413 
		, SEED_VK = 414 
		, SELECTED_TABLEVIEW = 415 
		, SELECT_ITEM = 416 
		, SELECT_LIST = 417 
		, SELECT_MODE = 418 
		, SELECT_STATEMENT = 419 
		, SELF_VK = 420 
		, SEMICOLON = 421 
		, SEPARATOR = 422 
		, SEQUENCE_NAME = 423 
		, SEQUENCE_VK = 424 
		, SEQUENTIAL_VK = 425 
		, SERIALIZABLE_VK = 426 
		, SERIALLY_REUSABLE_VK = 427 
		, SERVERERROR_VK = 428 
		, SESSIONTIMEZONE_VK = 429 
		, SET_VK = 430 
		, SHOW_VK = 431 
		, SHUTDOWN_VK = 432 
		, SIBLINGS_VK = 433 
		, SIGNTYPE_VK = 434 
		, SIMPLE_CASE = 435 
		, SIMPLE_INTEGER_VK = 436 
		, SIMPLE_LETTER = 437 
		, SINGLE_TABLE_MODE = 438 
		, SINGLE_VK = 439 
		, SKIP_VK = 440 
		, SMALLINT_VK = 441 
		, SOLIDUS = 442 
		, SOME_VK = 443 
		, SPACE = 444 
		, SPECIFICATION_VK = 445 
		, SQL92_RESERVED_ALL = 446 
		, SQL92_RESERVED_ALTER = 447 
		, SQL92_RESERVED_AND = 448 
		, SQL92_RESERVED_ANY = 449 
		, SQL92_RESERVED_AS = 450 
		, SQL92_RESERVED_ASC = 451 
		, SQL92_RESERVED_BEGIN = 452 
		, SQL92_RESERVED_BETWEEN = 453 
		, SQL92_RESERVED_BY = 454 
		, SQL92_RESERVED_CASE = 455 
		, SQL92_RESERVED_CHECK = 456 
		, SQL92_RESERVED_CONNECT = 457 
		, SQL92_RESERVED_CREATE = 458 
		, SQL92_RESERVED_CURRENT = 459 
		, SQL92_RESERVED_CURSOR = 460 
		, SQL92_RESERVED_DATE = 461 
		, SQL92_RESERVED_DECLARE = 462 
		, SQL92_RESERVED_DEFAULT = 463 
		, SQL92_RESERVED_DELETE = 464 
		, SQL92_RESERVED_DESC = 465 
		, SQL92_RESERVED_DISTINCT = 466 
		, SQL92_RESERVED_DROP = 467 
		, SQL92_RESERVED_ELSE = 468 
		, SQL92_RESERVED_END = 469 
		, SQL92_RESERVED_EXCEPTION = 470 
		, SQL92_RESERVED_EXISTS = 471 
		, SQL92_RESERVED_FALSE = 472 
		, SQL92_RESERVED_FETCH = 473 
		, SQL92_RESERVED_FOR = 474 
		, SQL92_RESERVED_FROM = 475 
		, SQL92_RESERVED_GOTO = 476 
		, SQL92_RESERVED_GRANT = 477 
		, SQL92_RESERVED_GROUP = 478 
		, SQL92_RESERVED_HAVING = 479 
		, SQL92_RESERVED_IN = 480 
		, SQL92_RESERVED_INSERT = 481 
		, SQL92_RESERVED_INTERSECT = 482 
		, SQL92_RESERVED_INTO = 483 
		, SQL92_RESERVED_IS = 484 
		, SQL92_RESERVED_LIKE = 485 
		, SQL92_RESERVED_NOT = 486 
		, SQL92_RESERVED_NULL = 487 
		, SQL92_RESERVED_OF = 488 
		, SQL92_RESERVED_ON = 489 
		, SQL92_RESERVED_OPTION = 490 
		, SQL92_RESERVED_OR = 491 
		, SQL92_RESERVED_ORDER = 492 
		, SQL92_RESERVED_OVERLAPS = 493 
		, SQL92_RESERVED_PRIOR = 494 
		, SQL92_RESERVED_PROCEDURE = 495 
		, SQL92_RESERVED_PUBLIC = 496 
		, SQL92_RESERVED_REVOKE = 497 
		, SQL92_RESERVED_SELECT = 498 
		, SQL92_RESERVED_SIZE = 499 
		, SQL92_RESERVED_TABLE = 500 
		, SQL92_RESERVED_THE = 501 
		, SQL92_RESERVED_THEN = 502 
		, SQL92_RESERVED_TO = 503 
		, SQL92_RESERVED_TRUE = 504 
		, SQL92_RESERVED_UNION = 505 
		, SQL92_RESERVED_UNIQUE = 506 
		, SQL92_RESERVED_UPDATE = 507 
		, SQL92_RESERVED_VALUES = 508 
		, SQL92_RESERVED_VIEW = 509 
		, SQL92_RESERVED_WHEN = 510 
		, SQL92_RESERVED_WHERE = 511 
		, SQL92_RESERVED_WITH = 512 
		, SQLDATA_VK = 513 
		, STANDALONE_VK = 514 
		, STANDARD_FUNCTION = 515 
		, STARTUP_VK = 516 
		, STATIC_RETURNING = 517 
		, STATIC_VK = 518 
		, STATISTICS_VK = 519 
		, STRING_VK = 520 
		, SUBMULTISET_VK = 521 
		, SUBPARTITION_VK = 522 
		, SUBQUERY = 523 
		, SUSPEND_VK = 524 
		, TABLEVIEW_NAME = 525 
		, TABLE_ELEMENT = 526 
		, TABLE_EXPRESSION = 527 
		, TABLE_REF = 528 
		, TABLE_REF_ELEMENT = 529 
		, TABLE_VAR_NAME = 530 
		, TILDE_OPERATOR_PART = 531 
		, TIMESTAMP_LTZ_UNCONSTRAINED_VK = 532 
		, TIMESTAMP_TZ_UNCONSTRAINED_VK = 533 
		, TIMESTAMP_UNCONSTRAINED_VK = 534 
		, TIMESTAMP_VK = 535 
		, TIMEZONE_ABBR_VK = 536 
		, TIMEZONE_HOUR_VK = 537 
		, TIMEZONE_MINUTE_VK = 538 
		, TIMEZONE_REGION_VK = 539 
		, TIME_VK = 540 
		, TRAILING_VK = 541 
		, TRANSLATE_VK = 542 
		, TREAT_VK = 543 
		, TRIGGER_NAME = 544 
		, TRIM_VK = 545 
		, TRUNCATE_VK = 546 
		, TYPE_NAME = 547 
		, TYPE_VK = 548 
		, T_BINDVAR_NAME = 549 
		, T_COLUMN_ALIAS = 550 
		, T_COLUMN_LIST = 551 
		, T_COLUMN_NAME = 552 
		, T_COND_AND = 553 
		, T_COND_AND_SEQ = 554 
		, T_COND_BETWEEN = 555 
		, T_COND_COMPARISON = 556 
		, T_COND_EQUALS_PATH = 557 
		, T_COND_EXISTS = 558 
		, T_COND_GROUP_COMPARISON = 559 
		, T_COND_IN = 560 
		, T_COND_IS = 561 
		, T_COND_IS_ANY = 562 
		, T_COND_IS_A_SET = 563 
		, T_COND_IS_EMPTY = 564 
		, T_COND_IS_OF_TYPE = 565 
		, T_COND_IS_PRESENT = 566 
		, T_COND_LIKE = 567 
		, T_COND_MEMEBER = 568 
		, T_COND_NOT = 569 
		, T_COND_OR = 570 
		, T_COND_OR_SEQ = 571 
		, T_COND_PAREN = 572 
		, T_COND_REGEXP_LIKE = 573 
		, T_COND_SUBMULTISET = 574 
		, T_COND_UNDER_PATH = 575 
		, T_DBLINK_NAME = 576 
		, T_DECL = 577 
		, T_FOR_UPDATE_CLAUSE = 578 
		, T_FROM = 579 
		, T_FUNCTION_NAME = 580 
		, T_GROUP_BY = 581 
		, T_HIERARCHICAL = 582 
		, T_IDENTIFIER = 583 
		, T_JOINING_CLAUSE = 584 
		, T_MODEL = 585 
		, T_OPERATOR_BINARY = 586 
		, T_OPERATOR_PART = 587 
		, T_OPERATOR_UNARY = 588 
		, T_ORDER_BY_CLAUSE = 589 
		, T_PACKAGE_NAME = 590 
		, T_RESERVED = 591 
		, T_SCHEMA_NAME = 592 
		, T_SELECT = 593 
		, T_SELECT_COLUMN = 594 
		, T_SUBQUERY = 595 
		, T_TABLE_ALIAS = 596 
		, T_TABLE_CAST = 597 
		, T_TABLE_NAME = 598 
		, T_TABLE_REF = 599 
		, T_UNION = 600 
		, T_UNKNOWN = 601 
		, T_USE = 602 
		, T_WHERE = 603 
		, T_WITH = 604 
		, UNARY_OPERATOR = 605 
		, UNBOUNDED_VK = 606 
		, UNDERSCORE = 607 
		, UNDER_VK = 608 
		, UNLIMITED_VK = 609 
		, UNPIVOT_IN_ELEMENT = 610 
		, UNPIVOT_VK = 611 
		, UNSIGNED_INTEGER = 612 
		, UNTIL_VK = 613 
		, UPDATED_VK = 614 
		, UPSERT_VK = 615 
		, UROWID_VK = 616 
		, VALIDATE_VK = 617 
		, VALUE_VK = 618 
		, VARCHAR2_VK = 619 
		, VARCHAR_VK = 620 
		, VARIABLE_NAME = 621 
		, VECTOR_EXPR = 622 
		, VERSIONS_VK = 623 
		, VERSION_VK = 624 
		, VERTICAL_BAR = 625 
		, WAIT_VK = 626 
		, WELLFORMED_VK = 627 
		, WITHIN_VK = 628 
		, WORK_VK = 629 
		, WRITE_VK = 630 
		, XMLAGG_VK = 631 
		, XMLATTRIBUTES_VK = 632 
		, XMLCAST_VK = 633 
		, XMLCOLATTVAL_VK = 634 
		, XMLELEMENT_VK = 635 
		, XMLEXISTS_VK = 636 
		, XMLFOREST_VK = 637 
		, XMLNAMESPACES_VK = 638 
		, XMLPARSE_VK = 639 
		, XMLPI_VK = 640 
		, XMLQUERY_VK = 641 
		, XMLROOT_VK = 642 
		, XMLSERIALIZE_VK = 643 
		, XMLTABLE_VK = 644 
		, XML_ALIAS = 645 
		, XML_COLUMN = 646 
		, XML_COLUMN_NAME = 647 
		, XML_ELEMENT = 648 
		, XML_VK = 649 
		, YEAR_VK = 650 
		, YES_VK = 651 
		, YMINTERVAL_UNCONSTRAINED_VK = 652 
		, ZV = 653 
	};
};

/** Context tracking structure for OracleDML
 */
class OracleDML : public OracleDMLImplTraits::BaseParserType
    , public OracleDMLTokens
{
public:
	typedef OracleDMLImplTraits ImplTraits;
	typedef OracleDML ComponentType;
	typedef ComponentType::StreamType StreamType;
	typedef OracleDMLImplTraits::BaseParserType BaseType;
	typedef ImplTraits::RecognizerSharedStateType<StreamType> RecognizerSharedStateType;
	typedef StreamType InputType;
	typedef OracleDMLImplTraits::CommonTokenType CommonTokenType;
	typedef OracleDMLImplTraits::TreeAdaptorType TreeAdaptorType;

	static const bool IsFiltered = false;

	/* ruleAttributeScopeDecl(scope)
	 */
	/* makeScopeSet()
	 */
	 /** Definition of the case_statement scope variable tracking
	 *  structure. An instance of this structure is created by calling
	 *  OracleDML_case_statementPush().
	 */
	struct  case_statementScope
	{
	    /* =============================================================================
	     * Programmer defined variables...
	     */
	    int isStatement;

	    /* End of programmer defined variables
	     * =============================================================================
	     */
	};



private:	
	OracleDML_OracleDMLKeys*	 m_gOracleDMLKeys;
	OracleDML_OracleDMLCommons*	 m_gOracleDMLCommons;
    /* ruleAttributeScopeDef(scope)
     */
    ImplTraits::AllocPolicyType::StackType< case_statementScope >  m_case_statement_stack;



public:
    OracleDML(InputType* instream);
    OracleDML(InputType* instream, RecognizerSharedStateType* state);

    void init(InputType* instream  );
    static ANTLR_UINT8** getTokenNames();


    struct compilation_unit_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        compilation_unit_return()
            : BaseType()
            {}
        compilation_unit_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        compilation_unit_return( compilation_unit_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~compilation_unit_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        compilation_unit_return&
        operator=( compilation_unit_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct seq_of_statements_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        seq_of_statements_return()
            : BaseType()
            {}
        seq_of_statements_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        seq_of_statements_return( seq_of_statements_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~seq_of_statements_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        seq_of_statements_return&
        operator=( seq_of_statements_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct explain_statement_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        explain_statement_return()
            : BaseType()
            {}
        explain_statement_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        explain_statement_return( explain_statement_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~explain_statement_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        explain_statement_return&
        operator=( explain_statement_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct select_statement_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        select_statement_return()
            : BaseType()
            {}
        select_statement_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        select_statement_return( select_statement_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~select_statement_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        select_statement_return&
        operator=( select_statement_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct subquery_factoring_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        subquery_factoring_clause_return()
            : BaseType()
            {}
        subquery_factoring_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        subquery_factoring_clause_return( subquery_factoring_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~subquery_factoring_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        subquery_factoring_clause_return&
        operator=( subquery_factoring_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct factoring_element_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        factoring_element_return()
            : BaseType()
            {}
        factoring_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        factoring_element_return( factoring_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~factoring_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        factoring_element_return&
        operator=( factoring_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct search_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        search_clause_return()
            : BaseType()
            {}
        search_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        search_clause_return( search_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~search_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        search_clause_return&
        operator=( search_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct cycle_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        cycle_clause_return()
            : BaseType()
            {}
        cycle_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        cycle_clause_return( cycle_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~cycle_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        cycle_clause_return&
        operator=( cycle_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct subquery_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        subquery_return()
            : BaseType()
            {}
        subquery_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        subquery_return( subquery_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~subquery_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        subquery_return&
        operator=( subquery_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct subquery_operation_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        subquery_operation_part_return()
            : BaseType()
            {}
        subquery_operation_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        subquery_operation_part_return( subquery_operation_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~subquery_operation_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        subquery_operation_part_return&
        operator=( subquery_operation_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct subquery_basic_elements_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        subquery_basic_elements_return()
            : BaseType()
            {}
        subquery_basic_elements_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        subquery_basic_elements_return( subquery_basic_elements_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~subquery_basic_elements_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        subquery_basic_elements_return&
        operator=( subquery_basic_elements_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct query_block_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        query_block_return()
            : BaseType()
            {}
        query_block_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        query_block_return( query_block_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~query_block_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        query_block_return&
        operator=( query_block_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct selected_element_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        selected_element_return()
            : BaseType()
            {}
        selected_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        selected_element_return( selected_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~selected_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        selected_element_return&
        operator=( selected_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct from_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        from_clause_return()
            : BaseType()
            {}
        from_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        from_clause_return( from_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~from_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        from_clause_return&
        operator=( from_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct select_list_elements_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        select_list_elements_return()
            : BaseType()
            {}
        select_list_elements_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        select_list_elements_return( select_list_elements_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~select_list_elements_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        select_list_elements_return&
        operator=( select_list_elements_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct table_ref_list_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        table_ref_list_return()
            : BaseType()
            {}
        table_ref_list_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        table_ref_list_return( table_ref_list_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~table_ref_list_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        table_ref_list_return&
        operator=( table_ref_list_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct table_ref_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        table_ref_return()
            : BaseType()
            {}
        table_ref_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        table_ref_return( table_ref_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~table_ref_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        table_ref_return&
        operator=( table_ref_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct table_ref_aux_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        table_ref_aux_return()
            : BaseType()
            {}
        table_ref_aux_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        table_ref_aux_return( table_ref_aux_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~table_ref_aux_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        table_ref_aux_return&
        operator=( table_ref_aux_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct join_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        join_clause_return()
            : BaseType()
            {}
        join_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        join_clause_return( join_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~join_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        join_clause_return&
        operator=( join_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct join_on_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        join_on_part_return()
            : BaseType()
            {}
        join_on_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        join_on_part_return( join_on_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~join_on_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        join_on_part_return&
        operator=( join_on_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct join_using_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        join_using_part_return()
            : BaseType()
            {}
        join_using_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        join_using_part_return( join_using_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~join_using_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        join_using_part_return&
        operator=( join_using_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct outer_join_type_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        outer_join_type_return()
            : BaseType()
            {}
        outer_join_type_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        outer_join_type_return( outer_join_type_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~outer_join_type_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        outer_join_type_return&
        operator=( outer_join_type_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct query_partition_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        query_partition_clause_return()
            : BaseType()
            {}
        query_partition_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        query_partition_clause_return( query_partition_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~query_partition_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        query_partition_clause_return&
        operator=( query_partition_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct flashback_query_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        flashback_query_clause_return()
            : BaseType()
            {}
        flashback_query_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        flashback_query_clause_return( flashback_query_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~flashback_query_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        flashback_query_clause_return&
        operator=( flashback_query_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct pivot_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        pivot_clause_return()
            : BaseType()
            {}
        pivot_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        pivot_clause_return( pivot_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~pivot_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        pivot_clause_return&
        operator=( pivot_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct pivot_element_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        pivot_element_return()
            : BaseType()
            {}
        pivot_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        pivot_element_return( pivot_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~pivot_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        pivot_element_return&
        operator=( pivot_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct pivot_for_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        pivot_for_clause_return()
            : BaseType()
            {}
        pivot_for_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        pivot_for_clause_return( pivot_for_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~pivot_for_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        pivot_for_clause_return&
        operator=( pivot_for_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct pivot_in_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        pivot_in_clause_return()
            : BaseType()
            {}
        pivot_in_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        pivot_in_clause_return( pivot_in_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~pivot_in_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        pivot_in_clause_return&
        operator=( pivot_in_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct pivot_in_clause_element_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        pivot_in_clause_element_return()
            : BaseType()
            {}
        pivot_in_clause_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        pivot_in_clause_element_return( pivot_in_clause_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~pivot_in_clause_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        pivot_in_clause_element_return&
        operator=( pivot_in_clause_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct pivot_in_clause_elements_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        pivot_in_clause_elements_return()
            : BaseType()
            {}
        pivot_in_clause_elements_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        pivot_in_clause_elements_return( pivot_in_clause_elements_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~pivot_in_clause_elements_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        pivot_in_clause_elements_return&
        operator=( pivot_in_clause_elements_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct unpivot_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        unpivot_clause_return()
            : BaseType()
            {}
        unpivot_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        unpivot_clause_return( unpivot_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~unpivot_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        unpivot_clause_return&
        operator=( unpivot_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct unpivot_in_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        unpivot_in_clause_return()
            : BaseType()
            {}
        unpivot_in_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        unpivot_in_clause_return( unpivot_in_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~unpivot_in_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        unpivot_in_clause_return&
        operator=( unpivot_in_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct unpivot_in_elements_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        unpivot_in_elements_return()
            : BaseType()
            {}
        unpivot_in_elements_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        unpivot_in_elements_return( unpivot_in_elements_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~unpivot_in_elements_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        unpivot_in_elements_return&
        operator=( unpivot_in_elements_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct hierarchical_query_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        hierarchical_query_clause_return()
            : BaseType()
            {}
        hierarchical_query_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        hierarchical_query_clause_return( hierarchical_query_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~hierarchical_query_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        hierarchical_query_clause_return&
        operator=( hierarchical_query_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct start_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        start_part_return()
            : BaseType()
            {}
        start_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        start_part_return( start_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~start_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        start_part_return&
        operator=( start_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct group_by_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        group_by_clause_return()
            : BaseType()
            {}
        group_by_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        group_by_clause_return( group_by_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~group_by_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        group_by_clause_return&
        operator=( group_by_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct group_by_elements_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        group_by_elements_return()
            : BaseType()
            {}
        group_by_elements_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        group_by_elements_return( group_by_elements_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~group_by_elements_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        group_by_elements_return&
        operator=( group_by_elements_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct rollup_cube_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        rollup_cube_clause_return()
            : BaseType()
            {}
        rollup_cube_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        rollup_cube_clause_return( rollup_cube_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~rollup_cube_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        rollup_cube_clause_return&
        operator=( rollup_cube_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct grouping_sets_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        grouping_sets_clause_return()
            : BaseType()
            {}
        grouping_sets_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        grouping_sets_clause_return( grouping_sets_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~grouping_sets_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        grouping_sets_clause_return&
        operator=( grouping_sets_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct grouping_sets_elements_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        grouping_sets_elements_return()
            : BaseType()
            {}
        grouping_sets_elements_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        grouping_sets_elements_return( grouping_sets_elements_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~grouping_sets_elements_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        grouping_sets_elements_return&
        operator=( grouping_sets_elements_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct having_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        having_clause_return()
            : BaseType()
            {}
        having_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        having_clause_return( having_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~having_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        having_clause_return&
        operator=( having_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct model_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        model_clause_return()
            : BaseType()
            {}
        model_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        model_clause_return( model_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~model_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        model_clause_return&
        operator=( model_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct cell_reference_options_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        cell_reference_options_return()
            : BaseType()
            {}
        cell_reference_options_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        cell_reference_options_return( cell_reference_options_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~cell_reference_options_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        cell_reference_options_return&
        operator=( cell_reference_options_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct return_rows_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        return_rows_clause_return()
            : BaseType()
            {}
        return_rows_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        return_rows_clause_return( return_rows_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~return_rows_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        return_rows_clause_return&
        operator=( return_rows_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct reference_model_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        reference_model_return()
            : BaseType()
            {}
        reference_model_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        reference_model_return( reference_model_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~reference_model_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        reference_model_return&
        operator=( reference_model_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct main_model_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        main_model_return()
            : BaseType()
            {}
        main_model_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        main_model_return( main_model_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~main_model_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        main_model_return&
        operator=( main_model_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct model_column_clauses_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        model_column_clauses_return()
            : BaseType()
            {}
        model_column_clauses_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        model_column_clauses_return( model_column_clauses_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~model_column_clauses_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        model_column_clauses_return&
        operator=( model_column_clauses_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct model_column_partition_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        model_column_partition_part_return()
            : BaseType()
            {}
        model_column_partition_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        model_column_partition_part_return( model_column_partition_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~model_column_partition_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        model_column_partition_part_return&
        operator=( model_column_partition_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct model_column_list_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        model_column_list_return()
            : BaseType()
            {}
        model_column_list_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        model_column_list_return( model_column_list_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~model_column_list_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        model_column_list_return&
        operator=( model_column_list_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct model_column_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        model_column_return()
            : BaseType()
            {}
        model_column_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        model_column_return( model_column_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~model_column_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        model_column_return&
        operator=( model_column_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct model_rules_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        model_rules_clause_return()
            : BaseType()
            {}
        model_rules_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        model_rules_clause_return( model_rules_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~model_rules_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        model_rules_clause_return&
        operator=( model_rules_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct model_rules_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        model_rules_part_return()
            : BaseType()
            {}
        model_rules_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        model_rules_part_return( model_rules_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~model_rules_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        model_rules_part_return&
        operator=( model_rules_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct model_rules_element_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        model_rules_element_return()
            : BaseType()
            {}
        model_rules_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        model_rules_element_return( model_rules_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~model_rules_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        model_rules_element_return&
        operator=( model_rules_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct cell_assignment_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        cell_assignment_return()
            : BaseType()
            {}
        cell_assignment_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        cell_assignment_return( cell_assignment_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~cell_assignment_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        cell_assignment_return&
        operator=( cell_assignment_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct model_iterate_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        model_iterate_clause_return()
            : BaseType()
            {}
        model_iterate_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        model_iterate_clause_return( model_iterate_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~model_iterate_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        model_iterate_clause_return&
        operator=( model_iterate_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct until_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        until_part_return()
            : BaseType()
            {}
        until_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        until_part_return( until_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~until_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        until_part_return&
        operator=( until_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct order_by_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        order_by_clause_return()
            : BaseType()
            {}
        order_by_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        order_by_clause_return( order_by_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~order_by_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        order_by_clause_return&
        operator=( order_by_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct order_by_elements_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        order_by_elements_return()
            : BaseType()
            {}
        order_by_elements_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        order_by_elements_return( order_by_elements_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~order_by_elements_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        order_by_elements_return&
        operator=( order_by_elements_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct for_update_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        for_update_clause_return()
            : BaseType()
            {}
        for_update_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        for_update_clause_return( for_update_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~for_update_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        for_update_clause_return&
        operator=( for_update_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct for_update_of_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        for_update_of_part_return()
            : BaseType()
            {}
        for_update_of_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        for_update_of_part_return( for_update_of_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~for_update_of_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        for_update_of_part_return&
        operator=( for_update_of_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct for_update_options_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        for_update_options_return()
            : BaseType()
            {}
        for_update_options_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        for_update_options_return( for_update_options_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~for_update_options_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        for_update_options_return&
        operator=( for_update_options_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct update_statement_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        update_statement_return()
            : BaseType()
            {}
        update_statement_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        update_statement_return( update_statement_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~update_statement_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        update_statement_return&
        operator=( update_statement_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct update_set_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        update_set_clause_return()
            : BaseType()
            {}
        update_set_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        update_set_clause_return( update_set_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~update_set_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        update_set_clause_return&
        operator=( update_set_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct column_based_update_set_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        column_based_update_set_clause_return()
            : BaseType()
            {}
        column_based_update_set_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        column_based_update_set_clause_return( column_based_update_set_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~column_based_update_set_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        column_based_update_set_clause_return&
        operator=( column_based_update_set_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct delete_statement_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        delete_statement_return()
            : BaseType()
            {}
        delete_statement_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        delete_statement_return( delete_statement_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~delete_statement_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        delete_statement_return&
        operator=( delete_statement_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct insert_statement_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        insert_statement_return()
            : BaseType()
            {}
        insert_statement_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        insert_statement_return( insert_statement_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~insert_statement_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        insert_statement_return&
        operator=( insert_statement_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct single_table_insert_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        single_table_insert_return()
            : BaseType()
            {}
        single_table_insert_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        single_table_insert_return( single_table_insert_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~single_table_insert_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        single_table_insert_return&
        operator=( single_table_insert_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct multi_table_insert_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        multi_table_insert_return()
            : BaseType()
            {}
        multi_table_insert_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        multi_table_insert_return( multi_table_insert_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~multi_table_insert_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        multi_table_insert_return&
        operator=( multi_table_insert_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct multi_table_element_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        multi_table_element_return()
            : BaseType()
            {}
        multi_table_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        multi_table_element_return( multi_table_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~multi_table_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        multi_table_element_return&
        operator=( multi_table_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct conditional_insert_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        conditional_insert_clause_return()
            : BaseType()
            {}
        conditional_insert_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        conditional_insert_clause_return( conditional_insert_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~conditional_insert_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        conditional_insert_clause_return&
        operator=( conditional_insert_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct conditional_insert_when_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        conditional_insert_when_part_return()
            : BaseType()
            {}
        conditional_insert_when_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        conditional_insert_when_part_return( conditional_insert_when_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~conditional_insert_when_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        conditional_insert_when_part_return&
        operator=( conditional_insert_when_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct conditional_insert_else_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        conditional_insert_else_part_return()
            : BaseType()
            {}
        conditional_insert_else_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        conditional_insert_else_part_return( conditional_insert_else_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~conditional_insert_else_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        conditional_insert_else_part_return&
        operator=( conditional_insert_else_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct insert_into_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        insert_into_clause_return()
            : BaseType()
            {}
        insert_into_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        insert_into_clause_return( insert_into_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~insert_into_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        insert_into_clause_return&
        operator=( insert_into_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct values_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        values_clause_return()
            : BaseType()
            {}
        values_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        values_clause_return( values_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~values_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        values_clause_return&
        operator=( values_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct merge_statement_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        merge_statement_return()
            : BaseType()
            {}
        merge_statement_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        merge_statement_return( merge_statement_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~merge_statement_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        merge_statement_return&
        operator=( merge_statement_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct merge_update_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        merge_update_clause_return()
            : BaseType()
            {}
        merge_update_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        merge_update_clause_return( merge_update_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~merge_update_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        merge_update_clause_return&
        operator=( merge_update_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct merge_element_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        merge_element_return()
            : BaseType()
            {}
        merge_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        merge_element_return( merge_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~merge_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        merge_element_return&
        operator=( merge_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct merge_update_delete_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        merge_update_delete_part_return()
            : BaseType()
            {}
        merge_update_delete_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        merge_update_delete_part_return( merge_update_delete_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~merge_update_delete_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        merge_update_delete_part_return&
        operator=( merge_update_delete_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct merge_insert_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        merge_insert_clause_return()
            : BaseType()
            {}
        merge_insert_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        merge_insert_clause_return( merge_insert_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~merge_insert_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        merge_insert_clause_return&
        operator=( merge_insert_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct selected_tableview_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        selected_tableview_return()
            : BaseType()
            {}
        selected_tableview_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        selected_tableview_return( selected_tableview_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~selected_tableview_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        selected_tableview_return&
        operator=( selected_tableview_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct lock_table_statement_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        lock_table_statement_return()
            : BaseType()
            {}
        lock_table_statement_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        lock_table_statement_return( lock_table_statement_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~lock_table_statement_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        lock_table_statement_return&
        operator=( lock_table_statement_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct wait_nowait_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        wait_nowait_part_return()
            : BaseType()
            {}
        wait_nowait_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        wait_nowait_part_return( wait_nowait_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~wait_nowait_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        wait_nowait_part_return&
        operator=( wait_nowait_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct lock_table_element_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        lock_table_element_return()
            : BaseType()
            {}
        lock_table_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        lock_table_element_return( lock_table_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~lock_table_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        lock_table_element_return&
        operator=( lock_table_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct lock_mode_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        lock_mode_return()
            : BaseType()
            {}
        lock_mode_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        lock_mode_return( lock_mode_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~lock_mode_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        lock_mode_return&
        operator=( lock_mode_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct general_table_ref_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        general_table_ref_return()
            : BaseType()
            {}
        general_table_ref_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        general_table_ref_return( general_table_ref_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~general_table_ref_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        general_table_ref_return&
        operator=( general_table_ref_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct static_returning_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        static_returning_clause_return()
            : BaseType()
            {}
        static_returning_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        static_returning_clause_return( static_returning_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~static_returning_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        static_returning_clause_return&
        operator=( static_returning_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct error_logging_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        error_logging_clause_return()
            : BaseType()
            {}
        error_logging_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        error_logging_clause_return( error_logging_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~error_logging_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        error_logging_clause_return&
        operator=( error_logging_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct error_logging_into_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        error_logging_into_part_return()
            : BaseType()
            {}
        error_logging_into_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        error_logging_into_part_return( error_logging_into_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~error_logging_into_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        error_logging_into_part_return&
        operator=( error_logging_into_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct error_logging_reject_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        error_logging_reject_part_return()
            : BaseType()
            {}
        error_logging_reject_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        error_logging_reject_part_return( error_logging_reject_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~error_logging_reject_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        error_logging_reject_part_return&
        operator=( error_logging_reject_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct dml_table_expression_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        dml_table_expression_clause_return()
            : BaseType()
            {}
        dml_table_expression_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        dml_table_expression_clause_return( dml_table_expression_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~dml_table_expression_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        dml_table_expression_clause_return&
        operator=( dml_table_expression_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct table_collection_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        table_collection_expression_return()
            : BaseType()
            {}
        table_collection_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        table_collection_expression_return( table_collection_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~table_collection_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        table_collection_expression_return&
        operator=( table_collection_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct subquery_restriction_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        subquery_restriction_clause_return()
            : BaseType()
            {}
        subquery_restriction_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        subquery_restriction_clause_return( subquery_restriction_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~subquery_restriction_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        subquery_restriction_clause_return&
        operator=( subquery_restriction_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct sample_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        sample_clause_return()
            : BaseType()
            {}
        sample_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        sample_clause_return( sample_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~sample_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        sample_clause_return&
        operator=( sample_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct seed_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        seed_part_return()
            : BaseType()
            {}
        seed_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        seed_part_return( seed_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~seed_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        seed_part_return&
        operator=( seed_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct cursor_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        cursor_expression_return()
            : BaseType()
            {}
        cursor_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        cursor_expression_return( cursor_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~cursor_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        cursor_expression_return&
        operator=( cursor_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct expression_list_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        expression_list_return()
            : BaseType()
            {}
        expression_list_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        expression_list_return( expression_list_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~expression_list_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        expression_list_return&
        operator=( expression_list_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct condition_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        condition_return()
            : BaseType()
            {}
        condition_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        condition_return( condition_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~condition_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        condition_return&
        operator=( condition_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct condition_wrapper_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        condition_wrapper_return()
            : BaseType()
            {}
        condition_wrapper_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        condition_wrapper_return( condition_wrapper_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~condition_wrapper_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        condition_wrapper_return&
        operator=( condition_wrapper_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        expression_return()
            : BaseType()
            {}
        expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        expression_return( expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        expression_return&
        operator=( expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct expression_wrapper_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        expression_wrapper_return()
            : BaseType()
            {}
        expression_wrapper_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        expression_wrapper_return( expression_wrapper_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~expression_wrapper_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        expression_wrapper_return&
        operator=( expression_wrapper_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct logical_and_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        logical_and_expression_return()
            : BaseType()
            {}
        logical_and_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        logical_and_expression_return( logical_and_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~logical_and_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        logical_and_expression_return&
        operator=( logical_and_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct negated_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        negated_expression_return()
            : BaseType()
            {}
        negated_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        negated_expression_return( negated_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~negated_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        negated_expression_return&
        operator=( negated_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct equality_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        equality_expression_return()
            : BaseType()
            {}
        equality_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        equality_expression_return( equality_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~equality_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        equality_expression_return&
        operator=( equality_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct multiset_comparsion_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        multiset_comparsion_return()
            : BaseType()
            {}
        multiset_comparsion_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        multiset_comparsion_return( multiset_comparsion_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~multiset_comparsion_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        multiset_comparsion_return&
        operator=( multiset_comparsion_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct multiset_type_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        multiset_type_return()
            : BaseType()
            {}
        multiset_type_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        multiset_type_return( multiset_type_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~multiset_type_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        multiset_type_return&
        operator=( multiset_type_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct relational_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        relational_expression_return()
            : BaseType()
            {}
        relational_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        relational_expression_return( relational_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~relational_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        relational_expression_return&
        operator=( relational_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct compound_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        compound_expression_return()
            : BaseType()
            {}
        compound_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        compound_expression_return( compound_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~compound_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        compound_expression_return&
        operator=( compound_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct like_type_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        like_type_return()
            : BaseType()
            {}
        like_type_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        like_type_return( like_type_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~like_type_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        like_type_return&
        operator=( like_type_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct like_escape_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        like_escape_part_return()
            : BaseType()
            {}
        like_escape_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        like_escape_part_return( like_escape_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~like_escape_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        like_escape_part_return&
        operator=( like_escape_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct in_elements_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        in_elements_return()
            : BaseType()
            {}
        in_elements_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        in_elements_return( in_elements_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~in_elements_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        in_elements_return&
        operator=( in_elements_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct between_elements_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        between_elements_return()
            : BaseType()
            {}
        between_elements_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        between_elements_return( between_elements_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~between_elements_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        between_elements_return&
        operator=( between_elements_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct concatenation_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        concatenation_return()
            : BaseType()
            {}
        concatenation_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        concatenation_return( concatenation_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~concatenation_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        concatenation_return&
        operator=( concatenation_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct concatenation_wrapper_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        concatenation_wrapper_return()
            : BaseType()
            {}
        concatenation_wrapper_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        concatenation_wrapper_return( concatenation_wrapper_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~concatenation_wrapper_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        concatenation_wrapper_return&
        operator=( concatenation_wrapper_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct additive_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        additive_expression_return()
            : BaseType()
            {}
        additive_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        additive_expression_return( additive_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~additive_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        additive_expression_return&
        operator=( additive_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct multiply_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        multiply_expression_return()
            : BaseType()
            {}
        multiply_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        multiply_expression_return( multiply_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~multiply_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        multiply_expression_return&
        operator=( multiply_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct datetime_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        datetime_expression_return()
            : BaseType()
            {}
        datetime_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        datetime_expression_return( datetime_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~datetime_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        datetime_expression_return&
        operator=( datetime_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct interval_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        interval_expression_return()
            : BaseType()
            {}
        interval_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        interval_expression_return( interval_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~interval_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        interval_expression_return&
        operator=( interval_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct model_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        model_expression_return()
            : BaseType()
            {}
        model_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        model_expression_return( model_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~model_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        model_expression_return&
        operator=( model_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct model_expression_element_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        model_expression_element_return()
            : BaseType()
            {}
        model_expression_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        model_expression_element_return( model_expression_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~model_expression_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        model_expression_element_return&
        operator=( model_expression_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct single_column_for_loop_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        single_column_for_loop_return()
            : BaseType()
            {}
        single_column_for_loop_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        single_column_for_loop_return( single_column_for_loop_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~single_column_for_loop_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        single_column_for_loop_return&
        operator=( single_column_for_loop_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct for_like_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        for_like_part_return()
            : BaseType()
            {}
        for_like_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        for_like_part_return( for_like_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~for_like_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        for_like_part_return&
        operator=( for_like_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct for_increment_decrement_type_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        for_increment_decrement_type_return()
            : BaseType()
            {}
        for_increment_decrement_type_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        for_increment_decrement_type_return( for_increment_decrement_type_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~for_increment_decrement_type_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        for_increment_decrement_type_return&
        operator=( for_increment_decrement_type_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct multi_column_for_loop_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        multi_column_for_loop_return()
            : BaseType()
            {}
        multi_column_for_loop_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        multi_column_for_loop_return( multi_column_for_loop_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~multi_column_for_loop_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        multi_column_for_loop_return&
        operator=( multi_column_for_loop_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct multiset_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        multiset_expression_return()
            : BaseType()
            {}
        multiset_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        multiset_expression_return( multiset_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~multiset_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        multiset_expression_return&
        operator=( multiset_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct unary_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        unary_expression_return()
            : BaseType()
            {}
        unary_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        unary_expression_return( unary_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~unary_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        unary_expression_return&
        operator=( unary_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct case_statement_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        case_statement_return()
            : BaseType()
            {}
        case_statement_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        case_statement_return( case_statement_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~case_statement_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        case_statement_return&
        operator=( case_statement_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct simple_case_statement_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        simple_case_statement_return()
            : BaseType()
            {}
        simple_case_statement_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        simple_case_statement_return( simple_case_statement_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~simple_case_statement_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        simple_case_statement_return&
        operator=( simple_case_statement_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct simple_case_when_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        simple_case_when_part_return()
            : BaseType()
            {}
        simple_case_when_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        simple_case_when_part_return( simple_case_when_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~simple_case_when_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        simple_case_when_part_return&
        operator=( simple_case_when_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct searched_case_statement_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        searched_case_statement_return()
            : BaseType()
            {}
        searched_case_statement_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        searched_case_statement_return( searched_case_statement_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~searched_case_statement_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        searched_case_statement_return&
        operator=( searched_case_statement_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct searched_case_when_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        searched_case_when_part_return()
            : BaseType()
            {}
        searched_case_when_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        searched_case_when_part_return( searched_case_when_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~searched_case_when_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        searched_case_when_part_return&
        operator=( searched_case_when_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct case_else_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        case_else_part_return()
            : BaseType()
            {}
        case_else_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        case_else_part_return( case_else_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~case_else_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        case_else_part_return&
        operator=( case_else_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct atom_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        atom_return()
            : BaseType()
            {}
        atom_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        atom_return( atom_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~atom_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        atom_return&
        operator=( atom_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct expression_or_vector_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        expression_or_vector_return()
            : BaseType()
            {}
        expression_or_vector_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        expression_or_vector_return( expression_or_vector_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~expression_or_vector_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        expression_or_vector_return&
        operator=( expression_or_vector_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct vector_expr_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        vector_expr_return()
            : BaseType()
            {}
        vector_expr_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        vector_expr_return( vector_expr_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~vector_expr_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        vector_expr_return&
        operator=( vector_expr_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct quantified_expression_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        quantified_expression_return()
            : BaseType()
            {}
        quantified_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        quantified_expression_return( quantified_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~quantified_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        quantified_expression_return&
        operator=( quantified_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct standard_function_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        standard_function_return()
            : BaseType()
            {}
        standard_function_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        standard_function_return( standard_function_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~standard_function_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        standard_function_return&
        operator=( standard_function_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct stantard_function_enabling_over_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        stantard_function_enabling_over_return()
            : BaseType()
            {}
        stantard_function_enabling_over_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        stantard_function_enabling_over_return( stantard_function_enabling_over_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~stantard_function_enabling_over_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        stantard_function_enabling_over_return&
        operator=( stantard_function_enabling_over_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct stantard_function_enabling_using_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        stantard_function_enabling_using_return()
            : BaseType()
            {}
        stantard_function_enabling_using_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        stantard_function_enabling_using_return( stantard_function_enabling_using_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~stantard_function_enabling_using_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        stantard_function_enabling_using_return&
        operator=( stantard_function_enabling_using_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct stantard_function_enabling_within_or_over_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        stantard_function_enabling_within_or_over_return()
            : BaseType()
            {}
        stantard_function_enabling_within_or_over_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        stantard_function_enabling_within_or_over_return( stantard_function_enabling_within_or_over_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~stantard_function_enabling_within_or_over_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        stantard_function_enabling_within_or_over_return&
        operator=( stantard_function_enabling_within_or_over_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct stantard_function_pedictions_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        stantard_function_pedictions_return()
            : BaseType()
            {}
        stantard_function_pedictions_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        stantard_function_pedictions_return( stantard_function_pedictions_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~stantard_function_pedictions_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        stantard_function_pedictions_return&
        operator=( stantard_function_pedictions_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct over_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        over_clause_return()
            : BaseType()
            {}
        over_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        over_clause_return( over_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~over_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        over_clause_return&
        operator=( over_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct windowing_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        windowing_clause_return()
            : BaseType()
            {}
        windowing_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        windowing_clause_return( windowing_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~windowing_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        windowing_clause_return&
        operator=( windowing_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct windowing_type_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        windowing_type_return()
            : BaseType()
            {}
        windowing_type_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        windowing_type_return( windowing_type_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~windowing_type_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        windowing_type_return&
        operator=( windowing_type_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct windowing_elements_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        windowing_elements_return()
            : BaseType()
            {}
        windowing_elements_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        windowing_elements_return( windowing_elements_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~windowing_elements_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        windowing_elements_return&
        operator=( windowing_elements_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct using_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        using_clause_return()
            : BaseType()
            {}
        using_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        using_clause_return( using_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~using_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        using_clause_return&
        operator=( using_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct using_element_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        using_element_return()
            : BaseType()
            {}
        using_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        using_element_return( using_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~using_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        using_element_return&
        operator=( using_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct collect_order_by_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        collect_order_by_part_return()
            : BaseType()
            {}
        collect_order_by_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        collect_order_by_part_return( collect_order_by_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~collect_order_by_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        collect_order_by_part_return&
        operator=( collect_order_by_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct within_or_over_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        within_or_over_part_return()
            : BaseType()
            {}
        within_or_over_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        within_or_over_part_return( within_or_over_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~within_or_over_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        within_or_over_part_return&
        operator=( within_or_over_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct cost_matrix_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        cost_matrix_clause_return()
            : BaseType()
            {}
        cost_matrix_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        cost_matrix_clause_return( cost_matrix_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~cost_matrix_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        cost_matrix_clause_return&
        operator=( cost_matrix_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct xml_passing_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        xml_passing_clause_return()
            : BaseType()
            {}
        xml_passing_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        xml_passing_clause_return( xml_passing_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~xml_passing_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        xml_passing_clause_return&
        operator=( xml_passing_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct xml_attributes_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        xml_attributes_clause_return()
            : BaseType()
            {}
        xml_attributes_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        xml_attributes_clause_return( xml_attributes_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~xml_attributes_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        xml_attributes_clause_return&
        operator=( xml_attributes_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct xml_namespaces_clause_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        xml_namespaces_clause_return()
            : BaseType()
            {}
        xml_namespaces_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        xml_namespaces_clause_return( xml_namespaces_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~xml_namespaces_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        xml_namespaces_clause_return&
        operator=( xml_namespaces_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct xml_table_column_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        xml_table_column_return()
            : BaseType()
            {}
        xml_table_column_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        xml_table_column_return( xml_table_column_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~xml_table_column_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        xml_table_column_return&
        operator=( xml_table_column_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct xml_general_default_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        xml_general_default_part_return()
            : BaseType()
            {}
        xml_general_default_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        xml_general_default_part_return( xml_general_default_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~xml_general_default_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        xml_general_default_part_return&
        operator=( xml_general_default_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct xml_multiuse_expression_element_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        xml_multiuse_expression_element_return()
            : BaseType()
            {}
        xml_multiuse_expression_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        xml_multiuse_expression_element_return( xml_multiuse_expression_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~xml_multiuse_expression_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        xml_multiuse_expression_element_return&
        operator=( xml_multiuse_expression_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct xmlroot_param_version_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        xmlroot_param_version_part_return()
            : BaseType()
            {}
        xmlroot_param_version_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        xmlroot_param_version_part_return( xmlroot_param_version_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~xmlroot_param_version_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        xmlroot_param_version_part_return&
        operator=( xmlroot_param_version_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct xmlroot_param_standalone_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        xmlroot_param_standalone_part_return()
            : BaseType()
            {}
        xmlroot_param_standalone_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        xmlroot_param_standalone_part_return( xmlroot_param_standalone_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~xmlroot_param_standalone_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        xmlroot_param_standalone_part_return&
        operator=( xmlroot_param_standalone_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct xmlserialize_param_enconding_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        xmlserialize_param_enconding_part_return()
            : BaseType()
            {}
        xmlserialize_param_enconding_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        xmlserialize_param_enconding_part_return( xmlserialize_param_enconding_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~xmlserialize_param_enconding_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        xmlserialize_param_enconding_part_return&
        operator=( xmlserialize_param_enconding_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct xmlserialize_param_version_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        xmlserialize_param_version_part_return()
            : BaseType()
            {}
        xmlserialize_param_version_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        xmlserialize_param_version_part_return( xmlserialize_param_version_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~xmlserialize_param_version_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        xmlserialize_param_version_part_return&
        operator=( xmlserialize_param_version_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct xmlserialize_param_ident_part_return : public OracleDMLImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDMLImplTraits::RuleReturnValueType BaseType;
        xmlserialize_param_ident_part_return()
            : BaseType()
            {}
        xmlserialize_param_ident_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        xmlserialize_param_ident_part_return( xmlserialize_param_ident_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~xmlserialize_param_ident_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        xmlserialize_param_ident_part_return&
        operator=( xmlserialize_param_ident_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


     OracleDML::compilation_unit_return compilation_unit (); 
     OracleDML::seq_of_statements_return seq_of_statements (); 
     OracleDML::explain_statement_return explain_statement (); 
     OracleDML::select_statement_return select_statement (); 
     OracleDML::subquery_factoring_clause_return subquery_factoring_clause (); 
     OracleDML::factoring_element_return factoring_element (); 
     OracleDML::search_clause_return search_clause (); 
     OracleDML::cycle_clause_return cycle_clause (); 
     OracleDML::subquery_return subquery (); 
     OracleDML::subquery_operation_part_return subquery_operation_part (); 
     OracleDML::subquery_basic_elements_return subquery_basic_elements (); 
     OracleDML::query_block_return query_block (); 
     OracleDML::selected_element_return selected_element (); 
     OracleDML::from_clause_return from_clause (); 
     OracleDML::select_list_elements_return select_list_elements (); 
     OracleDML::table_ref_list_return table_ref_list (); 
     OracleDML::table_ref_return table_ref (); 
     OracleDML::table_ref_aux_return table_ref_aux (); 
     OracleDML::join_clause_return join_clause (); 
     OracleDML::join_on_part_return join_on_part (); 
     OracleDML::join_using_part_return join_using_part (); 
     OracleDML::outer_join_type_return outer_join_type (); 
     OracleDML::query_partition_clause_return query_partition_clause (); 
     OracleDML::flashback_query_clause_return flashback_query_clause (); 
     OracleDML::pivot_clause_return pivot_clause (); 
     OracleDML::pivot_element_return pivot_element (); 
     OracleDML::pivot_for_clause_return pivot_for_clause (); 
     OracleDML::pivot_in_clause_return pivot_in_clause (); 
     OracleDML::pivot_in_clause_element_return pivot_in_clause_element (); 
     OracleDML::pivot_in_clause_elements_return pivot_in_clause_elements (); 
     OracleDML::unpivot_clause_return unpivot_clause (); 
     OracleDML::unpivot_in_clause_return unpivot_in_clause (); 
     OracleDML::unpivot_in_elements_return unpivot_in_elements (); 
     OracleDML::hierarchical_query_clause_return hierarchical_query_clause (); 
     OracleDML::start_part_return start_part (); 
     OracleDML::group_by_clause_return group_by_clause (); 
     OracleDML::group_by_elements_return group_by_elements (); 
     OracleDML::rollup_cube_clause_return rollup_cube_clause (); 
     OracleDML::grouping_sets_clause_return grouping_sets_clause (); 
     OracleDML::grouping_sets_elements_return grouping_sets_elements (); 
     OracleDML::having_clause_return having_clause (); 
     OracleDML::model_clause_return model_clause (); 
     OracleDML::cell_reference_options_return cell_reference_options (); 
     OracleDML::return_rows_clause_return return_rows_clause (); 
     OracleDML::reference_model_return reference_model (); 
     OracleDML::main_model_return main_model (); 
     OracleDML::model_column_clauses_return model_column_clauses (); 
     OracleDML::model_column_partition_part_return model_column_partition_part (); 
     OracleDML::model_column_list_return model_column_list (); 
     OracleDML::model_column_return model_column (); 
     OracleDML::model_rules_clause_return model_rules_clause (); 
     OracleDML::model_rules_part_return model_rules_part (); 
     OracleDML::model_rules_element_return model_rules_element (); 
     OracleDML::cell_assignment_return cell_assignment (); 
     OracleDML::model_iterate_clause_return model_iterate_clause (); 
     OracleDML::until_part_return until_part (); 
     OracleDML::order_by_clause_return order_by_clause (); 
     OracleDML::order_by_elements_return order_by_elements (); 
     OracleDML::for_update_clause_return for_update_clause (); 
     OracleDML::for_update_of_part_return for_update_of_part (); 
     OracleDML::for_update_options_return for_update_options (); 
     OracleDML::update_statement_return update_statement (); 
     OracleDML::update_set_clause_return update_set_clause (); 
     OracleDML::column_based_update_set_clause_return column_based_update_set_clause (); 
     OracleDML::delete_statement_return delete_statement (); 
     OracleDML::insert_statement_return insert_statement (); 
     OracleDML::single_table_insert_return single_table_insert (); 
     OracleDML::multi_table_insert_return multi_table_insert (); 
     OracleDML::multi_table_element_return multi_table_element (); 
     OracleDML::conditional_insert_clause_return conditional_insert_clause (); 
     OracleDML::conditional_insert_when_part_return conditional_insert_when_part (); 
     OracleDML::conditional_insert_else_part_return conditional_insert_else_part (); 
     OracleDML::insert_into_clause_return insert_into_clause (); 
     OracleDML::values_clause_return values_clause (); 
     OracleDML::merge_statement_return merge_statement (); 
     OracleDML::merge_update_clause_return merge_update_clause (); 
     OracleDML::merge_element_return merge_element (); 
     OracleDML::merge_update_delete_part_return merge_update_delete_part (); 
     OracleDML::merge_insert_clause_return merge_insert_clause (); 
     OracleDML::selected_tableview_return selected_tableview (); 
     OracleDML::lock_table_statement_return lock_table_statement (); 
     OracleDML::wait_nowait_part_return wait_nowait_part (); 
     OracleDML::lock_table_element_return lock_table_element (); 
     OracleDML::lock_mode_return lock_mode (); 
     OracleDML::general_table_ref_return general_table_ref (); 
     OracleDML::static_returning_clause_return static_returning_clause (); 
     OracleDML::error_logging_clause_return error_logging_clause (); 
     OracleDML::error_logging_into_part_return error_logging_into_part (); 
     OracleDML::error_logging_reject_part_return error_logging_reject_part (); 
     OracleDML::dml_table_expression_clause_return dml_table_expression_clause (); 
     OracleDML::table_collection_expression_return table_collection_expression (); 
     OracleDML::subquery_restriction_clause_return subquery_restriction_clause (); 
     OracleDML::sample_clause_return sample_clause (); 
     OracleDML::seed_part_return seed_part (); 
     OracleDML::cursor_expression_return cursor_expression (); 
     OracleDML::expression_list_return expression_list (); 
     OracleDML::condition_return condition (); 
     OracleDML::condition_wrapper_return condition_wrapper (); 
     OracleDML::expression_return expression (); 
     OracleDML::expression_wrapper_return expression_wrapper (); 
     OracleDML::logical_and_expression_return logical_and_expression (); 
     OracleDML::negated_expression_return negated_expression (); 
     OracleDML::equality_expression_return equality_expression (); 
     OracleDML::multiset_comparsion_return multiset_comparsion (); 
     OracleDML::multiset_type_return multiset_type (); 
     OracleDML::relational_expression_return relational_expression (); 
     OracleDML::compound_expression_return compound_expression (); 
     OracleDML::like_type_return like_type (); 
     OracleDML::like_escape_part_return like_escape_part (); 
     OracleDML::in_elements_return in_elements (); 
     OracleDML::between_elements_return between_elements (); 
     OracleDML::concatenation_return concatenation (); 
     OracleDML::concatenation_wrapper_return concatenation_wrapper (); 
     OracleDML::additive_expression_return additive_expression (); 
     OracleDML::multiply_expression_return multiply_expression (); 
     OracleDML::datetime_expression_return datetime_expression (); 
     OracleDML::interval_expression_return interval_expression (); 
     OracleDML::model_expression_return model_expression (); 
     OracleDML::model_expression_element_return model_expression_element (); 
     OracleDML::single_column_for_loop_return single_column_for_loop (); 
     OracleDML::for_like_part_return for_like_part (); 
     OracleDML::for_increment_decrement_type_return for_increment_decrement_type (); 
     OracleDML::multi_column_for_loop_return multi_column_for_loop (); 
     OracleDML::multiset_expression_return multiset_expression (); 
     OracleDML::unary_expression_return unary_expression (); 
     OracleDML::case_statement_return case_statement (int isStatementParameter); 
     OracleDML::simple_case_statement_return simple_case_statement (); 
     OracleDML::simple_case_when_part_return simple_case_when_part (); 
     OracleDML::searched_case_statement_return searched_case_statement (); 
     OracleDML::searched_case_when_part_return searched_case_when_part (); 
     OracleDML::case_else_part_return case_else_part (); 
     OracleDML::atom_return atom (); 
     OracleDML::expression_or_vector_return expression_or_vector (); 
     OracleDML::vector_expr_return vector_expr (); 
     OracleDML::quantified_expression_return quantified_expression (); 
     OracleDML::standard_function_return standard_function (); 
     OracleDML::stantard_function_enabling_over_return stantard_function_enabling_over (); 
     OracleDML::stantard_function_enabling_using_return stantard_function_enabling_using (); 
     OracleDML::stantard_function_enabling_within_or_over_return stantard_function_enabling_within_or_over (); 
     OracleDML::stantard_function_pedictions_return stantard_function_pedictions (); 
     OracleDML::over_clause_return over_clause (); 
     OracleDML::windowing_clause_return windowing_clause (); 
     OracleDML::windowing_type_return windowing_type (); 
     OracleDML::windowing_elements_return windowing_elements (); 
     OracleDML::using_clause_return using_clause (); 
     OracleDML::using_element_return using_element (); 
     OracleDML::collect_order_by_part_return collect_order_by_part (); 
     OracleDML::within_or_over_part_return within_or_over_part (); 
     OracleDML::cost_matrix_clause_return cost_matrix_clause (); 
     OracleDML::xml_passing_clause_return xml_passing_clause (); 
     OracleDML::xml_attributes_clause_return xml_attributes_clause (); 
     OracleDML::xml_namespaces_clause_return xml_namespaces_clause (); 
     OracleDML::xml_table_column_return xml_table_column (); 
     OracleDML::xml_general_default_part_return xml_general_default_part (); 
     OracleDML::xml_multiuse_expression_element_return xml_multiuse_expression_element (); 
     OracleDML::xmlroot_param_version_part_return xmlroot_param_version_part (); 
     OracleDML::xmlroot_param_standalone_part_return xmlroot_param_standalone_part (); 
     OracleDML::xmlserialize_param_enconding_part_return xmlserialize_param_enconding_part (); 
     OracleDML::xmlserialize_param_version_part_return xmlserialize_param_version_part (); 
     OracleDML::xmlserialize_param_ident_part_return xmlserialize_param_ident_part (); 













































      bool msynpred( antlr3::ClassForwarder< synpred1_OracleDML > );
        void msynpred1_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred2_OracleDML > );
        void msynpred2_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred3_OracleDML > );
        void msynpred3_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred4_OracleDML > );
        void msynpred4_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred5_OracleDML > );
        void msynpred5_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred6_OracleDML > );
        void msynpred6_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred7_OracleDML > );
        void msynpred7_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred8_OracleDML > );
        void msynpred8_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred9_OracleDML > );
        void msynpred9_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred10_OracleDML > );
        void msynpred10_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred11_OracleDML > );
        void msynpred11_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred12_OracleDML > );
        void msynpred12_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred13_OracleDML > );
        void msynpred13_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred14_OracleDML > );
        void msynpred14_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred15_OracleDML > );
        void msynpred15_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred16_OracleDML > );
        void msynpred16_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred17_OracleDML > );
        void msynpred17_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred18_OracleDML > );
        void msynpred18_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred19_OracleDML > );
        void msynpred19_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred20_OracleDML > );
        void msynpred20_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred21_OracleDML > );
        void msynpred21_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred22_OracleDML > );
        void msynpred22_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred23_OracleDML > );
        void msynpred23_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred24_OracleDML > );
        void msynpred24_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred25_OracleDML > );
        void msynpred25_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred26_OracleDML > );
        void msynpred26_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred27_OracleDML > );
        void msynpred27_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred28_OracleDML > );
        void msynpred28_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred29_OracleDML > );
        void msynpred29_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred30_OracleDML > );
        void msynpred30_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred31_OracleDML > );
        void msynpred31_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred36_OracleDML > );
        void msynpred36_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred38_OracleDML > );
        void msynpred38_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred39_OracleDML > );
        void msynpred39_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred40_OracleDML > );
        void msynpred40_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred41_OracleDML > );
        void msynpred41_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred42_OracleDML > );
        void msynpred42_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred43_OracleDML > );
        void msynpred43_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred45_OracleDML > );
        void msynpred45_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred46_OracleDML > );
        void msynpred46_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred47_OracleDML > );
        void msynpred47_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred48_OracleDML > );
        void msynpred48_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred49_OracleDML > );
        void msynpred49_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred50_OracleDML > );
        void msynpred50_OracleDML_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred51_OracleDML > );
        void msynpred51_OracleDML_fragment ();
    // Delegated rules
    OracleDML_OracleDMLKeys::binary_double_nan_key_return binary_double_nan_key();

    OracleDML_OracleDMLKeys::rawtohex_key_return rawtohex_key();

    OracleDML_OracleDMLKeys::percent_rowtype_key_return percent_rowtype_key();

    OracleDML_OracleDMLKeys::first_key_return first_key();

    OracleDML_OracleDMLKeys::deferred_key_return deferred_key();

    OracleDML_OracleDMLKeys::timestamp_unconstrained_key_return timestamp_unconstrained_key();

    OracleDML_OracleDMLKeys::invalidate_key_return invalidate_key();

    OracleDML_OracleDMLKeys::position_key_return position_key();

    OracleDML_OracleDMLKeys::nullif_key_return nullif_key();

    OracleDML_OracleDMLKeys::where_key_return where_key();

    OracleDML_OracleDMLKeys::extract_key_return extract_key();

    OracleDML_OracleDMLKeys::start_key_return start_key();

    OracleDML_OracleDMLKeys::sum_key_return sum_key();

    OracleDML_OracleDMLKeys::authid_key_return authid_key();

    OracleDML_OracleDMLKeys::xmltable_key_return xmltable_key();

    OracleDML_OracleDMLKeys::unlimited_key_return unlimited_key();

    OracleDML_OracleDMLKeys::mod_key_return mod_key();

    OracleDML_OracleDMLKeys::system_user_key_return system_user_key();

    OracleDML_OracleDMLCommons::numeric_return numeric();

    OracleDML_OracleDMLKeys::schema_key_return schema_key();

    OracleDML_OracleDMLKeys::uid_key_return uid_key();

    OracleDML_OracleDMLKeys::option_key_return option_key();

    OracleDML_OracleDMLKeys::dml_key_return dml_key();

    OracleDML_OracleDMLKeys::package_key_return package_key();

    OracleDML_OracleDMLKeys::from_key_return from_key();

    OracleDML_OracleDMLKeys::initcap_key_return initcap_key();

    OracleDML_OracleDMLKeys::specification_key_return specification_key();

    OracleDML_OracleDMLKeys::decrement_key_return decrement_key();

    OracleDML_OracleDMLKeys::snapshot_key_return snapshot_key();

    OracleDML_OracleDMLKeys::decompose_key_return decompose_key();

    OracleDML_OracleDMLKeys::compatibility_key_return compatibility_key();

    OracleDML_OracleDMLKeys::trigger_key_return trigger_key();

    OracleDML_OracleDMLKeys::return_key_return return_key();

    OracleDML_OracleDMLKeys::evalname_key_return evalname_key();

    OracleDML_OracleDMLKeys::nvl_key_return nvl_key();

    OracleDML_OracleDMLKeys::like4_key_return like4_key();

    OracleDML_OracleDMLKeys::final_key_return final_key();

    OracleDML_OracleDMLCommons::variable_name_return variable_name();

    OracleDML_OracleDMLKeys::likec_key_return likec_key();

    OracleDML_OracleDMLCommons::column_name_return column_name();

    OracleDML_OracleDMLKeys::at_key_return at_key();

    OracleDML_OracleDMLKeys::variable_key_return variable_key();

    OracleDML_OracleDMLKeys::userenv_key_return userenv_key();

    OracleDML_OracleDMLKeys::simple_integer_key_return simple_integer_key();

    OracleDML_OracleDMLKeys::read_key_return read_key();

    OracleDML_OracleDMLKeys::shutdown_key_return shutdown_key();

    OracleDML_OracleDMLCommons::parameter_name_return parameter_name();

    OracleDML_OracleDMLCommons::function_argument_modeling_return function_argument_modeling();

    OracleDML_OracleDMLKeys::chartorowid_key_return chartorowid_key();

    OracleDML_OracleDMLCommons::multiset_op_return multiset_op();

    OracleDML_OracleDMLKeys::binary_float_max_subnormal_key_return binary_float_max_subnormal_key();

    OracleDML_OracleDMLKeys::connect_key_return connect_key();

    OracleDML_OracleDMLCommons::record_name_return record_name();

    OracleDML_OracleDMLKeys::raise_key_return raise_key();

    OracleDML_OracleDMLKeys::binary_integer_key_return binary_integer_key();

    OracleDML_OracleDMLKeys::columns_key_return columns_key();

    OracleDML_OracleDMLKeys::grant_key_return grant_key();

    OracleDML_OracleDMLCommons::index_name_return index_name();

    OracleDML_OracleDMLCommons::aggregate_function_name_return aggregate_function_name();

    OracleDML_OracleDMLKeys::rename_key_return rename_key();

    OracleDML_OracleDMLKeys::timezone_abbr_key_return timezone_abbr_key();

    OracleDML_OracleDMLKeys::cube_key_return cube_key();

    OracleDML_OracleDMLKeys::hextoraw_key_return hextoraw_key();

    OracleDML_OracleDMLKeys::parent_key_return parent_key();

    OracleDML_OracleDMLKeys::substring_key_return substring_key();

    OracleDML_OracleDMLKeys::using_key_return using_key();

    OracleDML_OracleDMLKeys::hash_key_return hash_key();

    OracleDML_OracleDMLKeys::nvarchar2_key_return nvarchar2_key();

    OracleDML_OracleDMLCommons::keep_clause_return keep_clause();

    OracleDML_OracleDMLKeys::search_key_return search_key();

    OracleDML_OracleDMLKeys::create_key_return create_key();

    OracleDML_OracleDMLKeys::size_key_return size_key();

    OracleDML_OracleDMLKeys::xmlcolattval_key_return xmlcolattval_key();

    OracleDML_OracleDMLCommons::main_model_name_return main_model_name();

    OracleDML_OracleDMLKeys::int_key_return int_key();

    OracleDML_OracleDMLKeys::replace_key_return replace_key();

    OracleDML_OracleDMLKeys::not_key_return not_key();

    OracleDML_OracleDMLKeys::java_key_return java_key();

    OracleDML_OracleDMLKeys::octet_length_key_return octet_length_key();

    OracleDML_OracleDMLKeys::exception_key_return exception_key();

    OracleDML_OracleDMLKeys::float_key_return float_key();

    OracleDML_OracleDMLKeys::both_key_return both_key();

    OracleDML_OracleDMLKeys::timeout_key_return timeout_key();

    OracleDML_OracleDMLKeys::dec_key_return dec_key();

    OracleDML_OracleDMLKeys::analyze_key_return analyze_key();

    OracleDML_OracleDMLKeys::like_key_return like_key();

    OracleDML_OracleDMLKeys::asc_key_return asc_key();

    OracleDML_OracleDMLKeys::ascii_key_return ascii_key();

    OracleDML_OracleDMLKeys::declare_key_return declare_key();

    OracleDML_OracleDMLKeys::unbounded_key_return unbounded_key();

    OracleDML_OracleDMLKeys::timezone_region_key_return timezone_region_key();

    OracleDML_OracleDMLKeys::xmlcast_key_return xmlcast_key();

    OracleDML_OracleDMLKeys::resumable_key_return resumable_key();

    OracleDML_OracleDMLKeys::iterate_key_return iterate_key();

    OracleDML_OracleDMLKeys::member_key_return member_key();

    OracleDML_OracleDMLKeys::real_key_return real_key();

    OracleDML_OracleDMLKeys::lower_key_return lower_key();

    OracleDML_OracleDMLCommons::xml_column_name_return xml_column_name();

    OracleDML_OracleDMLKeys::work_key_return work_key();

    OracleDML_OracleDMLKeys::variance_key_return variance_key();

    OracleDML_OracleDMLKeys::constraints_key_return constraints_key();

    OracleDML_OracleDMLKeys::decode_key_return decode_key();

    OracleDML_OracleDMLKeys::segment_key_return segment_key();

    OracleDML_OracleDMLKeys::xmlpi_key_return xmlpi_key();

    OracleDML_OracleDMLKeys::hour_key_return hour_key();

    OracleDML_OracleDMLCommons::precision_part_return precision_part();

    OracleDML_OracleDMLKeys::until_key_return until_key();

    OracleDML_OracleDMLKeys::parallel_enable_key_return parallel_enable_key();

    OracleDML_OracleDMLKeys::customdatum_key_return customdatum_key();

    OracleDML_OracleDMLKeys::delete_key_return delete_key();

    OracleDML_OracleDMLKeys::sample_key_return sample_key();

    OracleDML_OracleDMLCommons::exception_name_return exception_name();

    OracleDML_OracleDMLCommons::package_name_return package_name();

    OracleDML_OracleDMLKeys::oserror_key_return oserror_key();

    OracleDML_OracleDMLKeys::rules_key_return rules_key();

    OracleDML_OracleDMLKeys::subtype_key_return subtype_key();

    OracleDML_OracleDMLKeys::path_key_return path_key();

    OracleDML_OracleDMLKeys::nocycle_key_return nocycle_key();

    OracleDML_OracleDMLKeys::whenever_key_return whenever_key();

    OracleDML_OracleDMLKeys::positive_key_return positive_key();

    OracleDML_OracleDMLKeys::logon_key_return logon_key();

    OracleDML_OracleDMLKeys::minute_key_return minute_key();

    OracleDML_OracleDMLCommons::procedure_name_return procedure_name();

    OracleDML_OracleDMLKeys::identified_key_return identified_key();

    OracleDML_OracleDMLKeys::settings_key_return settings_key();

    OracleDML_OracleDMLKeys::and_key_return and_key();

    OracleDML_OracleDMLCommons::current_of_clause_return current_of_clause();

    OracleDML_OracleDMLKeys::the_key_return the_key();

    OracleDML_OracleDMLKeys::collate_key_return collate_key();

    OracleDML_OracleDMLKeys::nocache_key_return nocache_key();

    OracleDML_OracleDMLKeys::natural_key_return natural_key();

    OracleDML_OracleDMLKeys::nominvalue_key_return nominvalue_key();

    OracleDML_OracleDMLKeys::committed_key_return committed_key();

    OracleDML_OracleDMLKeys::logoff_key_return logoff_key();

    OracleDML_OracleDMLKeys::long_key_return long_key();

    OracleDML_OracleDMLKeys::breadth_key_return breadth_key();

    OracleDML_OracleDMLKeys::array_key_return array_key();

    OracleDML_OracleDMLKeys::exceptions_key_return exceptions_key();

    OracleDML_OracleDMLKeys::last_key_return last_key();

    OracleDML_OracleDMLKeys::binary_double_key_return binary_double_key();

    OracleDML_OracleDMLKeys::coalesce_key_return coalesce_key();

    OracleDML_OracleDMLKeys::distinct_key_return distinct_key();

    OracleDML_OracleDMLKeys::skip_key_return skip_key();

    OracleDML_OracleDMLKeys::end_key_return end_key();

    OracleDML_OracleDMLKeys::autonomous_transaction_key_return autonomous_transaction_key();

    OracleDML_OracleDMLKeys::object_key_return object_key();

    OracleDML_OracleDMLKeys::dbtimezone_key_return dbtimezone_key();

    OracleDML_OracleDMLKeys::xmlparse_key_return xmlparse_key();

    OracleDML_OracleDMLKeys::binary_float_max_normal_key_return binary_float_max_normal_key();

    OracleDML_OracleDMLKeys::value_key_return value_key();

    OracleDML_OracleDMLKeys::pls_integer_key_return pls_integer_key();

    OracleDML_OracleDMLKeys::index_key_return index_key();

    OracleDML_OracleDMLCommons::function_argument_return function_argument();

    OracleDML_OracleDMLKeys::intersect_key_return intersect_key();

    OracleDML_OracleDMLKeys::rowid_key_return rowid_key();

    OracleDML_OracleDMLKeys::servererror_key_return servererror_key();

    OracleDML_OracleDMLKeys::character_key_return character_key();

    OracleDML_OracleDMLCommons::function_argument_analytic_return function_argument_analytic();

    OracleDML_OracleDMLKeys::session_key_return session_key();

    OracleDML_OracleDMLCommons::table_alias_return table_alias();

    OracleDML_OracleDMLKeys::dsinterval_unconstrained_key_return dsinterval_unconstrained_key();

    OracleDML_OracleDMLKeys::table_key_return table_key();

    OracleDML_OracleDMLKeys::increment_key_return increment_key();

    OracleDML_OracleDMLKeys::scn_key_return scn_key();

    OracleDML_OracleDMLKeys::rpad_key_return rpad_key();

    OracleDML_OracleDMLKeys::enable_key_return enable_key();

    OracleDML_OracleDMLKeys::ref_key_return ref_key();

    OracleDML_OracleDMLKeys::char_cs_key_return char_cs_key();

    OracleDML_OracleDMLKeys::nothing_key_return nothing_key();

    OracleDML_OracleDMLKeys::execute_key_return execute_key();

    OracleDML_OracleDMLKeys::submultiset_key_return submultiset_key();

    OracleDML_OracleDMLKeys::string_key_return string_key();

    OracleDML_OracleDMLKeys::local_key_return local_key();

    OracleDML_OracleDMLCommons::sequence_name_return sequence_name();

    OracleDML_OracleDMLKeys::a_key_return a_key();

    OracleDML_OracleDMLKeys::batch_key_return batch_key();

    OracleDML_OracleDMLKeys::out_key_return out_key();

    OracleDML_OracleDMLKeys::subpartition_key_return subpartition_key();

    OracleDML_OracleDMLKeys::log_key_return log_key();

    OracleDML_OracleDMLKeys::year_key_return year_key();

    OracleDML_OracleDMLKeys::to_date_key_return to_date_key();

    OracleDML_OracleDMLKeys::minus_key_return minus_key();

    OracleDML_OracleDMLKeys::group_key_return group_key();

    OracleDML_OracleDMLKeys::compile_key_return compile_key();

    OracleDML_OracleDMLKeys::oid_key_return oid_key();

    OracleDML_OracleDMLKeys::each_key_return each_key();

    OracleDML_OracleDMLKeys::document_key_return document_key();

    OracleDML_OracleDMLKeys::having_key_return having_key();

    OracleDML_OracleDMLKeys::true_key_return true_key();

    OracleDML_OracleDMLKeys::reference_key_return reference_key();

    OracleDML_OracleDMLKeys::timestamp_key_return timestamp_key();

    OracleDML_OracleDMLCommons::tableview_name_return tableview_name();

    OracleDML_OracleDMLKeys::noorder_key_return noorder_key();

    OracleDML_OracleDMLKeys::sequential_key_return sequential_key();

    OracleDML_OracleDMLKeys::unique_key_return unique_key();

    OracleDML_OracleDMLKeys::comment_key_return comment_key();

    OracleDML_OracleDMLKeys::within_key_return within_key();

    OracleDML_OracleDMLKeys::trim_key_return trim_key();

    OracleDML_OracleDMLKeys::rtrim_key_return rtrim_key();

    OracleDML_OracleDMLKeys::count_key_return count_key();

    OracleDML_OracleDMLKeys::restrict_references_key_return restrict_references_key();

    OracleDML_OracleDMLKeys::xmlexists_key_return xmlexists_key();

    OracleDML_OracleDMLKeys::savepoint_key_return savepoint_key();

    OracleDML_OracleDMLKeys::default_key_return default_key();

    OracleDML_OracleDMLKeys::multiset_key_return multiset_key();

    OracleDML_OracleDMLKeys::substr_key_return substr_key();

    OracleDML_OracleDMLKeys::ddl_key_return ddl_key();

    OracleDML_OracleDMLKeys::inner_key_return inner_key();

    OracleDML_OracleDMLKeys::floor_key_return floor_key();

    OracleDML_OracleDMLCommons::label_name_return label_name();

    OracleDML_OracleDMLCommons::rollback_segment_name_return rollback_segment_name();

    OracleDML_OracleDMLKeys::some_key_return some_key();

    OracleDML_OracleDMLKeys::second_key_return second_key();

    OracleDML_OracleDMLKeys::deterministic_key_return deterministic_key();

    OracleDML_OracleDMLKeys::attribute_key_return attribute_key();

    OracleDML_OracleDMLKeys::type_key_return type_key();

    OracleDML_OracleDMLKeys::compound_key_return compound_key();

    OracleDML_OracleDMLKeys::upper_key_return upper_key();

    OracleDML_OracleDMLKeys::max_key_return max_key();

    OracleDML_OracleDMLKeys::success_key_return success_key();

    OracleDML_OracleDMLKeys::date_key_return date_key();

    OracleDML_OracleDMLKeys::under_key_return under_key();

    OracleDML_OracleDMLKeys::update_key_return update_key();

    OracleDML_OracleDMLKeys::result_key_return result_key();

    OracleDML_OracleDMLKeys::pivot_key_return pivot_key();

    OracleDML_OracleDMLKeys::else_key_return else_key();

    OracleDML_OracleDMLKeys::greatest_key_return greatest_key();

    OracleDML_OracleDMLKeys::rowidtochar_key_return rowidtochar_key();

    OracleDML_OracleDMLCommons::constant_return constant();

    OracleDML_OracleDMLKeys::timestamp_tz_unconstrained_key_return timestamp_tz_unconstrained_key();

    OracleDML_OracleDMLKeys::left_key_return left_key();

    OracleDML_OracleDMLKeys::data_key_return data_key();

    OracleDML_OracleDMLCommons::table_element_return table_element();

    OracleDML_OracleDMLCommons::link_name_return link_name();

    OracleDML_OracleDMLKeys::order_key_return order_key();

    OracleDML_OracleDMLKeys::revoke_key_return revoke_key();

    OracleDML_OracleDMLKeys::transaction_key_return transaction_key();

    OracleDML_OracleDMLCommons::function_name_return function_name();

    OracleDML_OracleDMLKeys::alter_key_return alter_key();

    OracleDML_OracleDMLKeys::merge_key_return merge_key();

    OracleDML_OracleDMLKeys::percent_notfound_key_return percent_notfound_key();

    OracleDML_OracleDMLKeys::match_key_return match_key();

    OracleDML_OracleDMLKeys::use_key_return use_key();

    OracleDML_OracleDMLKeys::false_key_return false_key();

    OracleDML_OracleDMLCommons::cost_class_name_return cost_class_name();

    OracleDML_OracleDMLKeys::between_key_return between_key();

    OracleDML_OracleDMLKeys::ignore_key_return ignore_key();

    OracleDML_OracleDMLKeys::disassociate_key_return disassociate_key();

    OracleDML_OracleDMLKeys::nocopy_key_return nocopy_key();

    OracleDML_OracleDMLKeys::no_key_return no_key();

    OracleDML_OracleDMLKeys::unpivot_key_return unpivot_key();

    OracleDML_OracleDMLKeys::maxvalue_key_return maxvalue_key();

    OracleDML_OracleDMLKeys::open_key_return open_key();

    OracleDML_OracleDMLKeys::definer_key_return definer_key();

    OracleDML_OracleDMLKeys::percent_found_key_return percent_found_key();

    OracleDML_OracleDMLKeys::add_key_return add_key();

    OracleDML_OracleDMLKeys::char_length_key_return char_length_key();

    OracleDML_OracleDMLKeys::context_key_return context_key();

    OracleDML_OracleDMLKeys::referencing_key_return referencing_key();

    OracleDML_OracleDMLKeys::time_key_return time_key();

    OracleDML_OracleDMLKeys::urowid_key_return urowid_key();

    OracleDML_OracleDMLCommons::general_element_part_return general_element_part();

    OracleDML_OracleDMLKeys::sets_key_return sets_key();

    OracleDML_OracleDMLKeys::cluster_key_return cluster_key();

    OracleDML_OracleDMLKeys::cross_key_return cross_key();

    OracleDML_OracleDMLKeys::binary_double_min_normal_key_return binary_double_min_normal_key();

    OracleDML_OracleDMLKeys::mode_key_return mode_key();

    OracleDML_OracleDMLKeys::suspend_key_return suspend_key();

    OracleDML_OracleDMLKeys::off_key_return off_key();

    OracleDML_OracleDMLKeys::timestamp_ltz_unconstrained_key_return timestamp_ltz_unconstrained_key();

    OracleDML_OracleDMLKeys::modify_key_return modify_key();

    OracleDML_OracleDMLKeys::locked_key_return locked_key();

    OracleDML_OracleDMLKeys::first_value_key_return first_value_key();

    OracleDML_OracleDMLKeys::current_user_key_return current_user_key();

    OracleDML_OracleDMLKeys::xmlroot_key_return xmlroot_key();

    OracleDML_OracleDMLKeys::xmlagg_key_return xmlagg_key();

    OracleDML_OracleDMLCommons::char_set_name_return char_set_name();

    OracleDML_OracleDMLKeys::db_role_change_key_return db_role_change_key();

    OracleDML_OracleDMLKeys::reuse_key_return reuse_key();

    OracleDML_OracleDMLKeys::ltrim_key_return ltrim_key();

    OracleDML_OracleDMLKeys::xmlelement_key_return xmlelement_key();

    OracleDML_OracleDMLKeys::wellformed_key_return wellformed_key();

    OracleDML_OracleDMLKeys::present_key_return present_key();

    OracleDML_OracleDMLKeys::constant_key_return constant_key();

    OracleDML_OracleDMLKeys::any_key_return any_key();

    OracleDML_OracleDMLKeys::reject_key_return reject_key();

    OracleDML_OracleDMLKeys::rollup_key_return rollup_key();

    OracleDML_OracleDMLKeys::respect_key_return respect_key();

    OracleDML_OracleDMLKeys::least_key_return least_key();

    OracleDML_OracleDMLKeys::limit_key_return limit_key();

    OracleDML_OracleDMLKeys::yes_key_return yes_key();

    OracleDML_OracleDMLCommons::savepoint_name_return savepoint_name();

    OracleDML_OracleDMLKeys::xmlforest_key_return xmlforest_key();

    OracleDML_OracleDMLKeys::min_key_return min_key();

    OracleDML_OracleDMLKeys::module_key_return module_key();

    OracleDML_OracleDMLKeys::with_key_return with_key();

    OracleDML_OracleDMLKeys::cost_key_return cost_key();

    OracleDML_OracleDMLKeys::xmlquery_key_return xmlquery_key();

    OracleDML_OracleDMLKeys::current_timestamp_key_return current_timestamp_key();

    OracleDML_OracleDMLKeys::nulls_key_return nulls_key();

    OracleDML_OracleDMLKeys::show_key_return show_key();

    OracleDML_OracleDMLKeys::union_key_return union_key();

    OracleDML_OracleDMLKeys::binary_double_min_subnormal_key_return binary_double_min_subnormal_key();

    OracleDML_OracleDMLKeys::full_key_return full_key();

    OracleDML_OracleDMLKeys::serveroutput_key_return serveroutput_key();

    OracleDML_OracleDMLKeys::corresponding_key_return corresponding_key();

    OracleDML_OracleDMLKeys::content_key_return content_key();

    OracleDML_OracleDMLKeys::global_key_return global_key();

    OracleDML_OracleDMLCommons::type_spec_return type_spec();

    OracleDML_OracleDMLKeys::corrupt_xid_all_key_return corrupt_xid_all_key();

    OracleDML_OracleDMLKeys::for_key_return for_key();

    OracleDML_OracleDMLKeys::constraint_key_return constraint_key();

    OracleDML_OracleDMLCommons::bind_variable_return bind_variable();

    OracleDML_OracleDMLKeys::relies_on_key_return relies_on_key();

    OracleDML_OracleDMLKeys::to_number_key_return to_number_key();

    OracleDML_OracleDMLCommons::argument_return argument();

    OracleDML_OracleDMLKeys::advise_key_return advise_key();

    OracleDML_OracleDMLKeys::role_key_return role_key();

    OracleDML_OracleDMLKeys::values_key_return values_key();

    OracleDML_OracleDMLKeys::nested_key_return nested_key();

    OracleDML_OracleDMLKeys::raw_key_return raw_key();

    OracleDML_OracleDMLKeys::range_key_return range_key();

    OracleDML_OracleDMLKeys::self_key_return self_key();

    OracleDML_OracleDMLKeys::partition_key_return partition_key();

    OracleDML_OracleDMLCommons::type_name_return type_name();

    OracleDML_OracleDMLKeys::query_key_return query_key();

    OracleDML_OracleDMLKeys::integer_key_return integer_key();

    OracleDML_OracleDMLKeys::is_key_return is_key();

    OracleDML_OracleDMLKeys::sequence_key_return sequence_key();

    OracleDML_OracleDMLKeys::save_key_return save_key();

    OracleDML_OracleDMLKeys::select_key_return select_key();

    OracleDML_OracleDMLKeys::none_key_return none_key();

    OracleDML_OracleDMLKeys::sqrt_key_return sqrt_key();

    OracleDML_OracleDMLKeys::after_key_return after_key();

    OracleDML_OracleDMLKeys::before_key_return before_key();

    OracleDML_OracleDMLKeys::nchar_key_return nchar_key();

    OracleDML_OracleDMLKeys::cast_key_return cast_key();

    OracleDML_OracleDMLKeys::binary_float_nan_key_return binary_float_nan_key();

    OracleDML_OracleDMLKeys::truncate_key_return truncate_key();

    OracleDML_OracleDMLKeys::smallint_key_return smallint_key();

    OracleDML_OracleDMLKeys::name_key_return name_key();

    OracleDML_OracleDMLKeys::binary_double_max_normal_key_return binary_double_max_normal_key();

    OracleDML_OracleDMLKeys::lpad_key_return lpad_key();

    OracleDML_OracleDMLKeys::signtype_key_return signtype_key();

    OracleDML_OracleDMLKeys::to_key_return to_key();

    OracleDML_OracleDMLKeys::aggregate_key_return aggregate_key();

    OracleDML_OracleDMLKeys::concat_key_return concat_key();

    OracleDML_OracleDMLKeys::outer_key_return outer_key();

    OracleDML_OracleDMLKeys::collect_key_return collect_key();

    OracleDML_OracleDMLKeys::exclude_key_return exclude_key();

    OracleDML_OracleDMLCommons::where_clause_return where_clause();

    OracleDML_OracleDMLKeys::chr_key_return chr_key();

    OracleDML_OracleDMLCommons::constraint_name_return constraint_name();

    OracleDML_OracleDMLKeys::commit_key_return commit_key();

    OracleDML_OracleDMLKeys::write_key_return write_key();

    OracleDML_OracleDMLKeys::instr_key_return instr_key();

    OracleDML_OracleDMLKeys::dimension_key_return dimension_key();

    OracleDML_OracleDMLCommons::trigger_name_return trigger_name();

    OracleDML_OracleDMLKeys::upsert_key_return upsert_key();

    OracleDML_OracleDMLKeys::parallel_key_return parallel_key();

    OracleDML_OracleDMLKeys::cascade_key_return cascade_key();

    OracleDML_OracleDMLKeys::clob_key_return clob_key();

    OracleDML_OracleDMLCommons::alias_quoted_string_return alias_quoted_string(int identifierClass, int usageType);

    OracleDML_OracleDMLKeys::partial_key_return partial_key();

    OracleDML_OracleDMLKeys::precision_key_return precision_key();

    OracleDML_OracleDMLCommons::into_clause_return into_clause();

    OracleDML_OracleDMLKeys::leading_key_return leading_key();

    OracleDML_OracleDMLCommons::id_expression_return id_expression(int identifierClass, int usageType);

    OracleDML_OracleDMLKeys::warning_key_return warning_key();

    OracleDML_OracleDMLCommons::attribute_name_return attribute_name();

    OracleDML_OracleDMLKeys::abs_key_return abs_key();

    OracleDML_OracleDMLKeys::percent_isopen_key_return percent_isopen_key();

    OracleDML_OracleDMLKeys::set_key_return set_key();

    OracleDML_OracleDMLKeys::nchar_cs_key_return nchar_cs_key();

    OracleDML_OracleDMLCommons::not_equal_op_return not_equal_op();

    OracleDML_OracleDMLKeys::on_key_return on_key();

    OracleDML_OracleDMLKeys::infinite_key_return infinite_key();

    OracleDML_OracleDMLKeys::version_key_return version_key();

    OracleDML_OracleDMLKeys::nan_key_return nan_key();

    OracleDML_OracleDMLKeys::percent_rowcount_key_return percent_rowcount_key();

    OracleDML_OracleDMLKeys::associate_key_return associate_key();

    OracleDML_OracleDMLKeys::standalone_key_return standalone_key();

    OracleDML_OracleDMLKeys::hide_key_return hide_key();

    OracleDML_OracleDMLKeys::immediate_key_return immediate_key();

    OracleDML_OracleDMLKeys::double_key_return double_key();

    OracleDML_OracleDMLKeys::close_key_return close_key();

    OracleDML_OracleDMLKeys::result_cache_key_return result_cache_key();

    OracleDML_OracleDMLKeys::current_key_return current_key();

    OracleDML_OracleDMLKeys::nclob_key_return nclob_key();

    OracleDML_OracleDMLKeys::level_key_return level_key();

    OracleDML_OracleDMLKeys::sign_key_return sign_key();

    OracleDML_OracleDMLKeys::reverse_key_return reverse_key();

    OracleDML_OracleDMLKeys::keep_key_return keep_key();

    OracleDML_OracleDMLKeys::preceding_key_return preceding_key();

    OracleDML_OracleDMLKeys::schemacheck_key_return schemacheck_key();

    OracleDML_OracleDMLKeys::minvalue_key_return minvalue_key();

    OracleDML_OracleDMLKeys::cycle_key_return cycle_key();

    OracleDML_OracleDMLKeys::validate_key_return validate_key();

    OracleDML_OracleDMLKeys::binary_float_key_return binary_float_key();

    OracleDML_OracleDMLCommons::query_name_return query_name();

    OracleDML_OracleDMLKeys::grouping_key_return grouping_key();

    OracleDML_OracleDMLKeys::oradata_key_return oradata_key();

    OracleDML_OracleDMLKeys::empty_key_return empty_key();

    OracleDML_OracleDMLKeys::indent_key_return indent_key();

    OracleDML_OracleDMLKeys::agent_key_return agent_key();

    OracleDML_OracleDMLKeys::into_key_return into_key();

    OracleDML_OracleDMLKeys::bit_length_key_return bit_length_key();

    OracleDML_OracleDMLKeys::nowait_key_return nowait_key();

    OracleDML_OracleDMLKeys::xmlserialize_key_return xmlserialize_key();

    OracleDML_OracleDMLKeys::siblings_key_return siblings_key();

    OracleDML_OracleDMLKeys::old_key_return old_key();

    OracleDML_OracleDMLKeys::rows_key_return rows_key();

    OracleDML_OracleDMLKeys::single_key_return single_key();

    OracleDML_OracleDMLCommons::concatenation_op_return concatenation_op();

    OracleDML_OracleDMLKeys::current_date_key_return current_date_key();

    OracleDML_OracleDMLKeys::only_key_return only_key();

    OracleDML_OracleDMLKeys::user_key_return user_key();

    OracleDML_OracleDMLKeys::xml_key_return xml_key();

    OracleDML_OracleDMLKeys::row_key_return row_key();

    OracleDML_OracleDMLKeys::main_key_return main_key();

    OracleDML_OracleDMLKeys::then_key_return then_key();

    OracleDML_OracleDMLKeys::or_key_return or_key();

    OracleDML_OracleDMLKeys::debug_key_return debug_key();

    OracleDML_OracleDMLKeys::record_key_return record_key();

    OracleDML_OracleDMLKeys::translate_key_return translate_key();

    OracleDML_OracleDMLKeys::indexed_key_return indexed_key();

    OracleDML_OracleDMLKeys::statement_key_return statement_key();

    OracleDML_OracleDMLKeys::trunc_key_return trunc_key();

    OracleDML_OracleDMLKeys::check_key_return check_key();

    OracleDML_OracleDMLKeys::seed_key_return seed_key();

    OracleDML_OracleDMLKeys::matched_key_return matched_key();

    OracleDML_OracleDMLKeys::naturaln_key_return naturaln_key();

    OracleDML_OracleDMLKeys::serializable_key_return serializable_key();

    OracleDML_OracleDMLKeys::sysdate_key_return sysdate_key();

    OracleDML_OracleDMLKeys::sqlerror_key_return sqlerror_key();

    OracleDML_OracleDMLKeys::convert_key_return convert_key();

    OracleDML_OracleDMLCommons::quoted_string_return quoted_string();

    OracleDML_OracleDMLKeys::forall_key_return forall_key();

    OracleDML_OracleDMLKeys::function_key_return function_key();

    OracleDML_OracleDMLCommons::partition_extension_clause_return partition_extension_clause();

    OracleDML_OracleDMLKeys::entityescaping_key_return entityescaping_key();

    OracleDML_OracleDMLKeys::statistics_key_return statistics_key();

    OracleDML_OracleDMLKeys::include_key_return include_key();

    OracleDML_OracleDMLKeys::isolation_key_return isolation_key();

    OracleDML_OracleDMLKeys::session_user_key_return session_user_key();

    OracleDML_OracleDMLKeys::including_key_return including_key();

    OracleDML_OracleDMLKeys::lock_key_return lock_key();

    OracleDML_OracleDMLKeys::yminterval_unconstrained_key_return yminterval_unconstrained_key();

    OracleDML_OracleDMLKeys::mlslabel_key_return mlslabel_key();

    OracleDML_OracleDMLKeys::current_time_key_return current_time_key();

    OracleDML_OracleDMLKeys::month_key_return month_key();

    OracleDML_OracleDMLKeys::returning_key_return returning_key();

    OracleDML_OracleDMLKeys::pragma_key_return pragma_key();

    OracleDML_OracleDMLKeys::block_key_return block_key();

    OracleDML_OracleDMLKeys::indicator_key_return indicator_key();

    OracleDML_OracleDMLCommons::reference_model_name_return reference_model_name();

    OracleDML_OracleDMLKeys::in_key_return in_key();

    OracleDML_OracleDMLKeys::exit_key_return exit_key();

    OracleDML_OracleDMLKeys::sessiontimezone_key_return sessiontimezone_key();

    OracleDML_OracleDMLCommons::datatype_return datatype();

    OracleDML_OracleDMLKeys::national_key_return national_key();

    OracleDML_OracleDMLKeys::plan_key_return plan_key();

    OracleDML_OracleDMLKeys::prior_key_return prior_key();

    OracleDML_OracleDMLKeys::procedure_key_return procedure_key();

    OracleDML_OracleDMLKeys::ceil_key_return ceil_key();

    OracleDML_OracleDMLKeys::goto_key_return goto_key();

    OracleDML_OracleDMLKeys::defaults_key_return defaults_key();

    OracleDML_OracleDMLKeys::drop_key_return drop_key();

    OracleDML_OracleDMLKeys::updated_key_return updated_key();

    OracleDML_OracleDMLKeys::noschemacheck_key_return noschemacheck_key();

    OracleDML_OracleDMLKeys::cursor_key_return cursor_key();

    OracleDML_OracleDMLKeys::binary_double_infinity_key_return binary_double_infinity_key();

    OracleDML_OracleDMLKeys::following_key_return following_key();

    OracleDML_OracleDMLKeys::desc_key_return desc_key();

    OracleDML_OracleDMLKeys::exists_key_return exists_key();

    OracleDML_OracleDMLCommons::native_datatype_element_return native_datatype_element();

    OracleDML_OracleDMLKeys::cache_key_return cache_key();

    OracleDML_OracleDMLKeys::power_key_return power_key();

    OracleDML_OracleDMLKeys::rollback_key_return rollback_key();

    OracleDML_OracleDMLKeys::character_length_key_return character_length_key();

    OracleDML_OracleDMLKeys::varying_key_return varying_key();

    OracleDML_OracleDMLKeys::as_key_return as_key();

    OracleDML_OracleDMLKeys::explain_key_return explain_key();

    OracleDML_OracleDMLKeys::nav_key_return nav_key();

    OracleDML_OracleDMLKeys::canonical_key_return canonical_key();

    OracleDML_OracleDMLKeys::dump_key_return dump_key();

    OracleDML_OracleDMLKeys::library_key_return library_key();

    OracleDML_OracleDMLKeys::case_key_return case_key();

    OracleDML_OracleDMLKeys::system_key_return system_key();

    OracleDML_OracleDMLKeys::to_char_key_return to_char_key();

    OracleDML_OracleDMLKeys::call_key_return call_key();

    OracleDML_OracleDMLKeys::follows_key_return follows_key();

    OracleDML_OracleDMLKeys::bfile_key_return bfile_key();

    OracleDML_OracleDMLKeys::when_key_return when_key();

    OracleDML_OracleDMLKeys::binary_double_max_subnormal_key_return binary_double_max_subnormal_key();

    OracleDML_OracleDMLKeys::overriding_key_return overriding_key();

    OracleDML_OracleDMLKeys::pipelined_key_return pipelined_key();

    OracleDML_OracleDMLKeys::ordinality_key_return ordinality_key();

    OracleDML_OracleDMLKeys::statement_id_key_return statement_id_key();

    OracleDML_OracleDMLKeys::new_key_return new_key();

    OracleDML_OracleDMLKeys::instantiable_key_return instantiable_key();

    OracleDML_OracleDMLKeys::fetch_key_return fetch_key();

    OracleDML_OracleDMLKeys::guard_key_return guard_key();

    OracleDML_OracleDMLKeys::soundex_key_return soundex_key();

    OracleDML_OracleDMLCommons::collection_name_return collection_name();

    OracleDML_OracleDMLCommons::general_element_return general_element();

    OracleDML_OracleDMLKeys::exception_init_key_return exception_init_key();

    OracleDML_OracleDMLKeys::corrupt_xid_key_return corrupt_xid_key();

    OracleDML_OracleDMLKeys::insert_key_return insert_key();

    OracleDML_OracleDMLKeys::disable_key_return disable_key();

    OracleDML_OracleDMLKeys::percent_type_key_return percent_type_key();

    OracleDML_OracleDMLKeys::connect_by_root_key_return connect_by_root_key();

    OracleDML_OracleDMLKeys::treat_key_return treat_key();

    OracleDML_OracleDMLKeys::elsif_key_return elsif_key();

    OracleDML_OracleDMLKeys::escape_key_return escape_key();

    OracleDML_OracleDMLKeys::last_value_key_return last_value_key();

    OracleDML_OracleDMLKeys::bit_key_return bit_key();

    OracleDML_OracleDMLKeys::right_key_return right_key();

    OracleDML_OracleDMLKeys::join_key_return join_key();

    OracleDML_OracleDMLKeys::language_key_return language_key();

    OracleDML_OracleDMLKeys::startup_key_return startup_key();

    OracleDML_OracleDMLKeys::errors_key_return errors_key();

    OracleDML_OracleDMLKeys::binary_float_min_subnormal_key_return binary_float_min_subnormal_key();

    OracleDML_OracleDMLKeys::decimal_key_return decimal_key();

    OracleDML_OracleDMLKeys::versions_key_return versions_key();

    OracleDML_OracleDMLKeys::continue_key_return continue_key();

    OracleDML_OracleDMLKeys::link_key_return link_key();

    OracleDML_OracleDMLKeys::database_key_return database_key();

    OracleDML_OracleDMLKeys::varchar2_key_return varchar2_key();

    OracleDML_OracleDMLKeys::body_key_return body_key();

    OracleDML_OracleDMLKeys::unknown_key_return unknown_key();

    OracleDML_OracleDMLCommons::id_return id(int identifierClass, int usageType);

    OracleDML_OracleDMLKeys::nextval_key_return nextval_key();

    OracleDML_OracleDMLKeys::inline_key_return inline_key();

    OracleDML_OracleDMLKeys::extend_key_return extend_key();

    OracleDML_OracleDMLCommons::greater_than_or_equals_op_return greater_than_or_equals_op();

    OracleDML_OracleDMLKeys::noaudit_key_return noaudit_key();

    OracleDML_OracleDMLKeys::vsize_key_return vsize_key();

    OracleDML_OracleDMLKeys::bulk_key_return bulk_key();

    OracleDML_OracleDMLKeys::passing_key_return passing_key();

    OracleDML_OracleDMLKeys::trailing_key_return trailing_key();

    OracleDML_OracleDMLKeys::varchar_key_return varchar_key();

    OracleDML_OracleDMLKeys::if_key_return if_key();

    OracleDML_OracleDMLKeys::external_key_return external_key();

    OracleDML_OracleDMLKeys::static_key_return static_key();

    OracleDML_OracleDMLKeys::of_key_return of_key();

    OracleDML_OracleDMLKeys::audit_key_return audit_key();

    OracleDML_OracleDMLKeys::wait_key_return wait_key();

    OracleDML_OracleDMLKeys::avg_key_return avg_key();

    OracleDML_OracleDMLKeys::varray_key_return varray_key();

    OracleDML_OracleDMLKeys::round_key_return round_key();

    OracleDML_OracleDMLKeys::nomaxvalue_key_return nomaxvalue_key();

    OracleDML_OracleDMLKeys::except_key_return except_key();

    OracleDML_OracleDMLKeys::stddev_key_return stddev_key();

    OracleDML_OracleDMLKeys::noentityescaping_key_return noentityescaping_key();

    OracleDML_OracleDMLCommons::respect_or_ignore_nulls_return respect_or_ignore_nulls();

    OracleDML_OracleDMLKeys::length_key_return length_key();

    OracleDML_OracleDMLKeys::encoding_key_return encoding_key();

    OracleDML_OracleDMLKeys::blob_key_return blob_key();

    OracleDML_OracleDMLKeys::like2_key_return like2_key();

    OracleDML_OracleDMLKeys::model_key_return model_key();

    OracleDML_OracleDMLKeys::timezone_minute_key_return timezone_minute_key();

    OracleDML_OracleDMLKeys::boolean_key_return boolean_key();

    OracleDML_OracleDMLKeys::failure_key_return failure_key();

    OracleDML_OracleDMLKeys::substitutable_key_return substitutable_key();

    OracleDML_OracleDMLKeys::interval_key_return interval_key();

    OracleDML_OracleDMLKeys::instead_key_return instead_key();

    OracleDML_OracleDMLKeys::serially_reusable_key_return serially_reusable_key();

    OracleDML_OracleDMLKeys::exclusive_key_return exclusive_key();

    OracleDML_OracleDMLKeys::zone_key_return zone_key();

    OracleDML_OracleDMLKeys::day_key_return day_key();

    OracleDML_OracleDMLCommons::cursor_name_return cursor_name();

    OracleDML_OracleDMLKeys::automatic_key_return automatic_key();

    OracleDML_OracleDMLKeys::xmlnamespaces_key_return xmlnamespaces_key();

    OracleDML_OracleDMLKeys::c_key_return c_key();

    OracleDML_OracleDMLKeys::share_key_return share_key();

    OracleDML_OracleDMLCommons::implementation_type_name_return implementation_type_name();

    OracleDML_OracleDMLKeys::positiven_key_return positiven_key();

    OracleDML_OracleDMLKeys::auto_key_return auto_key();

    OracleDML_OracleDMLKeys::loop_key_return loop_key();

    OracleDML_OracleDMLKeys::force_key_return force_key();

    OracleDML_OracleDMLKeys::measures_key_return measures_key();

    OracleDML_OracleDMLKeys::over_key_return over_key();

    OracleDML_OracleDMLKeys::sqldata_key_return sqldata_key();

    OracleDML_OracleDMLKeys::parameters_key_return parameters_key();

    OracleDML_OracleDMLKeys::map_key_return map_key();

    OracleDML_OracleDMLKeys::by_key_return by_key();

    OracleDML_OracleDMLKeys::byte_key_return byte_key();

    OracleDML_OracleDMLKeys::begin_key_return begin_key();

    OracleDML_OracleDMLCommons::less_than_or_equals_op_return less_than_or_equals_op();

    OracleDML_OracleDMLKeys::inout_key_return inout_key();

    OracleDML_OracleDMLCommons::outer_join_sign_return outer_join_sign();

    OracleDML_OracleDMLKeys::while_key_return while_key();

    OracleDML_OracleDMLKeys::timezone_hour_key_return timezone_hour_key();

    OracleDML_OracleDMLKeys::numeric_key_return numeric_key();

    OracleDML_OracleDMLCommons::column_alias_return column_alias();

    OracleDML_OracleDMLKeys::binary_float_min_normal_key_return binary_float_min_normal_key();

    OracleDML_OracleDMLKeys::depth_key_return depth_key();

    OracleDML_OracleDMLKeys::all_key_return all_key();

    OracleDML_OracleDMLKeys::xmlattributes_key_return xmlattributes_key();

    OracleDML_OracleDMLKeys::number_key_return number_key();

    OracleDML_OracleDMLKeys::char_key_return char_key();

    OracleDML_OracleDMLKeys::indices_key_return indices_key();

    OracleDML_OracleDMLKeys::constructor_key_return constructor_key();

    OracleDML_OracleDMLKeys::binary_float_infinity_key_return binary_float_infinity_key();

    OracleDML_OracleDMLKeys::element_key_return element_key();

    OracleDML_OracleDMLKeys::dense_rank_key_return dense_rank_key();

    OracleDML_OracleDMLKeys::null_key_return null_key();

    const char *    getGrammarFileName();
    void            reset();
    ~OracleDML();

};

// Function protoypes for the constructor functions that external translation units
// such as delegators and delegates may wish to call.
//

/* End of token definitions for OracleDML
 * =============================================================================
 */

}

#endif

/* END - Note:Keep extra line feed to satisfy UNIX systems */
