/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.3-SNAPSHOT
 *
 *     -  From the grammar source file : OracleDMLCommons.g
 *     -                            On : 2015-09-27 21:38:31
 *     -                for the parser : OracleDML_OracleDMLCommonsParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include "antlr3compilerwarning.hpp"
#include "OracleDML_OracleDMLCommons.hpp"

// Include delegator definition header files
//
#include "OracleDML.hpp" 
#include <memory>

/* ----------------------------------------- */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

namespace  Antlr3BackendImpl  {
using namespace antlr3;

//typedef CommonTreeAdaptor adaptor;
//TreeAdaptor adaptor = new CommonTreeAdaptor();

//void setTreeAdaptor(TreeAdaptor adaptor)
//{
//	this.adaptor = adaptor;
//	<grammar.directDelegates:{g|<g:delegateName()>.setTreeAdaptor(this.adaptor);}>
//}
//TreeAdaptor getTreeAdaptor()
//{
//	return adaptor;
//}
/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "OracleDMLCommons.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* OracleDML_OracleDMLCommons::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new OracleDML_OracleDMLCommons parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
OracleDML_OracleDMLCommons::OracleDML_OracleDMLCommons( StreamType* instream, OracleDML* gOracleDML)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream, gOracleDML);
}

/** \brief Create a new OracleDML_OracleDMLCommons parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
OracleDML_OracleDMLCommons::OracleDML_OracleDMLCommons( StreamType* instream, RecognizerSharedStateType* state, OracleDML* gOracleDML)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream , gOracleDML);
}

void OracleDML_OracleDMLCommons::init(StreamType* instream, OracleDML* gOracleDML)
{
	/* Allocate TreeAdaptorType 
	 */
	// Install the pointers back to lexers that will delegate us to perform certain functions
	// for them.
	//
	m_gOracleDML = gOracleDML;
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( OracleDMLTokenNames );

}

void
OracleDML_OracleDMLCommons::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
OracleDML_OracleDMLCommons::~OracleDML_OracleDMLCommons()
{
}

/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
ANTLR_UINT8**	OracleDML_OracleDMLCommons::getTokenNames()
{
        return OracleDMLTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_subpartition_key_in_partition_extension_clause286_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_subpartition_key_in_partition_extension_clause286( FOLLOW_subpartition_key_in_partition_extension_clause286_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_partition_key_in_partition_extension_clause291_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_partition_key_in_partition_extension_clause291( FOLLOW_partition_key_in_partition_extension_clause291_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_for_key_in_partition_extension_clause305_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_for_key_in_partition_extension_clause305( FOLLOW_for_key_in_partition_extension_clause305_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_partition_extension_clause309_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_expression_list_in_partition_extension_clause309( FOLLOW_expression_list_in_partition_extension_clause309_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_as_key_in_column_alias338_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_as_key_in_column_alias338( FOLLOW_as_key_in_column_alias338_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_column_alias342_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_column_alias342( FOLLOW_id_in_column_alias342_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_alias_quoted_string_in_column_alias345_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_alias_quoted_string_in_column_alias345( FOLLOW_alias_quoted_string_in_column_alias345_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_as_key_in_column_alias377_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_as_key_in_column_alias377( FOLLOW_as_key_in_column_alias377_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_table_alias399_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_table_alias399( FOLLOW_id_in_table_alias399_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_alias_quoted_string_in_table_alias404_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_alias_quoted_string_in_table_alias404( FOLLOW_alias_quoted_string_in_table_alias404_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_alias_quoted_string446_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_alias_quoted_string446( FOLLOW_quoted_string_in_alias_quoted_string446_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_where_key_in_where_clause479_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000100000030), ANTLR_UINT64_LIT(0x4000000000000000), ANTLR_UINT64_LIT(0x010040C00184B882), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_where_key_in_where_clause479( FOLLOW_where_key_in_where_clause479_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_current_of_clause_in_where_clause483_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_current_of_clause_in_where_clause483( FOLLOW_current_of_clause_in_where_clause483_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_condition_wrapper_in_where_clause485_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_condition_wrapper_in_where_clause485( FOLLOW_condition_wrapper_in_where_clause485_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_current_key_in_current_of_clause506_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000010000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_current_key_in_current_of_clause506( FOLLOW_current_key_in_current_of_clause506_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_of_key_in_current_of_clause509_bits[]	= { ANTLR_UINT64_LIT(0x0000000400000000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_of_key_in_current_of_clause509( FOLLOW_of_key_in_current_of_clause509_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_cursor_name_in_current_of_clause512_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_cursor_name_in_current_of_clause512( FOLLOW_cursor_name_in_current_of_clause512_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_into_key_in_into_clause532_bits[]	= { ANTLR_UINT64_LIT(0x0000000400000000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_into_key_in_into_clause532( FOLLOW_into_key_in_into_clause532_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_into_clause535_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_variable_name_in_into_clause535( FOLLOW_variable_name_in_into_clause535_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_into_clause538_bits[]	= { ANTLR_UINT64_LIT(0x0000000400000000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_into_clause538( FOLLOW_COMMA_in_into_clause538_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_into_clause541_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_variable_name_in_into_clause541( FOLLOW_variable_name_in_into_clause541_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_bulk_key_in_into_clause555_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_bulk_key_in_into_clause555( FOLLOW_bulk_key_in_into_clause555_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_collect_key_in_into_clause558_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000800000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_collect_key_in_into_clause558( FOLLOW_collect_key_in_into_clause558_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_into_key_in_into_clause561_bits[]	= { ANTLR_UINT64_LIT(0x0000000400000000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_into_key_in_into_clause561( FOLLOW_into_key_in_into_clause561_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_into_clause564_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_variable_name_in_into_clause564( FOLLOW_variable_name_in_into_clause564_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_into_clause567_bits[]	= { ANTLR_UINT64_LIT(0x0000000400000000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_into_clause567( FOLLOW_COMMA_in_into_clause567_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_into_clause570_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_variable_name_in_into_clause570( FOLLOW_variable_name_in_into_clause570_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_xml_column_name597_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_xml_column_name597( FOLLOW_id_in_xml_column_name597_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_xml_column_name617_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_xml_column_name617( FOLLOW_quoted_string_in_xml_column_name617_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_cost_class_name646_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_cost_class_name646( FOLLOW_id_in_cost_class_name646_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_attribute_name683_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_attribute_name683( FOLLOW_id_in_attribute_name683_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_savepoint_name720_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_savepoint_name720( FOLLOW_id_in_savepoint_name720_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_rollback_segment_name757_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_rollback_segment_name757( FOLLOW_id_in_rollback_segment_name757_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_package_name810_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_package_name810( FOLLOW_id_in_package_name810_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_implementation_type_name847_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_implementation_type_name847( FOLLOW_id_in_implementation_type_name847_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_implementation_type_name859_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_implementation_type_name859( FOLLOW_PERIOD_in_implementation_type_name859_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_implementation_type_name861_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_implementation_type_name861( FOLLOW_id_expression_in_implementation_type_name861_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_parameter_name903_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_parameter_name903( FOLLOW_id_in_parameter_name903_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_reference_model_name940_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_reference_model_name940( FOLLOW_id_in_reference_model_name940_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_main_model_name977_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_main_model_name977( FOLLOW_id_in_main_model_name977_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_aggregate_function_name1014_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_aggregate_function_name1014( FOLLOW_id_in_aggregate_function_name1014_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_aggregate_function_name1026_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_aggregate_function_name1026( FOLLOW_PERIOD_in_aggregate_function_name1026_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_aggregate_function_name1028_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_aggregate_function_name1028( FOLLOW_id_expression_in_aggregate_function_name1028_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_query_name1070_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_query_name1070( FOLLOW_id_in_query_name1070_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_constraint_name1107_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_constraint_name1107( FOLLOW_id_in_constraint_name1107_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_constraint_name1119_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_constraint_name1119( FOLLOW_PERIOD_in_constraint_name1119_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_constraint_name1121_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_constraint_name1121( FOLLOW_id_expression_in_constraint_name1121_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_AT_SIGN_in_constraint_name1127_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_AT_SIGN_in_constraint_name1127( FOLLOW_AT_SIGN_in_constraint_name1127_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_link_name_in_constraint_name1129_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_link_name_in_constraint_name1129( FOLLOW_link_name_in_constraint_name1129_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_label_name1173_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_label_name1173( FOLLOW_id_expression_in_label_name1173_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_type_name1210_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_type_name1210( FOLLOW_id_expression_in_type_name1210_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_type_name1222_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_type_name1222( FOLLOW_PERIOD_in_type_name1222_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_type_name1224_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_type_name1224( FOLLOW_id_expression_in_type_name1224_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_sequence_name1264_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_sequence_name1264( FOLLOW_id_expression_in_sequence_name1264_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_sequence_name1276_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_sequence_name1276( FOLLOW_PERIOD_in_sequence_name1276_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_sequence_name1278_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_sequence_name1278( FOLLOW_id_expression_in_sequence_name1278_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_exception_name1318_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_exception_name1318( FOLLOW_id_in_exception_name1318_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_exception_name1330_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_exception_name1330( FOLLOW_PERIOD_in_exception_name1330_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_exception_name1332_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_exception_name1332( FOLLOW_id_expression_in_exception_name1332_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_function_name1374_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_function_name1374( FOLLOW_id_in_function_name1374_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_function_name1386_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_function_name1386( FOLLOW_PERIOD_in_function_name1386_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_function_name1388_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_function_name1388( FOLLOW_id_expression_in_function_name1388_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_procedure_name1430_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_procedure_name1430( FOLLOW_id_in_procedure_name1430_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_procedure_name1442_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_procedure_name1442( FOLLOW_PERIOD_in_procedure_name1442_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_procedure_name1444_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_procedure_name1444( FOLLOW_id_expression_in_procedure_name1444_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_trigger_name1486_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_trigger_name1486( FOLLOW_id_in_trigger_name1486_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_trigger_name1498_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_trigger_name1498( FOLLOW_PERIOD_in_trigger_name1498_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_trigger_name1500_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_trigger_name1500( FOLLOW_id_expression_in_trigger_name1500_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_INTRODUCER_in_variable_name1542_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_INTRODUCER_in_variable_name1542( FOLLOW_INTRODUCER_in_variable_name1542_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_char_set_name_in_variable_name1544_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_char_set_name_in_variable_name1544( FOLLOW_char_set_name_in_variable_name1544_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_variable_name1560_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_variable_name1560( FOLLOW_id_expression_in_variable_name1560_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_variable_name1572_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_variable_name1572( FOLLOW_PERIOD_in_variable_name1572_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_variable_name1574_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_variable_name1574( FOLLOW_id_expression_in_variable_name1574_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_variable_name1608_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_variable_name1608( FOLLOW_bind_variable_in_variable_name1608_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_index_name1644_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_index_name1644( FOLLOW_id_in_index_name1644_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_cursor_name1682_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_cursor_name1682( FOLLOW_id_in_cursor_name1682_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_cursor_name1687_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_cursor_name1687( FOLLOW_bind_variable_in_cursor_name1687_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_record_name1729_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_record_name1729( FOLLOW_id_in_record_name1729_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_record_name1734_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_record_name1734( FOLLOW_bind_variable_in_record_name1734_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_collection_name1770_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_collection_name1770( FOLLOW_id_in_collection_name1770_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_collection_name1782_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_collection_name1782( FOLLOW_PERIOD_in_collection_name1782_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_collection_name1784_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_collection_name1784( FOLLOW_id_expression_in_collection_name1784_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_link_name1825_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_link_name1825( FOLLOW_id_in_link_name1825_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_column_name1914_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_column_name1914( FOLLOW_id_in_column_name1914_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_column_name1917_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_column_name1917( FOLLOW_PERIOD_in_column_name1917_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_column_name1919_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_column_name1919( FOLLOW_id_expression_in_column_name1919_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_column_name1924_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_column_name1924( FOLLOW_PERIOD_in_column_name1924_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_column_name1926_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_column_name1926( FOLLOW_id_expression_in_column_name1926_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_column_name1976_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_column_name1976( FOLLOW_id_in_column_name1976_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_column_name1979_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_column_name1979( FOLLOW_PERIOD_in_column_name1979_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_column_name1981_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_column_name1981( FOLLOW_id_expression_in_column_name1981_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_column_name2023_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_column_name2023( FOLLOW_id_in_column_name2023_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_tableview_name2099_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_tableview_name2099( FOLLOW_id_in_tableview_name2099_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_tableview_name2102_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_tableview_name2102( FOLLOW_PERIOD_in_tableview_name2102_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_tableview_name2104_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_tableview_name2104( FOLLOW_id_expression_in_tableview_name2104_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_tableview_name2119_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_tableview_name2119( FOLLOW_id_in_tableview_name2119_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_AT_SIGN_in_tableview_name2141_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_AT_SIGN_in_tableview_name2141( FOLLOW_AT_SIGN_in_tableview_name2141_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_link_name_in_tableview_name2143_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_link_name_in_tableview_name2143( FOLLOW_link_name_in_tableview_name2143_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_partition_extension_clause_in_tableview_name2157_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_partition_extension_clause_in_tableview_name2157( FOLLOW_partition_extension_clause_in_tableview_name2157_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_char_set_name2209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_char_set_name2209( FOLLOW_id_expression_in_char_set_name2209_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_char_set_name2221_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_char_set_name2221( FOLLOW_PERIOD_in_char_set_name2221_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_char_set_name2223_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_char_set_name2223( FOLLOW_id_expression_in_char_set_name2223_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_keep_key_in_keep_clause2266_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_keep_key_in_keep_clause2266( FOLLOW_keep_key_in_keep_clause2266_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_keep_clause2277_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_keep_clause2277( FOLLOW_LEFT_PAREN_in_keep_clause2277_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_dense_rank_key_in_keep_clause2292_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_dense_rank_key_in_keep_clause2292( FOLLOW_dense_rank_key_in_keep_clause2292_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_first_key_in_keep_clause2295_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000100000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_first_key_in_keep_clause2295( FOLLOW_first_key_in_keep_clause2295_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_last_key_in_keep_clause2297_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000100000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_last_key_in_keep_clause2297( FOLLOW_last_key_in_keep_clause2297_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_keep_clause2313_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_order_by_clause_in_keep_clause2313( FOLLOW_order_by_clause_in_keep_clause2313_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_keep_clause2323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_keep_clause2323( FOLLOW_RIGHT_PAREN_in_keep_clause2323_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_keep_clause2326_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_over_clause_in_keep_clause2326( FOLLOW_over_clause_in_keep_clause2326_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_function_argument2347_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000012), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000100000030), ANTLR_UINT64_LIT(0x4000000000000200), ANTLR_UINT64_LIT(0x010040C00184B082), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_function_argument2347( FOLLOW_LEFT_PAREN_in_function_argument2347_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_argument_in_function_argument2362_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_argument_in_function_argument2362( FOLLOW_argument_in_function_argument2362_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument2366_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000100000030), ANTLR_UINT64_LIT(0x4000000000000000), ANTLR_UINT64_LIT(0x010040C00184B082), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument2366( FOLLOW_COMMA_in_function_argument2366_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_argument_in_function_argument2368_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_argument_in_function_argument2368( FOLLOW_argument_in_function_argument2368_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_function_argument2382_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_function_argument2382( FOLLOW_RIGHT_PAREN_in_function_argument2382_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_keep_clause_in_function_argument2392_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_keep_clause_in_function_argument2392( FOLLOW_keep_clause_in_function_argument2392_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_function_argument_analytic2433_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000012), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000100000030), ANTLR_UINT64_LIT(0x4000000000000200), ANTLR_UINT64_LIT(0x010040C00184B082), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_function_argument_analytic2433( FOLLOW_LEFT_PAREN_in_function_argument_analytic2433_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_argument_in_function_argument_analytic2448_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_argument_in_function_argument_analytic2448( FOLLOW_argument_in_function_argument_analytic2448_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic2450_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic2450( FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic2450_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument_analytic2468_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000100000030), ANTLR_UINT64_LIT(0x4000000000000000), ANTLR_UINT64_LIT(0x010040C00184B082), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument_analytic2468( FOLLOW_COMMA_in_function_argument_analytic2468_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_argument_in_function_argument_analytic2470_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_argument_in_function_argument_analytic2470( FOLLOW_argument_in_function_argument_analytic2470_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic2472_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic2472( FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic2472_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_function_argument_analytic2487_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_function_argument_analytic2487( FOLLOW_RIGHT_PAREN_in_function_argument_analytic2487_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_keep_clause_in_function_argument_analytic2498_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_keep_clause_in_function_argument_analytic2498( FOLLOW_keep_clause_in_function_argument_analytic2498_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_function_argument_modeling2540_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_function_argument_modeling2540( FOLLOW_LEFT_PAREN_in_function_argument_modeling2540_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_column_name_in_function_argument_modeling2554_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_column_name_in_function_argument_modeling2554( FOLLOW_column_name_in_function_argument_modeling2554_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument_modeling2557_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000008000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument_modeling2557( FOLLOW_COMMA_in_function_argument_modeling2557_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_function_argument_modeling2560_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_function_argument_modeling2560( FOLLOW_numeric_in_function_argument_modeling2560_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_null_key_in_function_argument_modeling2562_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_null_key_in_function_argument_modeling2562( FOLLOW_null_key_in_function_argument_modeling2562_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument_modeling2566_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000008000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument_modeling2566( FOLLOW_COMMA_in_function_argument_modeling2566_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_function_argument_modeling2569_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_function_argument_modeling2569( FOLLOW_numeric_in_function_argument_modeling2569_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_null_key_in_function_argument_modeling2571_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_null_key_in_function_argument_modeling2571( FOLLOW_null_key_in_function_argument_modeling2571_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_using_key_in_function_argument_modeling2592_bits[]	= { ANTLR_UINT64_LIT(0x0180000400082000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000100000030), ANTLR_UINT64_LIT(0x4000000000000000), ANTLR_UINT64_LIT(0x010040C00184B082), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_using_key_in_function_argument_modeling2592( FOLLOW_using_key_in_function_argument_modeling2592_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_function_argument_modeling2621_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_tableview_name_in_function_argument_modeling2621( FOLLOW_tableview_name_in_function_argument_modeling2621_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_function_argument_modeling2623_bits[]	= { ANTLR_UINT64_LIT(0x0000000000080000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_function_argument_modeling2623( FOLLOW_PERIOD_in_function_argument_modeling2623_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_function_argument_modeling2625_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_ASTERISK_in_function_argument_modeling2625( FOLLOW_ASTERISK_in_function_argument_modeling2625_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_function_argument_modeling2645_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_ASTERISK_in_function_argument_modeling2645( FOLLOW_ASTERISK_in_function_argument_modeling2645_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_in_function_argument_modeling2665_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0002000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000000000000), ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_expression_in_function_argument_modeling2665( FOLLOW_expression_in_function_argument_modeling2665_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_function_argument_modeling2667_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_column_alias_in_function_argument_modeling2667( FOLLOW_column_alias_in_function_argument_modeling2667_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument_modeling2671_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000100000030), ANTLR_UINT64_LIT(0x4000000000000000), ANTLR_UINT64_LIT(0x010040C00184B082), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument_modeling2671( FOLLOW_COMMA_in_function_argument_modeling2671_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_in_function_argument_modeling2673_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0002000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000000000000), ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_expression_in_function_argument_modeling2673( FOLLOW_expression_in_function_argument_modeling2673_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_function_argument_modeling2675_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_column_alias_in_function_argument_modeling2675( FOLLOW_column_alias_in_function_argument_modeling2675_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_function_argument_modeling2707_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_function_argument_modeling2707( FOLLOW_RIGHT_PAREN_in_function_argument_modeling2707_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_keep_clause_in_function_argument_modeling2718_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_keep_clause_in_function_argument_modeling2718( FOLLOW_keep_clause_in_function_argument_modeling2718_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_respect_key_in_respect_or_ignore_nulls2760_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_respect_key_in_respect_or_ignore_nulls2760( FOLLOW_respect_key_in_respect_or_ignore_nulls2760_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_ignore_key_in_respect_or_ignore_nulls2764_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_ignore_key_in_respect_or_ignore_nulls2764( FOLLOW_ignore_key_in_respect_or_ignore_nulls2764_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_respect_or_ignore_nulls2767_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_nulls_key_in_respect_or_ignore_nulls2767( FOLLOW_nulls_key_in_respect_or_ignore_nulls2767_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_argument2806_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_argument2806( FOLLOW_id_in_argument2806_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_argument2809_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_argument2809( FOLLOW_EQUALS_OP_in_argument2809_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_argument2811_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000100000030), ANTLR_UINT64_LIT(0x4000000000000000), ANTLR_UINT64_LIT(0x010040C00184B082), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_argument2811( FOLLOW_GREATER_THAN_OP_in_argument2811_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_argument2817_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_expression_wrapper_in_argument2817( FOLLOW_expression_wrapper_in_argument2817_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_datatype_in_type_spec2878_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_datatype_in_type_spec2878( FOLLOW_datatype_in_type_spec2878_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_ref_key_in_type_spec2889_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_ref_key_in_type_spec2889( FOLLOW_ref_key_in_type_spec2889_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_type_name_in_type_spec2892_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_type_name_in_type_spec2892( FOLLOW_type_name_in_type_spec2892_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_percent_rowtype_key_in_type_spec2895_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_percent_rowtype_key_in_type_spec2895( FOLLOW_percent_rowtype_key_in_type_spec2895_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_percent_type_key_in_type_spec2897_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_percent_type_key_in_type_spec2897( FOLLOW_percent_type_key_in_type_spec2897_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_native_datatype_element_in_datatype2936_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_native_datatype_element_in_datatype2936( FOLLOW_native_datatype_element_in_datatype2936_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_precision_part_in_datatype2946_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_precision_part_in_datatype2946( FOLLOW_precision_part_in_datatype2946_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_with_key_in_datatype2958_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_with_key_in_datatype2958( FOLLOW_with_key_in_datatype2958_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_local_key_in_datatype2960_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_local_key_in_datatype2960( FOLLOW_local_key_in_datatype2960_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_time_key_in_datatype2963_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_time_key_in_datatype2963( FOLLOW_time_key_in_datatype2963_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_zone_key_in_datatype2965_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_zone_key_in_datatype2965( FOLLOW_zone_key_in_datatype2965_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_interval_key_in_datatype3003_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_interval_key_in_datatype3003( FOLLOW_interval_key_in_datatype3003_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_year_key_in_datatype3006_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_year_key_in_datatype3006( FOLLOW_year_key_in_datatype3006_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_day_key_in_datatype3008_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_day_key_in_datatype3008( FOLLOW_day_key_in_datatype3008_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_datatype3028_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000100000030), ANTLR_UINT64_LIT(0x4000000000000000), ANTLR_UINT64_LIT(0x010040C00184B082), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_datatype3028( FOLLOW_LEFT_PAREN_in_datatype3028_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_datatype3030_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_expression_wrapper_in_datatype3030( FOLLOW_expression_wrapper_in_datatype3030_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_datatype3032_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_datatype3032( FOLLOW_RIGHT_PAREN_in_datatype3032_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_to_key_in_datatype3049_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_to_key_in_datatype3049( FOLLOW_to_key_in_datatype3049_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_month_key_in_datatype3052_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_month_key_in_datatype3052( FOLLOW_month_key_in_datatype3052_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_second_key_in_datatype3054_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_second_key_in_datatype3054( FOLLOW_second_key_in_datatype3054_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_datatype3075_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000100000030), ANTLR_UINT64_LIT(0x4000000000000000), ANTLR_UINT64_LIT(0x010040C00184B082), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_datatype3075( FOLLOW_LEFT_PAREN_in_datatype3075_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_datatype3077_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_expression_wrapper_in_datatype3077( FOLLOW_expression_wrapper_in_datatype3077_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_datatype3079_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_datatype3079( FOLLOW_RIGHT_PAREN_in_datatype3079_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_precision_part3131_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_precision_part3131( FOLLOW_LEFT_PAREN_in_precision_part3131_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_precision_part3133_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_precision_part3133( FOLLOW_numeric_in_precision_part3133_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_precision_part3136_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_precision_part3136( FOLLOW_COMMA_in_precision_part3136_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_precision_part3138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_precision_part3138( FOLLOW_numeric_in_precision_part3138_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_char_key_in_precision_part3143_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_char_key_in_precision_part3143( FOLLOW_char_key_in_precision_part3143_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_byte_key_in_precision_part3147_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_byte_key_in_precision_part3147( FOLLOW_byte_key_in_precision_part3147_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_precision_part3151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_precision_part3151( FOLLOW_RIGHT_PAREN_in_precision_part3151_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_binary_integer_key_in_native_datatype_element3194_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_binary_integer_key_in_native_datatype_element3194( FOLLOW_binary_integer_key_in_native_datatype_element3194_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_pls_integer_key_in_native_datatype_element3205_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_pls_integer_key_in_native_datatype_element3205( FOLLOW_pls_integer_key_in_native_datatype_element3205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_natural_key_in_native_datatype_element3216_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_natural_key_in_native_datatype_element3216( FOLLOW_natural_key_in_native_datatype_element3216_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_binary_float_key_in_native_datatype_element3227_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_binary_float_key_in_native_datatype_element3227( FOLLOW_binary_float_key_in_native_datatype_element3227_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_binary_double_key_in_native_datatype_element3238_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_binary_double_key_in_native_datatype_element3238( FOLLOW_binary_double_key_in_native_datatype_element3238_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_naturaln_key_in_native_datatype_element3249_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_naturaln_key_in_native_datatype_element3249( FOLLOW_naturaln_key_in_native_datatype_element3249_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_positive_key_in_native_datatype_element3260_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_positive_key_in_native_datatype_element3260( FOLLOW_positive_key_in_native_datatype_element3260_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_positiven_key_in_native_datatype_element3271_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_positiven_key_in_native_datatype_element3271( FOLLOW_positiven_key_in_native_datatype_element3271_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_signtype_key_in_native_datatype_element3282_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_signtype_key_in_native_datatype_element3282( FOLLOW_signtype_key_in_native_datatype_element3282_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_simple_integer_key_in_native_datatype_element3293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_simple_integer_key_in_native_datatype_element3293( FOLLOW_simple_integer_key_in_native_datatype_element3293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_nvarchar2_key_in_native_datatype_element3304_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_nvarchar2_key_in_native_datatype_element3304( FOLLOW_nvarchar2_key_in_native_datatype_element3304_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_dec_key_in_native_datatype_element3315_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_dec_key_in_native_datatype_element3315( FOLLOW_dec_key_in_native_datatype_element3315_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_integer_key_in_native_datatype_element3326_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_integer_key_in_native_datatype_element3326( FOLLOW_integer_key_in_native_datatype_element3326_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_int_key_in_native_datatype_element3337_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_int_key_in_native_datatype_element3337( FOLLOW_int_key_in_native_datatype_element3337_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_key_in_native_datatype_element3348_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_numeric_key_in_native_datatype_element3348( FOLLOW_numeric_key_in_native_datatype_element3348_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_smallint_key_in_native_datatype_element3359_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_smallint_key_in_native_datatype_element3359( FOLLOW_smallint_key_in_native_datatype_element3359_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_number_key_in_native_datatype_element3370_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_number_key_in_native_datatype_element3370( FOLLOW_number_key_in_native_datatype_element3370_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_decimal_key_in_native_datatype_element3381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_decimal_key_in_native_datatype_element3381( FOLLOW_decimal_key_in_native_datatype_element3381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_double_key_in_native_datatype_element3393_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_double_key_in_native_datatype_element3393( FOLLOW_double_key_in_native_datatype_element3393_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_precision_key_in_native_datatype_element3395_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_precision_key_in_native_datatype_element3395( FOLLOW_precision_key_in_native_datatype_element3395_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_float_key_in_native_datatype_element3407_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_float_key_in_native_datatype_element3407( FOLLOW_float_key_in_native_datatype_element3407_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_real_key_in_native_datatype_element3418_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_real_key_in_native_datatype_element3418( FOLLOW_real_key_in_native_datatype_element3418_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_nchar_key_in_native_datatype_element3429_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_nchar_key_in_native_datatype_element3429( FOLLOW_nchar_key_in_native_datatype_element3429_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_long_key_in_native_datatype_element3440_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_long_key_in_native_datatype_element3440( FOLLOW_long_key_in_native_datatype_element3440_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_raw_key_in_native_datatype_element3442_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_raw_key_in_native_datatype_element3442( FOLLOW_raw_key_in_native_datatype_element3442_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_char_key_in_native_datatype_element3454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_char_key_in_native_datatype_element3454( FOLLOW_char_key_in_native_datatype_element3454_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_character_key_in_native_datatype_element3467_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_character_key_in_native_datatype_element3467( FOLLOW_character_key_in_native_datatype_element3467_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_varchar2_key_in_native_datatype_element3479_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_varchar2_key_in_native_datatype_element3479( FOLLOW_varchar2_key_in_native_datatype_element3479_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_varchar_key_in_native_datatype_element3490_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_varchar_key_in_native_datatype_element3490( FOLLOW_varchar_key_in_native_datatype_element3490_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_string_key_in_native_datatype_element3501_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_string_key_in_native_datatype_element3501( FOLLOW_string_key_in_native_datatype_element3501_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_raw_key_in_native_datatype_element3512_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_raw_key_in_native_datatype_element3512( FOLLOW_raw_key_in_native_datatype_element3512_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_boolean_key_in_native_datatype_element3523_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_boolean_key_in_native_datatype_element3523( FOLLOW_boolean_key_in_native_datatype_element3523_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_date_key_in_native_datatype_element3534_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_date_key_in_native_datatype_element3534( FOLLOW_date_key_in_native_datatype_element3534_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_rowid_key_in_native_datatype_element3545_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_rowid_key_in_native_datatype_element3545( FOLLOW_rowid_key_in_native_datatype_element3545_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_urowid_key_in_native_datatype_element3556_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_urowid_key_in_native_datatype_element3556( FOLLOW_urowid_key_in_native_datatype_element3556_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_year_key_in_native_datatype_element3567_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_year_key_in_native_datatype_element3567( FOLLOW_year_key_in_native_datatype_element3567_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_month_key_in_native_datatype_element3578_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_month_key_in_native_datatype_element3578( FOLLOW_month_key_in_native_datatype_element3578_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_day_key_in_native_datatype_element3589_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_day_key_in_native_datatype_element3589( FOLLOW_day_key_in_native_datatype_element3589_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_hour_key_in_native_datatype_element3600_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_hour_key_in_native_datatype_element3600( FOLLOW_hour_key_in_native_datatype_element3600_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_minute_key_in_native_datatype_element3611_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_minute_key_in_native_datatype_element3611( FOLLOW_minute_key_in_native_datatype_element3611_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_second_key_in_native_datatype_element3622_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_second_key_in_native_datatype_element3622( FOLLOW_second_key_in_native_datatype_element3622_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_timezone_hour_key_in_native_datatype_element3633_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_timezone_hour_key_in_native_datatype_element3633( FOLLOW_timezone_hour_key_in_native_datatype_element3633_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_timezone_minute_key_in_native_datatype_element3644_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_timezone_minute_key_in_native_datatype_element3644( FOLLOW_timezone_minute_key_in_native_datatype_element3644_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_timezone_region_key_in_native_datatype_element3655_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_timezone_region_key_in_native_datatype_element3655( FOLLOW_timezone_region_key_in_native_datatype_element3655_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_timezone_abbr_key_in_native_datatype_element3666_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_timezone_abbr_key_in_native_datatype_element3666( FOLLOW_timezone_abbr_key_in_native_datatype_element3666_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_key_in_native_datatype_element3677_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_timestamp_key_in_native_datatype_element3677( FOLLOW_timestamp_key_in_native_datatype_element3677_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_unconstrained_key_in_native_datatype_element3688_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_timestamp_unconstrained_key_in_native_datatype_element3688( FOLLOW_timestamp_unconstrained_key_in_native_datatype_element3688_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_tz_unconstrained_key_in_native_datatype_element3699_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_timestamp_tz_unconstrained_key_in_native_datatype_element3699( FOLLOW_timestamp_tz_unconstrained_key_in_native_datatype_element3699_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_ltz_unconstrained_key_in_native_datatype_element3710_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_timestamp_ltz_unconstrained_key_in_native_datatype_element3710( FOLLOW_timestamp_ltz_unconstrained_key_in_native_datatype_element3710_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_yminterval_unconstrained_key_in_native_datatype_element3721_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_yminterval_unconstrained_key_in_native_datatype_element3721( FOLLOW_yminterval_unconstrained_key_in_native_datatype_element3721_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_dsinterval_unconstrained_key_in_native_datatype_element3732_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_dsinterval_unconstrained_key_in_native_datatype_element3732( FOLLOW_dsinterval_unconstrained_key_in_native_datatype_element3732_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_bfile_key_in_native_datatype_element3743_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_bfile_key_in_native_datatype_element3743( FOLLOW_bfile_key_in_native_datatype_element3743_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_blob_key_in_native_datatype_element3754_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_blob_key_in_native_datatype_element3754( FOLLOW_blob_key_in_native_datatype_element3754_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_clob_key_in_native_datatype_element3765_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_clob_key_in_native_datatype_element3765( FOLLOW_clob_key_in_native_datatype_element3765_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_nclob_key_in_native_datatype_element3776_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_nclob_key_in_native_datatype_element3776( FOLLOW_nclob_key_in_native_datatype_element3776_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_mlslabel_key_in_native_datatype_element3787_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_mlslabel_key_in_native_datatype_element3787( FOLLOW_mlslabel_key_in_native_datatype_element3787_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_BINDVAR_in_bind_variable3811_bits[]	= { ANTLR_UINT64_LIT(0x0000000400000002), ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_BINDVAR_in_bind_variable3811( FOLLOW_BINDVAR_in_bind_variable3811_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_COLON_in_bind_variable3815_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_COLON_in_bind_variable3815( FOLLOW_COLON_in_bind_variable3815_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_bind_variable3819_bits[]	= { ANTLR_UINT64_LIT(0x0000000400000002), ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_bind_variable3819( FOLLOW_UNSIGNED_INTEGER_in_bind_variable3819_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_indicator_key_in_bind_variable3833_bits[]	= { ANTLR_UINT64_LIT(0x0000000400000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_indicator_key_in_bind_variable3833( FOLLOW_indicator_key_in_bind_variable3833_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_BINDVAR_in_bind_variable3839_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_BINDVAR_in_bind_variable3839( FOLLOW_BINDVAR_in_bind_variable3839_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_COLON_in_bind_variable3843_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_COLON_in_bind_variable3843( FOLLOW_COLON_in_bind_variable3843_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_bind_variable3847_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_bind_variable3847( FOLLOW_UNSIGNED_INTEGER_in_bind_variable3847_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_bind_variable3869_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_bind_variable3869( FOLLOW_PERIOD_in_bind_variable3869_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_bind_variable3871_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_bind_variable3871( FOLLOW_general_element_part_in_bind_variable3871_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_general_element3937_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_general_element3937( FOLLOW_general_element_part_in_general_element3937_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_general_element3947_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_general_element3947( FOLLOW_PERIOD_in_general_element3947_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_general_element3949_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_general_element3949( FOLLOW_general_element_part_in_general_element3949_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_INTRODUCER_in_general_element_part4012_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_INTRODUCER_in_general_element_part4012( FOLLOW_INTRODUCER_in_general_element_part4012_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_char_set_name_in_general_element_part4014_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_char_set_name_in_general_element_part4014( FOLLOW_char_set_name_in_general_element_part4014_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_general_element_part4018_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_general_element_part4018( FOLLOW_id_expression_in_general_element_part4018_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_general_element_part4042_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_general_element_part4042( FOLLOW_PERIOD_in_general_element_part4042_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_general_element_part4044_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_general_element_part4044( FOLLOW_id_expression_in_general_element_part4044_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_function_argument_in_general_element_part4050_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_function_argument_in_general_element_part4050( FOLLOW_function_argument_in_general_element_part4050_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_INTRODUCER_in_table_element4122_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_INTRODUCER_in_table_element4122( FOLLOW_INTRODUCER_in_table_element4122_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_char_set_name_in_table_element4124_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_char_set_name_in_table_element4124( FOLLOW_char_set_name_in_table_element4124_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_table_element4128_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_table_element4128( FOLLOW_id_expression_in_table_element4128_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_table_element4132_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_table_element4132( FOLLOW_PERIOD_in_table_element4132_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_table_element4134_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_table_element4134( FOLLOW_id_expression_in_table_element4134_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_key_in_constant4182_bits[]	= { ANTLR_UINT64_LIT(0x0180000400000000), ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_timestamp_key_in_constant4182( FOLLOW_timestamp_key_in_constant4182_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant4185_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant4185( FOLLOW_quoted_string_in_constant4185_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant4189_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant4189( FOLLOW_bind_variable_in_constant4189_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_at_key_in_constant4193_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_at_key_in_constant4193( FOLLOW_at_key_in_constant4193_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_time_key_in_constant4195_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_time_key_in_constant4195( FOLLOW_time_key_in_constant4195_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_zone_key_in_constant4197_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_zone_key_in_constant4197( FOLLOW_zone_key_in_constant4197_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant4199_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant4199( FOLLOW_quoted_string_in_constant4199_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_interval_key_in_constant4212_bits[]	= { ANTLR_UINT64_LIT(0x0180000400000000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_interval_key_in_constant4212( FOLLOW_interval_key_in_constant4212_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant4215_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant4215( FOLLOW_quoted_string_in_constant4215_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant4219_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant4219( FOLLOW_bind_variable_in_constant4219_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_constant4223_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_constant4223( FOLLOW_general_element_part_in_constant4223_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_day_key_in_constant4237_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_day_key_in_constant4237( FOLLOW_day_key_in_constant4237_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_hour_key_in_constant4241_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_hour_key_in_constant4241( FOLLOW_hour_key_in_constant4241_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_minute_key_in_constant4245_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_minute_key_in_constant4245( FOLLOW_minute_key_in_constant4245_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_second_key_in_constant4249_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_second_key_in_constant4249( FOLLOW_second_key_in_constant4249_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_constant4263_bits[]	= { ANTLR_UINT64_LIT(0x0000000400000000), ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_constant4263( FOLLOW_LEFT_PAREN_in_constant4263_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_constant4266_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_constant4266( FOLLOW_UNSIGNED_INTEGER_in_constant4266_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant4270_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant4270( FOLLOW_bind_variable_in_constant4270_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_constant4274_bits[]	= { ANTLR_UINT64_LIT(0x0000000400000000), ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_constant4274( FOLLOW_COMMA_in_constant4274_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_constant4277_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_constant4277( FOLLOW_UNSIGNED_INTEGER_in_constant4277_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant4281_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant4281( FOLLOW_bind_variable_in_constant4281_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_constant4287_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_constant4287( FOLLOW_RIGHT_PAREN_in_constant4287_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_to_key_in_constant4302_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_to_key_in_constant4302( FOLLOW_to_key_in_constant4302_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_day_key_in_constant4319_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_day_key_in_constant4319( FOLLOW_day_key_in_constant4319_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_hour_key_in_constant4323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_hour_key_in_constant4323( FOLLOW_hour_key_in_constant4323_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_minute_key_in_constant4327_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_minute_key_in_constant4327( FOLLOW_minute_key_in_constant4327_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_second_key_in_constant4331_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_second_key_in_constant4331( FOLLOW_second_key_in_constant4331_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_constant4334_bits[]	= { ANTLR_UINT64_LIT(0x0000000400000000), ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_constant4334( FOLLOW_LEFT_PAREN_in_constant4334_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_constant4337_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_constant4337( FOLLOW_UNSIGNED_INTEGER_in_constant4337_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant4341_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant4341( FOLLOW_bind_variable_in_constant4341_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_constant4344_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_constant4344( FOLLOW_RIGHT_PAREN_in_constant4344_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_constant4371_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_constant4371( FOLLOW_numeric_in_constant4371_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_date_key_in_constant4382_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_date_key_in_constant4382( FOLLOW_date_key_in_constant4382_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant4384_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant4384( FOLLOW_quoted_string_in_constant4384_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant4395_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant4395( FOLLOW_quoted_string_in_constant4395_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_null_key_in_constant4406_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_null_key_in_constant4406( FOLLOW_null_key_in_constant4406_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_true_key_in_constant4417_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_true_key_in_constant4417( FOLLOW_true_key_in_constant4417_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_false_key_in_constant4428_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_false_key_in_constant4428( FOLLOW_false_key_in_constant4428_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_dbtimezone_key_in_constant4439_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_dbtimezone_key_in_constant4439( FOLLOW_dbtimezone_key_in_constant4439_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_sessiontimezone_key_in_constant4451_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_sessiontimezone_key_in_constant4451( FOLLOW_sessiontimezone_key_in_constant4451_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_minvalue_key_in_constant4462_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_minvalue_key_in_constant4462( FOLLOW_minvalue_key_in_constant4462_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_maxvalue_key_in_constant4473_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_maxvalue_key_in_constant4473( FOLLOW_maxvalue_key_in_constant4473_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_default_key_in_constant4484_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_default_key_in_constant4484( FOLLOW_default_key_in_constant4484_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_INTRODUCER_in_id4585_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_INTRODUCER_in_id4585( FOLLOW_INTRODUCER_in_id4585_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_char_set_name_in_id4587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_char_set_name_in_id4587( FOLLOW_char_set_name_in_id4587_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_id4601_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_id4601( FOLLOW_id_expression_in_id4601_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_id_expression4638_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_id_expression4638( FOLLOW_REGULAR_ID_in_id_expression4638_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_DELIMITED_ID_in_id_expression4655_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_DELIMITED_ID_in_id_expression4655( FOLLOW_DELIMITED_ID_in_id_expression4655_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_NOT_EQUAL_OP_in_not_equal_op4677_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_NOT_EQUAL_OP_in_not_equal_op4677( FOLLOW_NOT_EQUAL_OP_in_not_equal_op4677_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OP_in_not_equal_op4688_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_LESS_THAN_OP_in_not_equal_op4688( FOLLOW_LESS_THAN_OP_in_not_equal_op4688_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_not_equal_op4690_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_not_equal_op4690( FOLLOW_GREATER_THAN_OP_in_not_equal_op4690_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_EXCLAMATION_OPERATOR_PART_in_not_equal_op4701_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_EXCLAMATION_OPERATOR_PART_in_not_equal_op4701( FOLLOW_EXCLAMATION_OPERATOR_PART_in_not_equal_op4701_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_not_equal_op4703_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_not_equal_op4703( FOLLOW_EQUALS_OP_in_not_equal_op4703_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_CARRET_OPERATOR_PART_in_not_equal_op4714_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_CARRET_OPERATOR_PART_in_not_equal_op4714( FOLLOW_CARRET_OPERATOR_PART_in_not_equal_op4714_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_not_equal_op4716_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_not_equal_op4716( FOLLOW_EQUALS_OP_in_not_equal_op4716_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OR_EQUALS_OP_in_greater_than_or_equals_op4736_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OR_EQUALS_OP_in_greater_than_or_equals_op4736( FOLLOW_GREATER_THAN_OR_EQUALS_OP_in_greater_than_or_equals_op4736_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_greater_than_or_equals_op4747_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_greater_than_or_equals_op4747( FOLLOW_GREATER_THAN_OP_in_greater_than_or_equals_op4747_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_greater_than_or_equals_op4749_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_greater_than_or_equals_op4749( FOLLOW_EQUALS_OP_in_greater_than_or_equals_op4749_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OR_EQUALS_OP_in_less_than_or_equals_op4769_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_LESS_THAN_OR_EQUALS_OP_in_less_than_or_equals_op4769( FOLLOW_LESS_THAN_OR_EQUALS_OP_in_less_than_or_equals_op4769_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OP_in_less_than_or_equals_op4780_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_LESS_THAN_OP_in_less_than_or_equals_op4780( FOLLOW_LESS_THAN_OP_in_less_than_or_equals_op4780_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_less_than_or_equals_op4782_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_less_than_or_equals_op4782( FOLLOW_EQUALS_OP_in_less_than_or_equals_op4782_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_CONCATENATION_OP_in_concatenation_op4802_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_CONCATENATION_OP_in_concatenation_op4802( FOLLOW_CONCATENATION_OP_in_concatenation_op4802_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_VERTICAL_BAR_in_concatenation_op4813_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_VERTICAL_BAR_in_concatenation_op4813( FOLLOW_VERTICAL_BAR_in_concatenation_op4813_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_VERTICAL_BAR_in_concatenation_op4815_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_VERTICAL_BAR_in_concatenation_op4815( FOLLOW_VERTICAL_BAR_in_concatenation_op4815_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_multiset_key_in_multiset_op4835_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0200000400000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_multiset_key_in_multiset_op4835( FOLLOW_multiset_key_in_multiset_op4835_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_except_key_in_multiset_op4848_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_except_key_in_multiset_op4848( FOLLOW_except_key_in_multiset_op4848_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_intersect_key_in_multiset_op4852_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_intersect_key_in_multiset_op4852( FOLLOW_intersect_key_in_multiset_op4852_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_union_key_in_multiset_op4856_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_union_key_in_multiset_op4856( FOLLOW_union_key_in_multiset_op4856_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_all_key_in_multiset_op4871_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_all_key_in_multiset_op4871( FOLLOW_all_key_in_multiset_op4871_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_multiset_op4875_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_distinct_key_in_multiset_op4875( FOLLOW_distinct_key_in_multiset_op4875_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_outer_join_sign4898_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000100000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_outer_join_sign4898( FOLLOW_LEFT_PAREN_in_outer_join_sign4898_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PLUS_SIGN_in_outer_join_sign4900_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PLUS_SIGN_in_outer_join_sign4900( FOLLOW_PLUS_SIGN_in_outer_join_sign4900_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_outer_join_sign4902_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_outer_join_sign4902( FOLLOW_RIGHT_PAREN_in_outer_join_sign4902_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_as_key_in_synpred1_OracleDMLCommons338_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_as_key_in_synpred1_OracleDMLCommons338( FOLLOW_as_key_in_synpred1_OracleDMLCommons338_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_synpred1_OracleDMLCommons342_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_synpred1_OracleDMLCommons342( FOLLOW_id_in_synpred1_OracleDMLCommons342_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_alias_quoted_string_in_synpred1_OracleDMLCommons345_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_alias_quoted_string_in_synpred1_OracleDMLCommons345( FOLLOW_alias_quoted_string_in_synpred1_OracleDMLCommons345_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred2_OracleDMLCommons852_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred2_OracleDMLCommons852( FOLLOW_PERIOD_in_synpred2_OracleDMLCommons852_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred2_OracleDMLCommons854_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred2_OracleDMLCommons854( FOLLOW_id_expression_in_synpred2_OracleDMLCommons854_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred3_OracleDMLCommons1019_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred3_OracleDMLCommons1019( FOLLOW_PERIOD_in_synpred3_OracleDMLCommons1019_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred3_OracleDMLCommons1021_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred3_OracleDMLCommons1021( FOLLOW_id_expression_in_synpred3_OracleDMLCommons1021_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred4_OracleDMLCommons1112_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred4_OracleDMLCommons1112( FOLLOW_PERIOD_in_synpred4_OracleDMLCommons1112_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred4_OracleDMLCommons1114_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred4_OracleDMLCommons1114( FOLLOW_id_expression_in_synpred4_OracleDMLCommons1114_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred5_OracleDMLCommons1215_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred5_OracleDMLCommons1215( FOLLOW_PERIOD_in_synpred5_OracleDMLCommons1215_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred5_OracleDMLCommons1217_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred5_OracleDMLCommons1217( FOLLOW_id_expression_in_synpred5_OracleDMLCommons1217_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred6_OracleDMLCommons1269_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred6_OracleDMLCommons1269( FOLLOW_PERIOD_in_synpred6_OracleDMLCommons1269_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred6_OracleDMLCommons1271_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred6_OracleDMLCommons1271( FOLLOW_id_expression_in_synpred6_OracleDMLCommons1271_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred7_OracleDMLCommons1323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred7_OracleDMLCommons1323( FOLLOW_PERIOD_in_synpred7_OracleDMLCommons1323_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred7_OracleDMLCommons1325_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred7_OracleDMLCommons1325( FOLLOW_id_expression_in_synpred7_OracleDMLCommons1325_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred8_OracleDMLCommons1379_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred8_OracleDMLCommons1379( FOLLOW_PERIOD_in_synpred8_OracleDMLCommons1379_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred8_OracleDMLCommons1381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred8_OracleDMLCommons1381( FOLLOW_id_expression_in_synpred8_OracleDMLCommons1381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred9_OracleDMLCommons1435_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred9_OracleDMLCommons1435( FOLLOW_PERIOD_in_synpred9_OracleDMLCommons1435_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred9_OracleDMLCommons1437_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred9_OracleDMLCommons1437( FOLLOW_id_expression_in_synpred9_OracleDMLCommons1437_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred10_OracleDMLCommons1491_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred10_OracleDMLCommons1491( FOLLOW_PERIOD_in_synpred10_OracleDMLCommons1491_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred10_OracleDMLCommons1493_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred10_OracleDMLCommons1493( FOLLOW_id_expression_in_synpred10_OracleDMLCommons1493_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred11_OracleDMLCommons1565_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred11_OracleDMLCommons1565( FOLLOW_PERIOD_in_synpred11_OracleDMLCommons1565_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred11_OracleDMLCommons1567_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred11_OracleDMLCommons1567( FOLLOW_id_expression_in_synpred11_OracleDMLCommons1567_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred12_OracleDMLCommons1775_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred12_OracleDMLCommons1775( FOLLOW_PERIOD_in_synpred12_OracleDMLCommons1775_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred12_OracleDMLCommons1777_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred12_OracleDMLCommons1777( FOLLOW_id_expression_in_synpred12_OracleDMLCommons1777_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_synpred13_OracleDMLCommons1880_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_synpred13_OracleDMLCommons1880( FOLLOW_id_in_synpred13_OracleDMLCommons1880_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred13_OracleDMLCommons1883_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred13_OracleDMLCommons1883( FOLLOW_PERIOD_in_synpred13_OracleDMLCommons1883_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred13_OracleDMLCommons1885_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred13_OracleDMLCommons1885( FOLLOW_id_expression_in_synpred13_OracleDMLCommons1885_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred13_OracleDMLCommons1888_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred13_OracleDMLCommons1888( FOLLOW_PERIOD_in_synpred13_OracleDMLCommons1888_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred13_OracleDMLCommons1890_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred13_OracleDMLCommons1890( FOLLOW_id_expression_in_synpred13_OracleDMLCommons1890_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_synpred14_OracleDMLCommons1947_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_synpred14_OracleDMLCommons1947( FOLLOW_id_in_synpred14_OracleDMLCommons1947_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred14_OracleDMLCommons1950_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred14_OracleDMLCommons1950( FOLLOW_PERIOD_in_synpred14_OracleDMLCommons1950_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred14_OracleDMLCommons1952_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred14_OracleDMLCommons1952( FOLLOW_id_expression_in_synpred14_OracleDMLCommons1952_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_synpred15_OracleDMLCommons1999_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_synpred15_OracleDMLCommons1999( FOLLOW_id_in_synpred15_OracleDMLCommons1999_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_synpred16_OracleDMLCommons2091_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_synpred16_OracleDMLCommons2091( FOLLOW_id_in_synpred16_OracleDMLCommons2091_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred16_OracleDMLCommons2094_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred16_OracleDMLCommons2094( FOLLOW_PERIOD_in_synpred16_OracleDMLCommons2094_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred17_OracleDMLCommons2214_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred17_OracleDMLCommons2214( FOLLOW_PERIOD_in_synpred17_OracleDMLCommons2214_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred17_OracleDMLCommons2216_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred17_OracleDMLCommons2216( FOLLOW_id_expression_in_synpred17_OracleDMLCommons2216_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_synpred18_OracleDMLCommons2613_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_tableview_name_in_synpred18_OracleDMLCommons2613( FOLLOW_tableview_name_in_synpred18_OracleDMLCommons2613_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred18_OracleDMLCommons2615_bits[]	= { ANTLR_UINT64_LIT(0x0000000000080000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred18_OracleDMLCommons2615( FOLLOW_PERIOD_in_synpred18_OracleDMLCommons2615_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_synpred18_OracleDMLCommons2617_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_ASTERISK_in_synpred18_OracleDMLCommons2617( FOLLOW_ASTERISK_in_synpred18_OracleDMLCommons2617_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_synpred19_OracleDMLCommons2797_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_in_synpred19_OracleDMLCommons2797( FOLLOW_id_in_synpred19_OracleDMLCommons2797_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_synpred19_OracleDMLCommons2800_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_synpred19_OracleDMLCommons2800( FOLLOW_EQUALS_OP_in_synpred19_OracleDMLCommons2800_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_synpred19_OracleDMLCommons2802_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_synpred19_OracleDMLCommons2802( FOLLOW_GREATER_THAN_OP_in_synpred19_OracleDMLCommons2802_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred20_OracleDMLCommons3863_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred20_OracleDMLCommons3863( FOLLOW_PERIOD_in_synpred20_OracleDMLCommons3863_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_synpred20_OracleDMLCommons3865_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_synpred20_OracleDMLCommons3865( FOLLOW_general_element_part_in_synpred20_OracleDMLCommons3865_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred21_OracleDMLCommons3941_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred21_OracleDMLCommons3941( FOLLOW_PERIOD_in_synpred21_OracleDMLCommons3941_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_synpred21_OracleDMLCommons3943_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_synpred21_OracleDMLCommons3943( FOLLOW_general_element_part_in_synpred21_OracleDMLCommons3943_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred22_OracleDMLCommons4035_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred22_OracleDMLCommons4035( FOLLOW_PERIOD_in_synpred22_OracleDMLCommons4035_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML_OracleDMLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred22_OracleDMLCommons4037_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDML_OracleDMLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred22_OracleDMLCommons4037( FOLLOW_id_expression_in_synpred22_OracleDMLCommons4037_bits, 1 );



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    276:10: ( ( id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] )=> id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] ( PERIOD id_expression[T_UNKNOWN,T_USE] )* | ( id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] | ( id[T_COLUMN_NAME,T_USE] )=> id[T_COLUMN_NAME,T_USE] )
 */
static const ANTLR_INT32 dfa29_eot[33] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa29_eof[33] =
    {
	-1, -1, 20, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa29_min[33] =
    {
	113, 113, 68, 68, 113, 113, 113, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 113, 0, 0, 113, 113, -1, -1
    };
static const ANTLR_INT32 dfa29_max[33] =
    {
	381, 381, 512, 512, 381, 381, 381, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 381, 0, 0, 381, 381, -1, -1
    };
static const ANTLR_INT32 dfa29_accept[33] =
    {
	-1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, -1, -1, -1, -1, -1, 1, 2
    };
static const ANTLR_INT32 dfa29_special[33] =
    {
	-1, -1, 1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 2, 0, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa29_T_empty	 =   NULL;

static const ANTLR_INT32 dfa29_T0[] =
    {
	-1
    };

static const ANTLR_INT32 dfa29_T1[] =
    {
	30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 29
    };

static const ANTLR_INT32 dfa29_T2[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa29_T3[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa29_T4[] =
    {
	28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27
    };

static const ANTLR_INT32 dfa29_T5[] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 18, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 11, -1, -1, -1, -1, -1, -1, -1, -1, 17, 25, -1, -1, -1, -1, 16, -1, 
	-1, -1, -1, 24, -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, -1, -1, 13, -1, 
	-1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, 21
    };

static const ANTLR_INT32 dfa29_T6[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa29_transitions[] =
{
    dfa29_T6, dfa29_T3, dfa29_T5, dfa29_T5, dfa29_T2, dfa29_T2, dfa29_T4, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, dfa29_T1, dfa29_T0, dfa29_T0, 
    dfa29_T2, dfa29_T2, NULL, NULL
};


/* Declare tracking structure for Cyclic DFA 29
 */
class OracleDML_OracleDMLCommonsCyclicDFA29 : public CyclicDFA< OracleDML_OracleDMLCommonsImplTraits, OracleDML_OracleDMLCommons >, public OracleDML_OracleDMLCommonsTokens
{
public:
	typedef CyclicDFA< OracleDML_OracleDMLCommonsImplTraits, OracleDML_OracleDMLCommons >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	OracleDML_OracleDMLCommonsCyclicDFA29( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA29_28;

	    		    ANTLR_MARKER index29_28;


	    		    LA29_28 = ctx->LA(1);

	    		     
	    		        index29_28 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (this->msynpred( antlr3::ClassForwarder<synpred13_OracleDMLCommons>() ))  )
	    		    {
	    		        s = 31;
	    		    }

	    		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred14_OracleDMLCommons>() ))  )
	    		    {
	    		        s = 32;
	    		    }

	    			 
	    				ctx->seek(index29_28);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA29_2;

	    		    ANTLR_MARKER index29_2;


	    		    LA29_2 = ctx->LA(1);

	    		     
	    		        index29_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA29_2 == PERIOD)  )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA29_2 == COMMA) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA29_2 == PLSQL_NON_RESERVED_USING) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA29_2 == RIGHT_PAREN) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA29_2 == SQL92_RESERVED_ASC) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA29_2 == SQL92_RESERVED_DESC) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA29_2 == REGULAR_ID) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA29_2 == SQL92_RESERVED_SELECT) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA29_2 == LEFT_PAREN) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( (LA29_2 == SQL92_RESERVED_TO) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA29_2 == SQL92_RESERVED_IN) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA29_2 == SQL92_RESERVED_FOR) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA29_2 == SQL92_RESERVED_AS) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA29_2 == PLSQL_RESERVED_NOWAIT) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA29_2 == EOF_TOKEN || LA29_2 == SEMICOLON) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( (LA29_2 == SQL92_RESERVED_WITH) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( (LA29_2 == SQL92_RESERVED_ORDER) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA29_2 == EQUALS_OP) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 23;
	    		    }

	    		    else if ( (LA29_2 == SQL92_RESERVED_LIKE) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 24;
	    		    }

	    		    else if ( (LA29_2 == SQL92_RESERVED_FROM) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 25;
	    		    }

	    			 
	    				ctx->seek(index29_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA29_27;

	    		    ANTLR_MARKER index29_27;


	    		    LA29_27 = ctx->LA(1);

	    		     
	    		        index29_27 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (this->msynpred( antlr3::ClassForwarder<synpred13_OracleDMLCommons>() ))  )
	    		    {
	    		        s = 31;
	    		    }

	    		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred14_OracleDMLCommons>() ))  )
	    		    {
	    		        s = 32;
	    		    }

	    			 
	    				ctx->seek(index29_27);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA29_3;

	    		    ANTLR_MARKER index29_3;


	    		    LA29_3 = ctx->LA(1);

	    		     
	    		        index29_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA29_3 == PERIOD)  )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA29_3 == COMMA) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA29_3 == PLSQL_NON_RESERVED_USING) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA29_3 == RIGHT_PAREN) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA29_3 == SQL92_RESERVED_ASC) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA29_3 == SQL92_RESERVED_DESC) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA29_3 == REGULAR_ID) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA29_3 == SQL92_RESERVED_SELECT) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA29_3 == LEFT_PAREN) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( (LA29_3 == SQL92_RESERVED_TO) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA29_3 == SQL92_RESERVED_IN) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA29_3 == SQL92_RESERVED_FOR) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA29_3 == SQL92_RESERVED_AS) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA29_3 == PLSQL_RESERVED_NOWAIT) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA29_3 == EOF_TOKEN || LA29_3 == SEMICOLON) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( (LA29_3 == SQL92_RESERVED_WITH) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( (LA29_3 == SQL92_RESERVED_ORDER) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA29_3 == EQUALS_OP) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 23;
	    		    }

	    		    else if ( (LA29_3 == SQL92_RESERVED_LIKE) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 24;
	    		    }

	    		    else if ( (LA29_3 == SQL92_RESERVED_FROM) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDMLCommons>() )) )
	    		    {
	    		        s = 25;
	    		    }

	    			 
	    				ctx->seek(index29_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "276:10: ( ( id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] )=> id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] ( PERIOD id_expression[T_UNKNOWN,T_USE] )* | ( id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] | ( id[T_COLUMN_NAME,T_USE] )=> id[T_COLUMN_NAME,T_USE] )" );
	    ex->set_decisionNum( 29 );
	    ex->set_state(_s);
	    return -1;
	}
};

static OracleDML_OracleDMLCommonsCyclicDFA29  cdfa29(
	    29,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"276:10: ( ( id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] )=> id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] ( PERIOD id_expression[T_UNKNOWN,T_USE] )* | ( id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] | ( id[T_COLUMN_NAME,T_USE] )=> id[T_COLUMN_NAME,T_USE] )",
	    dfa29_eot,	    /* EOT table			    */
	    dfa29_eof,	    /* EOF table			    */
	    dfa29_min,	    /* Minimum tokens for each state    */
	    dfa29_max,	    /* Maximum tokens for each state    */
	    dfa29_accept,	/* Accept table			    */
	    dfa29_special,	/* Special transition states	    */
	    dfa29_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 29
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    289:9: ( ( id[T_SCHEMA_NAME,T_USE] PERIOD )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_TABLE_NAME,T_USE] | id[T_TABLE_NAME,T_USE] )
 */
static const ANTLR_INT32 dfa30_eot[13] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa30_eof[13] =
    {
	-1, -1, 7, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa30_min[13] =
    {
	113, 113, 13, 13, 113, 113, 19, -1, 113, -1, -1, 113, 113
    };
static const ANTLR_INT32 dfa30_max[13] =
    {
	381, 381, 625, 625, 381, 381, 381, -1, 381, -1, -1, 381, 381
    };
static const ANTLR_INT32 dfa30_accept[13] =
    {
	-1, -1, -1, -1, -1, -1, -1, 2, -1, 1, 1, -1, -1
    };
static const ANTLR_INT32 dfa30_special[13] =
    {
	-1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa30_T_empty	 =   NULL;

static const ANTLR_INT32 dfa30_T0[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa30_T1[] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 9
    };

static const ANTLR_INT32 dfa30_T2[] =
    {
	7, -1, -1, -1, -1, -1, 7, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, 
	-1, -1, -1, -1, 7, 7, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, 7, -1, 
	-1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 7, -1, 7, -1, -1, -1, 7, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 7, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 7, 7, -1, 7, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, 7, 7, 
	-1, 7, 7, 7, 7, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, 
	-1, -1, 7, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 7, -1, -1, -1, 7, -1, 7, 7, 7, 7, -1, 7, -1, 7, -1, 7, 
	-1, -1, 7, 7, -1, 7, 7, 7, 7, -1, 7, 7, -1, 7, 7, -1, 7, 7, -1, -1, 7, 
	7, 7, -1, 7, 7, 7, 7, 7, 7, -1, 7, -1, 7, 7, -1, 7, -1, -1, -1, 7, -1, 
	-1, -1, 7, 7, 7, 7, -1, -1, 7, -1, 7, 7, 7, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7
    };

static const ANTLR_INT32 dfa30_T3[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa30_T4[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa30_T5[] =
    {
	12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa30_transitions[] =
{
    dfa30_T4, dfa30_T3, dfa30_T2, dfa30_T2, dfa30_T0, dfa30_T0, dfa30_T1, 
    NULL, dfa30_T5, NULL, NULL, dfa30_T0, dfa30_T0
};


/* Declare tracking structure for Cyclic DFA 30
 */
class OracleDML_OracleDMLCommonsCyclicDFA30 : public CyclicDFA< OracleDML_OracleDMLCommonsImplTraits, OracleDML_OracleDMLCommons >, public OracleDML_OracleDMLCommonsTokens
{
public:
	typedef CyclicDFA< OracleDML_OracleDMLCommonsImplTraits, OracleDML_OracleDMLCommons >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	OracleDML_OracleDMLCommonsCyclicDFA30( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA30_6;

	    		    ANTLR_MARKER index30_6;


	    		    LA30_6 = ctx->LA(1);

	    		     
	    		        index30_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA30_6 == ASTERISK)  )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA30_6 == REGULAR_ID) && (this->msynpred( antlr3::ClassForwarder<synpred16_OracleDMLCommons>() )) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA30_6 == DELIMITED_ID) && (this->msynpred( antlr3::ClassForwarder<synpred16_OracleDMLCommons>() )) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index30_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "289:9: ( ( id[T_SCHEMA_NAME,T_USE] PERIOD )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_TABLE_NAME,T_USE] | id[T_TABLE_NAME,T_USE] )" );
	    ex->set_decisionNum( 30 );
	    ex->set_state(_s);
	    return -1;
	}
};

static OracleDML_OracleDMLCommonsCyclicDFA30  cdfa30(
	    30,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"289:9: ( ( id[T_SCHEMA_NAME,T_USE] PERIOD )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_TABLE_NAME,T_USE] | id[T_TABLE_NAME,T_USE] )",
	    dfa30_eot,	    /* EOT table			    */
	    dfa30_eof,	    /* EOF table			    */
	    dfa30_min,	    /* Minimum tokens for each state    */
	    dfa30_max,	    /* Maximum tokens for each state    */
	    dfa30_accept,	/* Accept table			    */
	    dfa30_special,	/* Special transition states	    */
	    dfa30_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 30
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    353:10: ( ( id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )=> id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )?
 */
static const ANTLR_INT32 dfa53_eot[27] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa53_eof[27] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa53_min[27] =
    {
	13, 113, 13, 19, -1, 113, 113, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 13, 113, 19, 19, -1, 113, 113
    };
static const ANTLR_INT32 dfa53_max[27] =
    {
	612, 381, 625, 625, -1, 381, 381, 612, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 612, 381, 625, 625, -1, 381, 381
    };
static const ANTLR_INT32 dfa53_accept[27] =
    {
	-1, -1, -1, -1, 2, -1, -1, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, -1, 
	-1, -1, -1, 1, -1, -1
    };
static const ANTLR_INT32 dfa53_special[27] =
    {
	-1, -1, 2, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa53_T_empty	 =   NULL;

static const ANTLR_INT32 dfa53_T0[] =
    {
	23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22
    };

static const ANTLR_INT32 dfa53_T1[] =
    {
	26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25
    };

static const ANTLR_INT32 dfa53_T2[] =
    {
	19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, 
	-1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 20, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 19, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 19, 19, -1, 19, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, 19, -1, -1, 
	-1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, 19, 19, 19, 
	-1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19
    };

static const ANTLR_INT32 dfa53_T3[] =
    {
	19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, 
	-1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 20, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 19, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 19, 19, -1, 19, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, 19, -1, -1, 
	-1, -1, 19, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, 19, 19, 19, 
	-1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19
    };

static const ANTLR_INT32 dfa53_T4[] =
    {
	19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 19, 19, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 19, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 19, -1, -1, 19, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, 19, -1, 
	19, -1, -1, 19, -1, -1, -1, -1, 19, 19, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 19
    };

static const ANTLR_INT32 dfa53_T5[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, 
	-1, 4, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, 4, 4, -1, 4, -1, -1, 4, -1, 
	-1, -1, -1, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 
	4, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa53_T6[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5
    };

static const ANTLR_INT32 dfa53_T7[] =
    {
	16, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, 
	-1, -1, -1, -1, -1, -1, 17, 17, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, 
	-1, 19, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, 16, -1, -1, -1, 19, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 19, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, 19, -1, 19, 19, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, 
	-1, -1, -1, -1, -1, 13, 8, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, 
	-1, 10, -1, 19, 13, -1, -1, -1, 19, -1, 12, -1, -1, -1, -1, -1, 16, -1, 
	18, -1, -1, 10, -1, -1, -1, -1, 13, 18, -1, -1, -1, -1, -1, -1, -1, 19, 
	-1, -1, -1, 19, 19, 19, 18, -1, -1, -1, 19, -1, -1, 8, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	19
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa53_transitions[] =
{
    dfa53_T5, dfa53_T6, dfa53_T7, dfa53_T3, NULL, dfa53_T0, dfa53_T0, dfa53_T4, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    dfa53_T4, dfa53_T1, dfa53_T2, dfa53_T2, NULL, dfa53_T0, dfa53_T0
};


/* Declare tracking structure for Cyclic DFA 53
 */
class OracleDML_OracleDMLCommonsCyclicDFA53 : public CyclicDFA< OracleDML_OracleDMLCommonsImplTraits, OracleDML_OracleDMLCommons >, public OracleDML_OracleDMLCommonsTokens
{
public:
	typedef CyclicDFA< OracleDML_OracleDMLCommonsImplTraits, OracleDML_OracleDMLCommons >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	OracleDML_OracleDMLCommonsCyclicDFA53( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA53_7;

	    		    ANTLR_MARKER index53_7;


	    		    LA53_7 = ctx->LA(1);

	    		     
	    		        index53_7 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA53_7 == GREATER_THAN_OP) && (this->msynpred( antlr3::ClassForwarder<synpred19_OracleDMLCommons>() )) )
	    		    {
	    		        s = 24;
	    		    }

	    		    else if ( (LA53_7 == APPROXIMATE_NUM_LIT || LA53_7 == BINDVAR || ((LA53_7 >= CHAR_STRING) && (LA53_7 <= CHAR_STRING_PERL)) || LA53_7 == COLON || LA53_7 == DELIMITED_ID || LA53_7 == EXACT_NUM_LIT || LA53_7 == INTRODUCER || LA53_7 == LEFT_PAREN || LA53_7 == MINUS_SIGN || LA53_7 == NATIONAL_CHAR_STRING_LIT || ((LA53_7 >= PLSQL_NON_RESERVED_CAST) && (LA53_7 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA53_7 == PLUS_SIGN || LA53_7 == REGULAR_ID || LA53_7 == SQL92_RESERVED_ALL || LA53_7 == SQL92_RESERVED_ANY || LA53_7 == SQL92_RESERVED_CASE || LA53_7 == SQL92_RESERVED_DATE || LA53_7 == SQL92_RESERVED_DEFAULT || LA53_7 == SQL92_RESERVED_DISTINCT || ((LA53_7 >= SQL92_RESERVED_EXISTS) && (LA53_7 <= SQL92_RESERVED_FALSE)) || LA53_7 == SQL92_RESERVED_NULL || LA53_7 == SQL92_RESERVED_PRIOR || LA53_7 == SQL92_RESERVED_TRUE || LA53_7 == UNSIGNED_INTEGER)  )
	    		    {
	    		        s = 19;
	    		    }

	    			 
	    				ctx->seek(index53_7);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA53_20;

	    		    ANTLR_MARKER index53_20;


	    		    LA53_20 = ctx->LA(1);

	    		     
	    		        index53_20 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA53_20 == GREATER_THAN_OP) && (this->msynpred( antlr3::ClassForwarder<synpred19_OracleDMLCommons>() )) )
	    		    {
	    		        s = 24;
	    		    }

	    		    else if ( (LA53_20 == APPROXIMATE_NUM_LIT || LA53_20 == BINDVAR || ((LA53_20 >= CHAR_STRING) && (LA53_20 <= CHAR_STRING_PERL)) || LA53_20 == COLON || LA53_20 == DELIMITED_ID || LA53_20 == EXACT_NUM_LIT || LA53_20 == INTRODUCER || LA53_20 == LEFT_PAREN || LA53_20 == MINUS_SIGN || LA53_20 == NATIONAL_CHAR_STRING_LIT || ((LA53_20 >= PLSQL_NON_RESERVED_CAST) && (LA53_20 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA53_20 == PLUS_SIGN || LA53_20 == REGULAR_ID || LA53_20 == SQL92_RESERVED_ALL || LA53_20 == SQL92_RESERVED_ANY || LA53_20 == SQL92_RESERVED_CASE || LA53_20 == SQL92_RESERVED_DATE || LA53_20 == SQL92_RESERVED_DEFAULT || LA53_20 == SQL92_RESERVED_DISTINCT || ((LA53_20 >= SQL92_RESERVED_EXISTS) && (LA53_20 <= SQL92_RESERVED_FALSE)) || LA53_20 == SQL92_RESERVED_NULL || LA53_20 == SQL92_RESERVED_PRIOR || LA53_20 == SQL92_RESERVED_TRUE || LA53_20 == UNSIGNED_INTEGER)  )
	    		    {
	    		        s = 19;
	    		    }

	    			 
	    				ctx->seek(index53_20);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA53_2;

	    		    ANTLR_MARKER index53_2;


	    		    LA53_2 = ctx->LA(1);

	    		     
	    		        index53_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA53_2 == EQUALS_OP)  )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA53_2 == MINUS_SIGN || LA53_2 == PLUS_SIGN)  )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA53_2 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA53_2 == SQL92_RESERVED_PRIOR) && (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA53_2 == REGULAR_ID)  )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA53_2 == SQL92_RESERVED_ALL || LA53_2 == SQL92_RESERVED_DISTINCT) && (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA53_2 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "INTERVAL"))||(( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA53_2 == SQL92_RESERVED_CASE)  )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA53_2 == PLSQL_NON_RESERVED_CAST || LA53_2 == SQL92_RESERVED_ANY || LA53_2 == SQL92_RESERVED_EXISTS) && (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA53_2 == INTRODUCER) && ((((toUpper(LT(1)->getText()) == "INTERVAL"))||(( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))) )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( (LA53_2 == BINDVAR || LA53_2 == COLON)  )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA53_2 == APPROXIMATE_NUM_LIT || LA53_2 == EXACT_NUM_LIT || LA53_2 == SQL92_RESERVED_DATE || LA53_2 == UNSIGNED_INTEGER) && (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (((LA53_2 >= CHAR_STRING) && (LA53_2 <= CHAR_STRING_PERL)) || LA53_2 == NATIONAL_CHAR_STRING_LIT)  )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA53_2 == SQL92_RESERVED_DEFAULT || LA53_2 == SQL92_RESERVED_FALSE || LA53_2 == SQL92_RESERVED_NULL || LA53_2 == SQL92_RESERVED_TRUE) && (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA53_2 == ASTERISK || LA53_2 == CARRET_OPERATOR_PART || LA53_2 == COMMA || LA53_2 == CONCATENATION_OP || LA53_2 == EXCLAMATION_OPERATOR_PART || ((LA53_2 >= GREATER_THAN_OP) && (LA53_2 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA53_2 >= LEFT_BRACKET) && (LA53_2 <= LEFT_PAREN)) || ((LA53_2 >= LESS_THAN_OP) && (LA53_2 <= LESS_THAN_OR_EQUALS_OP)) || LA53_2 == NOT_EQUAL_OP || LA53_2 == PERIOD || LA53_2 == PLSQL_NON_RESERVED_MULTISET || LA53_2 == RIGHT_PAREN || LA53_2 == SOLIDUS || LA53_2 == SQL92_RESERVED_AND || LA53_2 == SQL92_RESERVED_BETWEEN || LA53_2 == SQL92_RESERVED_IN || ((LA53_2 >= SQL92_RESERVED_IS) && (LA53_2 <= SQL92_RESERVED_NOT)) || LA53_2 == SQL92_RESERVED_OR || LA53_2 == VERTICAL_BAR)  )
	    		    {
	    		        s = 19;
	    		    }

	    			 
	    				ctx->seek(index53_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "353:10: ( ( id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )=> id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )?" );
	    ex->set_decisionNum( 53 );
	    ex->set_state(_s);
	    return -1;
	}
};

static OracleDML_OracleDMLCommonsCyclicDFA53  cdfa53(
	    53,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"353:10: ( ( id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )=> id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )?",
	    dfa53_eot,	    /* EOT table			    */
	    dfa53_eof,	    /* EOF table			    */
	    dfa53_min,	    /* Minimum tokens for each state    */
	    dfa53_max,	    /* Maximum tokens for each state    */
	    dfa53_accept,	/* Accept table			    */
	    dfa53_special,	/* Special transition states	    */
	    dfa53_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 53
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start partition_extension_clause
 * OracleDMLCommons.g:83:1: partition_extension_clause : ( subpartition_key ^| partition_key ^) ( for_key !)? expression_list ;
 */
OracleDML_OracleDMLCommons::partition_extension_clause_return
OracleDML_OracleDMLCommons::partition_extension_clause()
{
    OracleDML_OracleDMLCommons::partition_extension_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::subpartition_key_return subpartition_key1;
    ImplTraits::TreeTypePtr::pointer subpartition_key1_last = NULL;
    OracleDML_OracleDMLKeys::partition_key_return partition_key2;
    ImplTraits::TreeTypePtr::pointer partition_key2_last = NULL;
    OracleDML_OracleDMLKeys::for_key_return for_key3;
    ImplTraits::TreeTypePtr::pointer for_key3_last = NULL;
    OracleDML::expression_list_return expression_list4;
    ImplTraits::TreeTypePtr::pointer expression_list4_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:84:5: ( ( subpartition_key ^| partition_key ^) ( for_key !)? expression_list )
        // OracleDMLCommons.g:84:10: ( subpartition_key ^| partition_key ^) ( for_key !)? expression_list
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            // OracleDMLCommons.g:84:10: ( subpartition_key ^| partition_key ^)
            {
                ANTLR_UINT32 alt1=2;
                {
                    ANTLR_UINT32 LA1_0 = this->LA(1);
                    if ( (LA1_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "PARTITION"))||((toUpper(LT(1)->getText()) == "SUBPARTITION")))))
                    {
                        {
                            ANTLR_UINT32 LA1_1 = this->LA(2);
                            if ( ((toUpper(LT(1)->getText()) == "SUBPARTITION")))
                            {
                                alt1=1;
                            }
                            else if ( ((toUpper(LT(1)->getText()) == "PARTITION")))
                            {
                                alt1=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return retval;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 1 );
                                ex->set_state( 1 );


                                goto rulepartition_extension_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 1 );
                        ex->set_state( 0 );


                        goto rulepartition_extension_clauseEx;

                    }
                }
                switch (alt1)
                {
            	case 1:
            	    // OracleDMLCommons.g:84:12: subpartition_key ^
            	    {
            	        this->followPush(FOLLOW_subpartition_key_in_partition_extension_clause286);
            	        subpartition_key1=m_gOracleDML->subpartition_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_extension_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(subpartition_key1.tree, root_0);

            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:84:32: partition_key ^
            	    {
            	        this->followPush(FOLLOW_partition_key_in_partition_extension_clause291);
            	        partition_key2=m_gOracleDML->partition_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_extension_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(partition_key2.tree, root_0);

            	    }
            	    break;

                }
            }

            // OracleDMLCommons.g:85:16: ( for_key !)?
            {
                ANTLR_UINT32 alt2=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_FOR:
                    	{
                    		alt2=1;
                    	}
                        break;
                }

                switch (alt2)
                {
            	case 1:
            	    // OracleDMLCommons.g:85:16: for_key !
            	    {
            	        this->followPush(FOLLOW_for_key_in_partition_extension_clause305);
            	        for_key3=m_gOracleDML->for_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_extension_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_list_in_partition_extension_clause309);
            expression_list4=m_gOracleDML->expression_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepartition_extension_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_list4.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepartition_extension_clauseEx; /* Prevent compiler warnings */
    rulepartition_extension_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end partition_extension_clause */

/**
 * $ANTLR start column_alias
 * OracleDMLCommons.g:88:1: column_alias options {backtrack=true; } : ( ( as_key )? ( id[T_COLUMN_ALIAS,T_DECL] | alias_quoted_string[T_COLUMN_ALIAS,T_DECL] ) -> ^( ALIAS ( id )? ( alias_quoted_string )? ) | as_key );
 */
OracleDML_OracleDMLCommons::column_alias_return
OracleDML_OracleDMLCommons::column_alias()
{
    OracleDML_OracleDMLCommons::column_alias_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::as_key_return as_key5;
    ImplTraits::TreeTypePtr::pointer as_key5_last = NULL;
    OracleDML_OracleDMLCommons::id_return id6;
    ImplTraits::TreeTypePtr::pointer id6_last = NULL;
    OracleDML_OracleDMLCommons::alias_quoted_string_return alias_quoted_string7;
    ImplTraits::TreeTypePtr::pointer alias_quoted_string7_last = NULL;
    OracleDML_OracleDMLKeys::as_key_return as_key8;
    ImplTraits::TreeTypePtr::pointer as_key8_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_as_key(get_psrstate()->get_treeAdaptor(), "rule as_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_alias_quoted_string(get_psrstate()->get_treeAdaptor(), "rule alias_quoted_string");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDMLCommons.g:93:5: ( ( as_key )? ( id[T_COLUMN_ALIAS,T_DECL] | alias_quoted_string[T_COLUMN_ALIAS,T_DECL] ) -> ^( ALIAS ( id )? ( alias_quoted_string )? ) | as_key )

            ANTLR_UINT32 alt5;

            alt5=2;

            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_AS:
            	{
            		{
            		    ANTLR_UINT32 LA5_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred1_OracleDMLCommons>() )))
            		    {
            		        alt5=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt5=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 5 );
            		        ex->set_state( 1 );


            		        goto rulecolumn_aliasEx;

            		    }
            		}
            	}
                break;
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case DELIMITED_ID:
            case INTRODUCER:
            case NATIONAL_CHAR_STRING_LIT:
            case REGULAR_ID:
            	{
            		alt5=1;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 5 );
                ex->set_state( 0 );


                goto rulecolumn_aliasEx;

            }

            switch (alt5)
            {
        	case 1:
        	    // OracleDMLCommons.g:93:10: ( as_key )? ( id[T_COLUMN_ALIAS,T_DECL] | alias_quoted_string[T_COLUMN_ALIAS,T_DECL] )
        	    {
        	        // OracleDMLCommons.g:93:10: ( as_key )?
        	        {
        	            ANTLR_UINT32 alt3=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_AS:
        	                	{
        	                		alt3=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt3)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:93:10: as_key
        	        	    {
        	        	        this->followPush(FOLLOW_as_key_in_column_alias338);
        	        	        as_key5=m_gOracleDML->as_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_aliasEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            as_key5_last = as_key5.tree.get();
        	        	            stream_as_key.add(as_key5.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDMLCommons.g:93:18: ( id[T_COLUMN_ALIAS,T_DECL] | alias_quoted_string[T_COLUMN_ALIAS,T_DECL] )
        	        {
        	            ANTLR_UINT32 alt4=2;
        	            switch ( this->LA(1) )
        	            {
        	            case DELIMITED_ID:
        	            case INTRODUCER:
        	            case REGULAR_ID:
        	            	{
        	            		alt4=1;
        	            	}
        	                break;
        	            case CHAR_STRING:
        	            case CHAR_STRING_PERL:
        	            case NATIONAL_CHAR_STRING_LIT:
        	            	{
        	            		alt4=2;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return retval;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 4 );
        	                ex->set_state( 0 );


        	                goto rulecolumn_aliasEx;

        	            }

        	            switch (alt4)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:93:19: id[T_COLUMN_ALIAS,T_DECL]
        	        	    {
        	        	        this->followPush(FOLLOW_id_in_column_alias342);
        	        	        id6=id(T_COLUMN_ALIAS, T_DECL);

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_aliasEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            id6_last = id6.tree.get();
        	        	            stream_id.add(id6.tree);
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDMLCommons.g:93:45: alias_quoted_string[T_COLUMN_ALIAS,T_DECL]
        	        	    {
        	        	        this->followPush(FOLLOW_alias_quoted_string_in_column_alias345);
        	        	        alias_quoted_string7=alias_quoted_string(T_COLUMN_ALIAS, T_DECL);

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_aliasEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            alias_quoted_string7_last = alias_quoted_string7.tree.get();
        	        	            stream_alias_quoted_string.add(alias_quoted_string7.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // AST REWRITE
        	        // elements: alias_quoted_string, id
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 94:5: -> ^( ALIAS ( id )? ( alias_quoted_string )? )
        	        {
        	        	// OracleDMLCommons.g:94:11: ^( ALIAS ( id )? ( alias_quoted_string )? )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ALIAS, "ALIAS"), root_1);
        	        	// OracleDMLCommons.g:94:19: ( id )?
        	        	if ( stream_id.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
        	        	}
        	        	stream_id.reset();

        	        	// OracleDMLCommons.g:94:23: ( alias_quoted_string )?
        	        	if ( stream_alias_quoted_string.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_alias_quoted_string.nextTree());
        	        	}
        	        	stream_alias_quoted_string.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:95:10: as_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_as_key_in_column_alias377);
        	        as_key8=m_gOracleDML->as_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_aliasEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, as_key8.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulecolumn_aliasEx; /* Prevent compiler warnings */
    rulecolumn_aliasEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end column_alias */

/**
 * $ANTLR start table_alias
 * OracleDMLCommons.g:98:1: table_alias : ( id[T_TABLE_ALIAS,T_DECL] | alias_quoted_string[T_TABLE_ALIAS,T_DECL] ) -> ^( ALIAS ( id )? ( alias_quoted_string )? ) ;
 */
OracleDML_OracleDMLCommons::table_alias_return
OracleDML_OracleDMLCommons::table_alias()
{
    OracleDML_OracleDMLCommons::table_alias_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id9;
    ImplTraits::TreeTypePtr::pointer id9_last = NULL;
    OracleDML_OracleDMLCommons::alias_quoted_string_return alias_quoted_string10;
    ImplTraits::TreeTypePtr::pointer alias_quoted_string10_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_alias_quoted_string(get_psrstate()->get_treeAdaptor(), "rule alias_quoted_string");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:99:5: ( ( id[T_TABLE_ALIAS,T_DECL] | alias_quoted_string[T_TABLE_ALIAS,T_DECL] ) -> ^( ALIAS ( id )? ( alias_quoted_string )? ) )
        // OracleDMLCommons.g:99:10: ( id[T_TABLE_ALIAS,T_DECL] | alias_quoted_string[T_TABLE_ALIAS,T_DECL] )
        {
            // OracleDMLCommons.g:99:10: ( id[T_TABLE_ALIAS,T_DECL] | alias_quoted_string[T_TABLE_ALIAS,T_DECL] )
            {
                ANTLR_UINT32 alt6=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case REGULAR_ID:
                	{
                		alt6=1;
                	}
                    break;
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case NATIONAL_CHAR_STRING_LIT:
                	{
                		alt6=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 6 );
                    ex->set_state( 0 );


                    goto ruletable_aliasEx;

                }

                switch (alt6)
                {
            	case 1:
            	    // OracleDMLCommons.g:99:12: id[T_TABLE_ALIAS,T_DECL]
            	    {
            	        this->followPush(FOLLOW_id_in_table_alias399);
            	        id9=id(T_TABLE_ALIAS, T_DECL);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_aliasEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id9_last = id9.tree.get();
            	            stream_id.add(id9.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:99:39: alias_quoted_string[T_TABLE_ALIAS,T_DECL]
            	    {
            	        this->followPush(FOLLOW_alias_quoted_string_in_table_alias404);
            	        alias_quoted_string10=alias_quoted_string(T_TABLE_ALIAS, T_DECL);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_aliasEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            alias_quoted_string10_last = alias_quoted_string10.tree.get();
            	            stream_alias_quoted_string.add(alias_quoted_string10.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: alias_quoted_string, id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 100:5: -> ^( ALIAS ( id )? ( alias_quoted_string )? )
            {
            	// OracleDMLCommons.g:100:10: ^( ALIAS ( id )? ( alias_quoted_string )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ALIAS, "ALIAS"), root_1);
            	// OracleDMLCommons.g:100:18: ( id )?
            	if ( stream_id.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	}
            	stream_id.reset();

            	// OracleDMLCommons.g:100:22: ( alias_quoted_string )?
            	if ( stream_alias_quoted_string.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_alias_quoted_string.nextTree());
            	}
            	stream_alias_quoted_string.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletable_aliasEx; /* Prevent compiler warnings */
    ruletable_aliasEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end table_alias */

/**
 * $ANTLR start alias_quoted_string
 * OracleDMLCommons.g:103:1: alias_quoted_string[int identifierClass, int usageType] : quoted_string -> ID[$quoted_string.start] ;
 */
OracleDML_OracleDMLCommons::alias_quoted_string_return
OracleDML_OracleDMLCommons::alias_quoted_string(int identifierClass, int usageType)
{
    OracleDML_OracleDMLCommons::alias_quoted_string_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::quoted_string_return quoted_string11;
    ImplTraits::TreeTypePtr::pointer quoted_string11_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_quoted_string(get_psrstate()->get_treeAdaptor(), "rule quoted_string");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:104:5: ( quoted_string -> ID[$quoted_string.start] )
        // OracleDMLCommons.g:104:10: quoted_string
        {
            this->followPush(FOLLOW_quoted_string_in_alias_quoted_string446);
            quoted_string11=quoted_string();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealias_quoted_stringEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                quoted_string11_last = quoted_string11.tree.get();
                stream_quoted_string.add(quoted_string11.tree);
            }

            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 105:9: -> ID[$quoted_string.start]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(ID, (quoted_string11.start)));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulealias_quoted_stringEx; /* Prevent compiler warnings */
    rulealias_quoted_stringEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end alias_quoted_string */

/**
 * $ANTLR start where_clause
 * OracleDMLCommons.g:108:1: where_clause : where_key ^ ( current_of_clause | condition_wrapper ) ;
 */
OracleDML_OracleDMLCommons::where_clause_return
OracleDML_OracleDMLCommons::where_clause()
{
    OracleDML_OracleDMLCommons::where_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::where_key_return where_key12;
    ImplTraits::TreeTypePtr::pointer where_key12_last = NULL;
    OracleDML_OracleDMLCommons::current_of_clause_return current_of_clause13;
    ImplTraits::TreeTypePtr::pointer current_of_clause13_last = NULL;
    OracleDML::condition_wrapper_return condition_wrapper14;
    ImplTraits::TreeTypePtr::pointer condition_wrapper14_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:109:5: ( where_key ^ ( current_of_clause | condition_wrapper ) )
        // OracleDMLCommons.g:109:10: where_key ^ ( current_of_clause | condition_wrapper )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_where_key_in_where_clause479);
            where_key12=m_gOracleDML->where_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulewhere_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(where_key12.tree, root_0);

            // OracleDMLCommons.g:109:21: ( current_of_clause | condition_wrapper )
            {
                ANTLR_UINT32 alt7=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_CURRENT:
                	{
                		alt7=1;
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CAST:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case REGULAR_ID:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt7=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 7 );
                    ex->set_state( 0 );


                    goto rulewhere_clauseEx;

                }

                switch (alt7)
                {
            	case 1:
            	    // OracleDMLCommons.g:109:22: current_of_clause
            	    {
            	        this->followPush(FOLLOW_current_of_clause_in_where_clause483);
            	        current_of_clause13=current_of_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewhere_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, current_of_clause13.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:109:40: condition_wrapper
            	    {
            	        this->followPush(FOLLOW_condition_wrapper_in_where_clause485);
            	        condition_wrapper14=m_gOracleDML->condition_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewhere_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, condition_wrapper14.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulewhere_clauseEx; /* Prevent compiler warnings */
    rulewhere_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end where_clause */

/**
 * $ANTLR start current_of_clause
 * OracleDMLCommons.g:112:1: current_of_clause : current_key ^ of_key ! cursor_name ;
 */
OracleDML_OracleDMLCommons::current_of_clause_return
OracleDML_OracleDMLCommons::current_of_clause()
{
    OracleDML_OracleDMLCommons::current_of_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::current_key_return current_key15;
    ImplTraits::TreeTypePtr::pointer current_key15_last = NULL;
    OracleDML_OracleDMLKeys::of_key_return of_key16;
    ImplTraits::TreeTypePtr::pointer of_key16_last = NULL;
    OracleDML_OracleDMLCommons::cursor_name_return cursor_name17;
    ImplTraits::TreeTypePtr::pointer cursor_name17_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:113:5: ( current_key ^ of_key ! cursor_name )
        // OracleDMLCommons.g:113:10: current_key ^ of_key ! cursor_name
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_current_key_in_current_of_clause506);
            current_key15=m_gOracleDML->current_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecurrent_of_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(current_key15.tree, root_0);

            this->followPush(FOLLOW_of_key_in_current_of_clause509);
            of_key16=m_gOracleDML->of_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecurrent_of_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            this->followPush(FOLLOW_cursor_name_in_current_of_clause512);
            cursor_name17=cursor_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecurrent_of_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, cursor_name17.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecurrent_of_clauseEx; /* Prevent compiler warnings */
    rulecurrent_of_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end current_of_clause */

/**
 * $ANTLR start into_clause
 * OracleDMLCommons.g:116:1: into_clause : ( into_key ^ variable_name ( COMMA ! variable_name )* | bulk_key ^ collect_key ! into_key ! variable_name ( COMMA ! variable_name )* );
 */
OracleDML_OracleDMLCommons::into_clause_return
OracleDML_OracleDMLCommons::into_clause()
{
    OracleDML_OracleDMLCommons::into_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA20 = NULL;
    ImplTraits::CommonTokenType const* COMMA26 = NULL;
    OracleDML_OracleDMLKeys::into_key_return into_key18;
    ImplTraits::TreeTypePtr::pointer into_key18_last = NULL;
    OracleDML_OracleDMLCommons::variable_name_return variable_name19;
    ImplTraits::TreeTypePtr::pointer variable_name19_last = NULL;
    OracleDML_OracleDMLCommons::variable_name_return variable_name21;
    ImplTraits::TreeTypePtr::pointer variable_name21_last = NULL;
    OracleDML_OracleDMLKeys::bulk_key_return bulk_key22;
    ImplTraits::TreeTypePtr::pointer bulk_key22_last = NULL;
    OracleDML_OracleDMLKeys::collect_key_return collect_key23;
    ImplTraits::TreeTypePtr::pointer collect_key23_last = NULL;
    OracleDML_OracleDMLKeys::into_key_return into_key24;
    ImplTraits::TreeTypePtr::pointer into_key24_last = NULL;
    OracleDML_OracleDMLCommons::variable_name_return variable_name25;
    ImplTraits::TreeTypePtr::pointer variable_name25_last = NULL;
    OracleDML_OracleDMLCommons::variable_name_return variable_name27;
    ImplTraits::TreeTypePtr::pointer variable_name27_last = NULL;
    ImplTraits::TreeTypePtr COMMA20_tree;
    ImplTraits::TreeTypePtr COMMA26_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDMLCommons.g:117:5: ( into_key ^ variable_name ( COMMA ! variable_name )* | bulk_key ^ collect_key ! into_key ! variable_name ( COMMA ! variable_name )* )

            ANTLR_UINT32 alt10;

            alt10=2;

            {
                ANTLR_UINT32 LA10_0 = this->LA(1);
                if ( (LA10_0 == SQL92_RESERVED_INTO))
                {
                    alt10=1;
                }
                else if ( (LA10_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "BULK")))
                {
                    alt10=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 10 );
                    ex->set_state( 0 );


                    goto ruleinto_clauseEx;

                }
            }
            switch (alt10)
            {
        	case 1:
        	    // OracleDMLCommons.g:117:10: into_key ^ variable_name ( COMMA ! variable_name )*
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_into_key_in_into_clause532);
        	        into_key18=m_gOracleDML->into_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(into_key18.tree, root_0);

        	        this->followPush(FOLLOW_variable_name_in_into_clause535);
        	        variable_name19=variable_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, variable_name19.tree);


        	        // OracleDMLCommons.g:117:34: ( COMMA ! variable_name )*

        	        for (;;)
        	        {
        	            ANTLR_UINT32 alt8=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt8=1;
        	            	}
        	                break;

        	            }

        	            switch (alt8)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:117:35: COMMA ! variable_name
        	        	    {
        	        	        COMMA20 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_into_clause538);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinto_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_variable_name_in_into_clause541);
        	        	        variable_name21=variable_name();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinto_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, variable_name21.tree);


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop8;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop8: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:118:10: bulk_key ^ collect_key ! into_key ! variable_name ( COMMA ! variable_name )*
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_bulk_key_in_into_clause555);
        	        bulk_key22=m_gOracleDML->bulk_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(bulk_key22.tree, root_0);

        	        this->followPush(FOLLOW_collect_key_in_into_clause558);
        	        collect_key23=m_gOracleDML->collect_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        this->followPush(FOLLOW_into_key_in_into_clause561);
        	        into_key24=m_gOracleDML->into_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        this->followPush(FOLLOW_variable_name_in_into_clause564);
        	        variable_name25=variable_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, variable_name25.tree);


        	        // OracleDMLCommons.g:118:57: ( COMMA ! variable_name )*

        	        for (;;)
        	        {
        	            ANTLR_UINT32 alt9=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt9=1;
        	            	}
        	                break;

        	            }

        	            switch (alt9)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:118:58: COMMA ! variable_name
        	        	    {
        	        	        COMMA26 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_into_clause567);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinto_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_variable_name_in_into_clause570);
        	        	        variable_name27=variable_name();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinto_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, variable_name27.tree);


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop9;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop9: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruleinto_clauseEx; /* Prevent compiler warnings */
    ruleinto_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end into_clause */

/**
 * $ANTLR start xml_column_name
 * OracleDMLCommons.g:125:1: xml_column_name : ( id[T_COLUMN_NAME,T_USE] -> ^( XML_COLUMN_NAME id ) | quoted_string -> ^( XML_COLUMN_NAME ID[$quoted_string.start] ) );
 */
OracleDML_OracleDMLCommons::xml_column_name_return
OracleDML_OracleDMLCommons::xml_column_name()
{
    OracleDML_OracleDMLCommons::xml_column_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id28;
    ImplTraits::TreeTypePtr::pointer id28_last = NULL;
    OracleDML_OracleDMLCommons::quoted_string_return quoted_string29;
    ImplTraits::TreeTypePtr::pointer quoted_string29_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_quoted_string(get_psrstate()->get_treeAdaptor(), "rule quoted_string");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDMLCommons.g:126:5: ( id[T_COLUMN_NAME,T_USE] -> ^( XML_COLUMN_NAME id ) | quoted_string -> ^( XML_COLUMN_NAME ID[$quoted_string.start] ) )

            ANTLR_UINT32 alt11;

            alt11=2;

            switch ( this->LA(1) )
            {
            case DELIMITED_ID:
            case INTRODUCER:
            case REGULAR_ID:
            	{
            		alt11=1;
            	}
                break;
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case NATIONAL_CHAR_STRING_LIT:
            	{
            		alt11=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 11 );
                ex->set_state( 0 );


                goto rulexml_column_nameEx;

            }

            switch (alt11)
            {
        	case 1:
        	    // OracleDMLCommons.g:126:10: id[T_COLUMN_NAME,T_USE]
        	    {
        	        this->followPush(FOLLOW_id_in_xml_column_name597);
        	        id28=id(T_COLUMN_NAME, T_USE);

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexml_column_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            id28_last = id28.tree.get();
        	            stream_id.add(id28.tree);
        	        }

        	        // AST REWRITE
        	        // elements: id
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 126:34: -> ^( XML_COLUMN_NAME id )
        	        {
        	        	// OracleDMLCommons.g:126:37: ^( XML_COLUMN_NAME id )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(XML_COLUMN_NAME, "XML_COLUMN_NAME"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:127:10: quoted_string
        	    {
        	        this->followPush(FOLLOW_quoted_string_in_xml_column_name617);
        	        quoted_string29=quoted_string();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexml_column_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            quoted_string29_last = quoted_string29.tree.get();
        	            stream_quoted_string.add(quoted_string29.tree);
        	        }

        	        // AST REWRITE
        	        // elements: 
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 127:24: -> ^( XML_COLUMN_NAME ID[$quoted_string.start] )
        	        {
        	        	// OracleDMLCommons.g:127:27: ^( XML_COLUMN_NAME ID[$quoted_string.start] )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(XML_COLUMN_NAME, "XML_COLUMN_NAME"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, get_psrstate()->get_treeAdaptor()->create(ID, (quoted_string29.start)));
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulexml_column_nameEx; /* Prevent compiler warnings */
    rulexml_column_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xml_column_name */

/**
 * $ANTLR start cost_class_name
 * OracleDMLCommons.g:130:1: cost_class_name : id[T_UNKNOWN,T_USE] -> ^( COST_CLASS_NAME id ) ;
 */
OracleDML_OracleDMLCommons::cost_class_name_return
OracleDML_OracleDMLCommons::cost_class_name()
{
    OracleDML_OracleDMLCommons::cost_class_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id30;
    ImplTraits::TreeTypePtr::pointer id30_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:131:5: ( id[T_UNKNOWN,T_USE] -> ^( COST_CLASS_NAME id ) )
        // OracleDMLCommons.g:131:10: id[T_UNKNOWN,T_USE]
        {
            this->followPush(FOLLOW_id_in_cost_class_name646);
            id30=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto rulecost_class_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id30_last = id30.tree.get();
                stream_id.add(id30.tree);
            }

            // AST REWRITE
            // elements: id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 132:9: -> ^( COST_CLASS_NAME id )
            {
            	// OracleDMLCommons.g:132:12: ^( COST_CLASS_NAME id )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(COST_CLASS_NAME, "COST_CLASS_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecost_class_nameEx; /* Prevent compiler warnings */
    rulecost_class_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cost_class_name */

/**
 * $ANTLR start attribute_name
 * OracleDMLCommons.g:135:1: attribute_name : id[T_UNKNOWN,T_USE] -> ^( ATTRIBUTE_NAME id ) ;
 */
OracleDML_OracleDMLCommons::attribute_name_return
OracleDML_OracleDMLCommons::attribute_name()
{
    OracleDML_OracleDMLCommons::attribute_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id31;
    ImplTraits::TreeTypePtr::pointer id31_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:136:5: ( id[T_UNKNOWN,T_USE] -> ^( ATTRIBUTE_NAME id ) )
        // OracleDMLCommons.g:136:10: id[T_UNKNOWN,T_USE]
        {
            this->followPush(FOLLOW_id_in_attribute_name683);
            id31=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto ruleattribute_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id31_last = id31.tree.get();
                stream_id.add(id31.tree);
            }

            // AST REWRITE
            // elements: id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 137:9: -> ^( ATTRIBUTE_NAME id )
            {
            	// OracleDMLCommons.g:137:12: ^( ATTRIBUTE_NAME id )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ATTRIBUTE_NAME, "ATTRIBUTE_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleattribute_nameEx; /* Prevent compiler warnings */
    ruleattribute_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end attribute_name */

/**
 * $ANTLR start savepoint_name
 * OracleDMLCommons.g:140:1: savepoint_name : id[T_UNKNOWN,T_USE] -> ^( SAVEPOINT_NAME id ) ;
 */
OracleDML_OracleDMLCommons::savepoint_name_return
OracleDML_OracleDMLCommons::savepoint_name()
{
    OracleDML_OracleDMLCommons::savepoint_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id32;
    ImplTraits::TreeTypePtr::pointer id32_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:141:5: ( id[T_UNKNOWN,T_USE] -> ^( SAVEPOINT_NAME id ) )
        // OracleDMLCommons.g:141:10: id[T_UNKNOWN,T_USE]
        {
            this->followPush(FOLLOW_id_in_savepoint_name720);
            id32=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto rulesavepoint_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id32_last = id32.tree.get();
                stream_id.add(id32.tree);
            }

            // AST REWRITE
            // elements: id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 142:9: -> ^( SAVEPOINT_NAME id )
            {
            	// OracleDMLCommons.g:142:12: ^( SAVEPOINT_NAME id )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(SAVEPOINT_NAME, "SAVEPOINT_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesavepoint_nameEx; /* Prevent compiler warnings */
    rulesavepoint_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end savepoint_name */

/**
 * $ANTLR start rollback_segment_name
 * OracleDMLCommons.g:145:1: rollback_segment_name : id[T_UNKNOWN,T_USE] -> ^( ROLLBACK_SEGMENT_NAME id ) ;
 */
OracleDML_OracleDMLCommons::rollback_segment_name_return
OracleDML_OracleDMLCommons::rollback_segment_name()
{
    OracleDML_OracleDMLCommons::rollback_segment_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id33;
    ImplTraits::TreeTypePtr::pointer id33_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:146:5: ( id[T_UNKNOWN,T_USE] -> ^( ROLLBACK_SEGMENT_NAME id ) )
        // OracleDMLCommons.g:146:10: id[T_UNKNOWN,T_USE]
        {
            this->followPush(FOLLOW_id_in_rollback_segment_name757);
            id33=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto rulerollback_segment_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id33_last = id33.tree.get();
                stream_id.add(id33.tree);
            }

            // AST REWRITE
            // elements: id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 147:9: -> ^( ROLLBACK_SEGMENT_NAME id )
            {
            	// OracleDMLCommons.g:147:12: ^( ROLLBACK_SEGMENT_NAME id )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ROLLBACK_SEGMENT_NAME, "ROLLBACK_SEGMENT_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerollback_segment_nameEx; /* Prevent compiler warnings */
    rulerollback_segment_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end rollback_segment_name */

/**
 * $ANTLR start package_name
 * OracleDMLCommons.g:166:1: package_name : id[T_PACKAGE_NAME,T_USE] -> ^( PACKAGE_NAME id ) ;
 */
OracleDML_OracleDMLCommons::package_name_return
OracleDML_OracleDMLCommons::package_name()
{
    OracleDML_OracleDMLCommons::package_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id34;
    ImplTraits::TreeTypePtr::pointer id34_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:167:5: ( id[T_PACKAGE_NAME,T_USE] -> ^( PACKAGE_NAME id ) )
        // OracleDMLCommons.g:167:10: id[T_PACKAGE_NAME,T_USE]
        {
            this->followPush(FOLLOW_id_in_package_name810);
            id34=id(T_PACKAGE_NAME, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto rulepackage_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id34_last = id34.tree.get();
                stream_id.add(id34.tree);
            }

            // AST REWRITE
            // elements: id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 168:9: -> ^( PACKAGE_NAME id )
            {
            	// OracleDMLCommons.g:168:12: ^( PACKAGE_NAME id )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(PACKAGE_NAME, "PACKAGE_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepackage_nameEx; /* Prevent compiler warnings */
    rulepackage_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end package_name */

/**
 * $ANTLR start implementation_type_name
 * OracleDMLCommons.g:171:1: implementation_type_name : id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )? -> ^( IMPLEMENTATION_TYPE_NAME id ( id_expression )? ) ;
 */
OracleDML_OracleDMLCommons::implementation_type_name_return
OracleDML_OracleDMLCommons::implementation_type_name()
{
    OracleDML_OracleDMLCommons::implementation_type_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD36 = NULL;
    OracleDML_OracleDMLCommons::id_return id35;
    ImplTraits::TreeTypePtr::pointer id35_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression37;
    ImplTraits::TreeTypePtr::pointer id_expression37_last = NULL;
    ImplTraits::TreeTypePtr PERIOD36_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:172:5: ( id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )? -> ^( IMPLEMENTATION_TYPE_NAME id ( id_expression )? ) )
        // OracleDMLCommons.g:172:10: id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )?
        {
            this->followPush(FOLLOW_id_in_implementation_type_name847);
            id35=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto ruleimplementation_type_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id35_last = id35.tree.get();
                stream_id.add(id35.tree);
            }

            // OracleDMLCommons.g:172:30: ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )?
            {
                ANTLR_UINT32 alt12=2;
                {
                    ANTLR_UINT32 LA12_0 = this->LA(1);
                    if ( (LA12_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred2_OracleDMLCommons>() )))
                    {
                        alt12=1;
                    }
                }
                switch (alt12)
                {
            	case 1:
            	    // OracleDMLCommons.g:172:31: ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE]
            	    {
            	        PERIOD36 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_implementation_type_name859);
            	        if  (this->hasException())
            	        {
            	            goto ruleimplementation_type_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD36);


            	        this->followPush(FOLLOW_id_expression_in_implementation_type_name861);
            	        id_expression37=id_expression(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleimplementation_type_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression37_last = id_expression37.tree.get();
            	            stream_id_expression.add(id_expression37.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: id_expression, id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 173:9: -> ^( IMPLEMENTATION_TYPE_NAME id ( id_expression )? )
            {
            	// OracleDMLCommons.g:173:12: ^( IMPLEMENTATION_TYPE_NAME id ( id_expression )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IMPLEMENTATION_TYPE_NAME, "IMPLEMENTATION_TYPE_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	// OracleDMLCommons.g:173:42: ( id_expression )?
            	if ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleimplementation_type_nameEx; /* Prevent compiler warnings */
    ruleimplementation_type_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end implementation_type_name */

/**
 * $ANTLR start parameter_name
 * OracleDMLCommons.g:176:1: parameter_name : id[T_UNKNOWN,T_USE] -> ^( PARAMETER_NAME id ) ;
 */
OracleDML_OracleDMLCommons::parameter_name_return
OracleDML_OracleDMLCommons::parameter_name()
{
    OracleDML_OracleDMLCommons::parameter_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id38;
    ImplTraits::TreeTypePtr::pointer id38_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:177:5: ( id[T_UNKNOWN,T_USE] -> ^( PARAMETER_NAME id ) )
        // OracleDMLCommons.g:177:10: id[T_UNKNOWN,T_USE]
        {
            this->followPush(FOLLOW_id_in_parameter_name903);
            id38=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto ruleparameter_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id38_last = id38.tree.get();
                stream_id.add(id38.tree);
            }

            // AST REWRITE
            // elements: id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 178:9: -> ^( PARAMETER_NAME id )
            {
            	// OracleDMLCommons.g:178:12: ^( PARAMETER_NAME id )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(PARAMETER_NAME, "PARAMETER_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleparameter_nameEx; /* Prevent compiler warnings */
    ruleparameter_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end parameter_name */

/**
 * $ANTLR start reference_model_name
 * OracleDMLCommons.g:181:1: reference_model_name : id[T_UNKNOWN,T_USE] -> ^( REFERENCE_MODEL_NAME id ) ;
 */
OracleDML_OracleDMLCommons::reference_model_name_return
OracleDML_OracleDMLCommons::reference_model_name()
{
    OracleDML_OracleDMLCommons::reference_model_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id39;
    ImplTraits::TreeTypePtr::pointer id39_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:182:5: ( id[T_UNKNOWN,T_USE] -> ^( REFERENCE_MODEL_NAME id ) )
        // OracleDMLCommons.g:182:10: id[T_UNKNOWN,T_USE]
        {
            this->followPush(FOLLOW_id_in_reference_model_name940);
            id39=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_model_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id39_last = id39.tree.get();
                stream_id.add(id39.tree);
            }

            // AST REWRITE
            // elements: id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 183:9: -> ^( REFERENCE_MODEL_NAME id )
            {
            	// OracleDMLCommons.g:183:12: ^( REFERENCE_MODEL_NAME id )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(REFERENCE_MODEL_NAME, "REFERENCE_MODEL_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulereference_model_nameEx; /* Prevent compiler warnings */
    rulereference_model_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end reference_model_name */

/**
 * $ANTLR start main_model_name
 * OracleDMLCommons.g:186:1: main_model_name : id[T_UNKNOWN,T_USE] -> ^( MAIN_MODEL_NAME id ) ;
 */
OracleDML_OracleDMLCommons::main_model_name_return
OracleDML_OracleDMLCommons::main_model_name()
{
    OracleDML_OracleDMLCommons::main_model_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id40;
    ImplTraits::TreeTypePtr::pointer id40_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:187:5: ( id[T_UNKNOWN,T_USE] -> ^( MAIN_MODEL_NAME id ) )
        // OracleDMLCommons.g:187:10: id[T_UNKNOWN,T_USE]
        {
            this->followPush(FOLLOW_id_in_main_model_name977);
            id40=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto rulemain_model_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id40_last = id40.tree.get();
                stream_id.add(id40.tree);
            }

            // AST REWRITE
            // elements: id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 188:9: -> ^( MAIN_MODEL_NAME id )
            {
            	// OracleDMLCommons.g:188:12: ^( MAIN_MODEL_NAME id )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(MAIN_MODEL_NAME, "MAIN_MODEL_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemain_model_nameEx; /* Prevent compiler warnings */
    rulemain_model_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end main_model_name */

/**
 * $ANTLR start aggregate_function_name
 * OracleDMLCommons.g:191:1: aggregate_function_name : id[T_FUNCTION_NAME,T_USE] ( ( PERIOD id_expression[T_FUNCTION_NAME,T_USE] )=> PERIOD id_expression[T_FUNCTION_NAME,T_USE] )* -> ^( ROUTINE_NAME id ( id_expression )* ) ;
 */
OracleDML_OracleDMLCommons::aggregate_function_name_return
OracleDML_OracleDMLCommons::aggregate_function_name()
{
    OracleDML_OracleDMLCommons::aggregate_function_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD42 = NULL;
    OracleDML_OracleDMLCommons::id_return id41;
    ImplTraits::TreeTypePtr::pointer id41_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression43;
    ImplTraits::TreeTypePtr::pointer id_expression43_last = NULL;
    ImplTraits::TreeTypePtr PERIOD42_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:192:5: ( id[T_FUNCTION_NAME,T_USE] ( ( PERIOD id_expression[T_FUNCTION_NAME,T_USE] )=> PERIOD id_expression[T_FUNCTION_NAME,T_USE] )* -> ^( ROUTINE_NAME id ( id_expression )* ) )
        // OracleDMLCommons.g:192:10: id[T_FUNCTION_NAME,T_USE] ( ( PERIOD id_expression[T_FUNCTION_NAME,T_USE] )=> PERIOD id_expression[T_FUNCTION_NAME,T_USE] )*
        {
            this->followPush(FOLLOW_id_in_aggregate_function_name1014);
            id41=id(T_FUNCTION_NAME, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto ruleaggregate_function_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id41_last = id41.tree.get();
                stream_id.add(id41.tree);
            }

            // OracleDMLCommons.g:192:36: ( ( PERIOD id_expression[T_FUNCTION_NAME,T_USE] )=> PERIOD id_expression[T_FUNCTION_NAME,T_USE] )*

            for (;;)
            {
                ANTLR_UINT32 alt13=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    ANTLR_UINT32 LA13_0 = this->LA(1);
                    if ( (LA13_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred3_OracleDMLCommons>() )))
                    {
                        alt13=1;
                    }

                }
                switch (alt13)
                {
            	case 1:
            	    // OracleDMLCommons.g:192:37: ( PERIOD id_expression[T_FUNCTION_NAME,T_USE] )=> PERIOD id_expression[T_FUNCTION_NAME,T_USE]
            	    {
            	        PERIOD42 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_aggregate_function_name1026);
            	        if  (this->hasException())
            	        {
            	            goto ruleaggregate_function_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD42);


            	        this->followPush(FOLLOW_id_expression_in_aggregate_function_name1028);
            	        id_expression43=id_expression(T_FUNCTION_NAME, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleaggregate_function_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression43_last = id_expression43.tree.get();
            	            stream_id_expression.add(id_expression43.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop13;	/* break out of the loop */
            	    break;
                }
            }
            loop13: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: id, id_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 193:9: -> ^( ROUTINE_NAME id ( id_expression )* )
            {
            	// OracleDMLCommons.g:193:12: ^( ROUTINE_NAME id ( id_expression )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ROUTINE_NAME, "ROUTINE_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	// OracleDMLCommons.g:193:30: ( id_expression )*
            	while ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleaggregate_function_nameEx; /* Prevent compiler warnings */
    ruleaggregate_function_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end aggregate_function_name */

/**
 * $ANTLR start query_name
 * OracleDMLCommons.g:196:1: query_name : id[T_TABLE_NAME,T_DECL] -> ^( QUERY_NAME id ) ;
 */
OracleDML_OracleDMLCommons::query_name_return
OracleDML_OracleDMLCommons::query_name()
{
    OracleDML_OracleDMLCommons::query_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id44;
    ImplTraits::TreeTypePtr::pointer id44_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:197:5: ( id[T_TABLE_NAME,T_DECL] -> ^( QUERY_NAME id ) )
        // OracleDMLCommons.g:197:10: id[T_TABLE_NAME,T_DECL]
        {
            this->followPush(FOLLOW_id_in_query_name1070);
            id44=id(T_TABLE_NAME, T_DECL);

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id44_last = id44.tree.get();
                stream_id.add(id44.tree);
            }

            // AST REWRITE
            // elements: id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 198:9: -> ^( QUERY_NAME id )
            {
            	// OracleDMLCommons.g:198:12: ^( QUERY_NAME id )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(QUERY_NAME, "QUERY_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulequery_nameEx; /* Prevent compiler warnings */
    rulequery_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end query_name */

/**
 * $ANTLR start constraint_name
 * OracleDMLCommons.g:201:1: constraint_name : id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )* ( AT_SIGN link_name )? -> ^( CONSTRAINT_NAME id ( id_expression )* ( link_name )? ) ;
 */
OracleDML_OracleDMLCommons::constraint_name_return
OracleDML_OracleDMLCommons::constraint_name()
{
    OracleDML_OracleDMLCommons::constraint_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD46 = NULL;
    ImplTraits::CommonTokenType const* AT_SIGN48 = NULL;
    OracleDML_OracleDMLCommons::id_return id45;
    ImplTraits::TreeTypePtr::pointer id45_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression47;
    ImplTraits::TreeTypePtr::pointer id_expression47_last = NULL;
    OracleDML_OracleDMLCommons::link_name_return link_name49;
    ImplTraits::TreeTypePtr::pointer link_name49_last = NULL;
    ImplTraits::TreeTypePtr PERIOD46_tree;
    ImplTraits::TreeTypePtr AT_SIGN48_tree;
    RewriteRuleTokenStream<ImplTraits> stream_AT_SIGN(get_psrstate()->get_treeAdaptor(), "token AT_SIGN");
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_link_name(get_psrstate()->get_treeAdaptor(), "rule link_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:202:5: ( id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )* ( AT_SIGN link_name )? -> ^( CONSTRAINT_NAME id ( id_expression )* ( link_name )? ) )
        // OracleDMLCommons.g:202:10: id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )* ( AT_SIGN link_name )?
        {
            this->followPush(FOLLOW_id_in_constraint_name1107);
            id45=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstraint_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id45_last = id45.tree.get();
                stream_id.add(id45.tree);
            }

            // OracleDMLCommons.g:202:30: ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )*

            for (;;)
            {
                ANTLR_UINT32 alt14=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    ANTLR_UINT32 LA14_0 = this->LA(1);
                    if ( (LA14_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred4_OracleDMLCommons>() )))
                    {
                        alt14=1;
                    }

                }
                switch (alt14)
                {
            	case 1:
            	    // OracleDMLCommons.g:202:31: ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE]
            	    {
            	        PERIOD46 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_constraint_name1119);
            	        if  (this->hasException())
            	        {
            	            goto ruleconstraint_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD46);


            	        this->followPush(FOLLOW_id_expression_in_constraint_name1121);
            	        id_expression47=id_expression(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstraint_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression47_last = id_expression47.tree.get();
            	            stream_id_expression.add(id_expression47.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop14;	/* break out of the loop */
            	    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */


            // OracleDMLCommons.g:202:113: ( AT_SIGN link_name )?
            {
                ANTLR_UINT32 alt15=2;
                switch ( this->LA(1) )
                {
                    case AT_SIGN:
                    	{
                    		alt15=1;
                    	}
                        break;
                }

                switch (alt15)
                {
            	case 1:
            	    // OracleDMLCommons.g:202:114: AT_SIGN link_name
            	    {
            	        AT_SIGN48 =  this->matchToken(AT_SIGN, &FOLLOW_AT_SIGN_in_constraint_name1127);
            	        if  (this->hasException())
            	        {
            	            goto ruleconstraint_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_AT_SIGN.add(AT_SIGN48);


            	        this->followPush(FOLLOW_link_name_in_constraint_name1129);
            	        link_name49=link_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstraint_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            link_name49_last = link_name49.tree.get();
            	            stream_link_name.add(link_name49.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: id, id_expression, link_name
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 203:9: -> ^( CONSTRAINT_NAME id ( id_expression )* ( link_name )? )
            {
            	// OracleDMLCommons.g:203:12: ^( CONSTRAINT_NAME id ( id_expression )* ( link_name )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(CONSTRAINT_NAME, "CONSTRAINT_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	// OracleDMLCommons.g:203:33: ( id_expression )*
            	while ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	// OracleDMLCommons.g:203:48: ( link_name )?
            	if ( stream_link_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_link_name.nextTree());
            	}
            	stream_link_name.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconstraint_nameEx; /* Prevent compiler warnings */
    ruleconstraint_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end constraint_name */

/**
 * $ANTLR start label_name
 * OracleDMLCommons.g:206:1: label_name : id_expression[T_UNKNOWN,T_USE] -> ^( LABEL_NAME id_expression ) ;
 */
OracleDML_OracleDMLCommons::label_name_return
OracleDML_OracleDMLCommons::label_name()
{
    OracleDML_OracleDMLCommons::label_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_expression_return id_expression50;
    ImplTraits::TreeTypePtr::pointer id_expression50_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:207:5: ( id_expression[T_UNKNOWN,T_USE] -> ^( LABEL_NAME id_expression ) )
        // OracleDMLCommons.g:207:10: id_expression[T_UNKNOWN,T_USE]
        {
            this->followPush(FOLLOW_id_expression_in_label_name1173);
            id_expression50=id_expression(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto rulelabel_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id_expression50_last = id_expression50.tree.get();
                stream_id_expression.add(id_expression50.tree);
            }

            // AST REWRITE
            // elements: id_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 208:9: -> ^( LABEL_NAME id_expression )
            {
            	// OracleDMLCommons.g:208:12: ^( LABEL_NAME id_expression )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(LABEL_NAME, "LABEL_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelabel_nameEx; /* Prevent compiler warnings */
    rulelabel_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end label_name */

/**
 * $ANTLR start type_name
 * OracleDMLCommons.g:211:1: type_name : id_expression[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )* -> ^( TYPE_NAME ( id_expression )+ ) ;
 */
OracleDML_OracleDMLCommons::type_name_return
OracleDML_OracleDMLCommons::type_name()
{
    OracleDML_OracleDMLCommons::type_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD52 = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression51;
    ImplTraits::TreeTypePtr::pointer id_expression51_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression53;
    ImplTraits::TreeTypePtr::pointer id_expression53_last = NULL;
    ImplTraits::TreeTypePtr PERIOD52_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:212:5: ( id_expression[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )* -> ^( TYPE_NAME ( id_expression )+ ) )
        // OracleDMLCommons.g:212:10: id_expression[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )*
        {
            this->followPush(FOLLOW_id_expression_in_type_name1210);
            id_expression51=id_expression(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id_expression51_last = id_expression51.tree.get();
                stream_id_expression.add(id_expression51.tree);
            }

            // OracleDMLCommons.g:212:41: ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )*

            for (;;)
            {
                ANTLR_UINT32 alt16=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    ANTLR_UINT32 LA16_0 = this->LA(1);
                    if ( (LA16_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred5_OracleDMLCommons>() )))
                    {
                        alt16=1;
                    }

                }
                switch (alt16)
                {
            	case 1:
            	    // OracleDMLCommons.g:212:42: ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE]
            	    {
            	        PERIOD52 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_type_name1222);
            	        if  (this->hasException())
            	        {
            	            goto ruletype_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD52);


            	        this->followPush(FOLLOW_id_expression_in_type_name1224);
            	        id_expression53=id_expression(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression53_last = id_expression53.tree.get();
            	            stream_id_expression.add(id_expression53.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop16;	/* break out of the loop */
            	    break;
                }
            }
            loop16: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: id_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 213:9: -> ^( TYPE_NAME ( id_expression )+ )
            {
            	// OracleDMLCommons.g:213:12: ^( TYPE_NAME ( id_expression )+ )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TYPE_NAME, "TYPE_NAME"), root_1);
            	if ( !(stream_id_expression.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "id_expression empty" );
            		goto ruletype_nameEx;
            	}
            	while ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletype_nameEx; /* Prevent compiler warnings */
    ruletype_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end type_name */

/**
 * $ANTLR start sequence_name
 * OracleDMLCommons.g:216:1: sequence_name : id_expression[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )* -> ^( SEQUENCE_NAME ( id_expression )+ ) ;
 */
OracleDML_OracleDMLCommons::sequence_name_return
OracleDML_OracleDMLCommons::sequence_name()
{
    OracleDML_OracleDMLCommons::sequence_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD55 = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression54;
    ImplTraits::TreeTypePtr::pointer id_expression54_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression56;
    ImplTraits::TreeTypePtr::pointer id_expression56_last = NULL;
    ImplTraits::TreeTypePtr PERIOD55_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:217:5: ( id_expression[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )* -> ^( SEQUENCE_NAME ( id_expression )+ ) )
        // OracleDMLCommons.g:217:10: id_expression[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )*
        {
            this->followPush(FOLLOW_id_expression_in_sequence_name1264);
            id_expression54=id_expression(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto rulesequence_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id_expression54_last = id_expression54.tree.get();
                stream_id_expression.add(id_expression54.tree);
            }

            // OracleDMLCommons.g:217:41: ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )*

            for (;;)
            {
                ANTLR_UINT32 alt17=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    ANTLR_UINT32 LA17_0 = this->LA(1);
                    if ( (LA17_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred6_OracleDMLCommons>() )))
                    {
                        alt17=1;
                    }

                }
                switch (alt17)
                {
            	case 1:
            	    // OracleDMLCommons.g:217:42: ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE]
            	    {
            	        PERIOD55 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_sequence_name1276);
            	        if  (this->hasException())
            	        {
            	            goto rulesequence_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD55);


            	        this->followPush(FOLLOW_id_expression_in_sequence_name1278);
            	        id_expression56=id_expression(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesequence_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression56_last = id_expression56.tree.get();
            	            stream_id_expression.add(id_expression56.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop17;	/* break out of the loop */
            	    break;
                }
            }
            loop17: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: id_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 218:9: -> ^( SEQUENCE_NAME ( id_expression )+ )
            {
            	// OracleDMLCommons.g:218:12: ^( SEQUENCE_NAME ( id_expression )+ )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(SEQUENCE_NAME, "SEQUENCE_NAME"), root_1);
            	if ( !(stream_id_expression.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "id_expression empty" );
            		goto rulesequence_nameEx;
            	}
            	while ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesequence_nameEx; /* Prevent compiler warnings */
    rulesequence_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end sequence_name */

/**
 * $ANTLR start exception_name
 * OracleDMLCommons.g:221:1: exception_name : id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )* -> ^( EXCEPTION_NAME id ( id_expression )* ) ;
 */
OracleDML_OracleDMLCommons::exception_name_return
OracleDML_OracleDMLCommons::exception_name()
{
    OracleDML_OracleDMLCommons::exception_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD58 = NULL;
    OracleDML_OracleDMLCommons::id_return id57;
    ImplTraits::TreeTypePtr::pointer id57_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression59;
    ImplTraits::TreeTypePtr::pointer id_expression59_last = NULL;
    ImplTraits::TreeTypePtr PERIOD58_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:222:5: ( id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )* -> ^( EXCEPTION_NAME id ( id_expression )* ) )
        // OracleDMLCommons.g:222:10: id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )*
        {
            this->followPush(FOLLOW_id_in_exception_name1318);
            id57=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexception_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id57_last = id57.tree.get();
                stream_id.add(id57.tree);
            }

            // OracleDMLCommons.g:222:30: ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )*

            for (;;)
            {
                ANTLR_UINT32 alt18=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    ANTLR_UINT32 LA18_0 = this->LA(1);
                    if ( (LA18_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred7_OracleDMLCommons>() )))
                    {
                        alt18=1;
                    }

                }
                switch (alt18)
                {
            	case 1:
            	    // OracleDMLCommons.g:222:31: ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE]
            	    {
            	        PERIOD58 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_exception_name1330);
            	        if  (this->hasException())
            	        {
            	            goto ruleexception_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD58);


            	        this->followPush(FOLLOW_id_expression_in_exception_name1332);
            	        id_expression59=id_expression(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexception_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression59_last = id_expression59.tree.get();
            	            stream_id_expression.add(id_expression59.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop18;	/* break out of the loop */
            	    break;
                }
            }
            loop18: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: id, id_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 223:9: -> ^( EXCEPTION_NAME id ( id_expression )* )
            {
            	// OracleDMLCommons.g:223:11: ^( EXCEPTION_NAME id ( id_expression )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXCEPTION_NAME, "EXCEPTION_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	// OracleDMLCommons.g:223:31: ( id_expression )*
            	while ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexception_nameEx; /* Prevent compiler warnings */
    ruleexception_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end exception_name */

/**
 * $ANTLR start function_name
 * OracleDMLCommons.g:226:1: function_name : id[T_FUNCTION_NAME,T_USE] ( ( PERIOD id_expression[T_FUNCTION_NAME,T_USE] )=> PERIOD id_expression[T_FUNCTION_NAME,T_USE] )? -> ^( FUNCTION_NAME id ( id_expression )* ) ;
 */
OracleDML_OracleDMLCommons::function_name_return
OracleDML_OracleDMLCommons::function_name()
{
    OracleDML_OracleDMLCommons::function_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD61 = NULL;
    OracleDML_OracleDMLCommons::id_return id60;
    ImplTraits::TreeTypePtr::pointer id60_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression62;
    ImplTraits::TreeTypePtr::pointer id_expression62_last = NULL;
    ImplTraits::TreeTypePtr PERIOD61_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:227:5: ( id[T_FUNCTION_NAME,T_USE] ( ( PERIOD id_expression[T_FUNCTION_NAME,T_USE] )=> PERIOD id_expression[T_FUNCTION_NAME,T_USE] )? -> ^( FUNCTION_NAME id ( id_expression )* ) )
        // OracleDMLCommons.g:227:10: id[T_FUNCTION_NAME,T_USE] ( ( PERIOD id_expression[T_FUNCTION_NAME,T_USE] )=> PERIOD id_expression[T_FUNCTION_NAME,T_USE] )?
        {
            this->followPush(FOLLOW_id_in_function_name1374);
            id60=id(T_FUNCTION_NAME, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id60_last = id60.tree.get();
                stream_id.add(id60.tree);
            }

            // OracleDMLCommons.g:227:36: ( ( PERIOD id_expression[T_FUNCTION_NAME,T_USE] )=> PERIOD id_expression[T_FUNCTION_NAME,T_USE] )?
            {
                ANTLR_UINT32 alt19=2;
                {
                    ANTLR_UINT32 LA19_0 = this->LA(1);
                    if ( (LA19_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred8_OracleDMLCommons>() )))
                    {
                        alt19=1;
                    }
                }
                switch (alt19)
                {
            	case 1:
            	    // OracleDMLCommons.g:227:37: ( PERIOD id_expression[T_FUNCTION_NAME,T_USE] )=> PERIOD id_expression[T_FUNCTION_NAME,T_USE]
            	    {
            	        PERIOD61 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_function_name1386);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD61);


            	        this->followPush(FOLLOW_id_expression_in_function_name1388);
            	        id_expression62=id_expression(T_FUNCTION_NAME, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression62_last = id_expression62.tree.get();
            	            stream_id_expression.add(id_expression62.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: id_expression, id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 228:9: -> ^( FUNCTION_NAME id ( id_expression )* )
            {
            	// OracleDMLCommons.g:228:12: ^( FUNCTION_NAME id ( id_expression )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(FUNCTION_NAME, "FUNCTION_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	// OracleDMLCommons.g:228:31: ( id_expression )*
            	while ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefunction_nameEx; /* Prevent compiler warnings */
    rulefunction_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end function_name */

/**
 * $ANTLR start procedure_name
 * OracleDMLCommons.g:231:1: procedure_name : id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )? -> ^( PROCEDURE_NAME id ( id_expression )* ) ;
 */
OracleDML_OracleDMLCommons::procedure_name_return
OracleDML_OracleDMLCommons::procedure_name()
{
    OracleDML_OracleDMLCommons::procedure_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD64 = NULL;
    OracleDML_OracleDMLCommons::id_return id63;
    ImplTraits::TreeTypePtr::pointer id63_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression65;
    ImplTraits::TreeTypePtr::pointer id_expression65_last = NULL;
    ImplTraits::TreeTypePtr PERIOD64_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:232:5: ( id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )? -> ^( PROCEDURE_NAME id ( id_expression )* ) )
        // OracleDMLCommons.g:232:10: id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )?
        {
            this->followPush(FOLLOW_id_in_procedure_name1430);
            id63=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprocedure_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id63_last = id63.tree.get();
                stream_id.add(id63.tree);
            }

            // OracleDMLCommons.g:232:30: ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )?
            {
                ANTLR_UINT32 alt20=2;
                {
                    ANTLR_UINT32 LA20_0 = this->LA(1);
                    if ( (LA20_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred9_OracleDMLCommons>() )))
                    {
                        alt20=1;
                    }
                }
                switch (alt20)
                {
            	case 1:
            	    // OracleDMLCommons.g:232:31: ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE]
            	    {
            	        PERIOD64 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_procedure_name1442);
            	        if  (this->hasException())
            	        {
            	            goto ruleprocedure_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD64);


            	        this->followPush(FOLLOW_id_expression_in_procedure_name1444);
            	        id_expression65=id_expression(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprocedure_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression65_last = id_expression65.tree.get();
            	            stream_id_expression.add(id_expression65.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: id_expression, id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 233:9: -> ^( PROCEDURE_NAME id ( id_expression )* )
            {
            	// OracleDMLCommons.g:233:12: ^( PROCEDURE_NAME id ( id_expression )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(PROCEDURE_NAME, "PROCEDURE_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	// OracleDMLCommons.g:233:32: ( id_expression )*
            	while ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleprocedure_nameEx; /* Prevent compiler warnings */
    ruleprocedure_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end procedure_name */

/**
 * $ANTLR start trigger_name
 * OracleDMLCommons.g:236:1: trigger_name : id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )? -> ^( TRIGGER_NAME id ( id_expression )* ) ;
 */
OracleDML_OracleDMLCommons::trigger_name_return
OracleDML_OracleDMLCommons::trigger_name()
{
    OracleDML_OracleDMLCommons::trigger_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD67 = NULL;
    OracleDML_OracleDMLCommons::id_return id66;
    ImplTraits::TreeTypePtr::pointer id66_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression68;
    ImplTraits::TreeTypePtr::pointer id_expression68_last = NULL;
    ImplTraits::TreeTypePtr PERIOD67_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:237:5: ( id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )? -> ^( TRIGGER_NAME id ( id_expression )* ) )
        // OracleDMLCommons.g:237:10: id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )?
        {
            this->followPush(FOLLOW_id_in_trigger_name1486);
            id66=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto ruletrigger_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id66_last = id66.tree.get();
                stream_id.add(id66.tree);
            }

            // OracleDMLCommons.g:237:30: ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )?
            {
                ANTLR_UINT32 alt21=2;
                {
                    ANTLR_UINT32 LA21_0 = this->LA(1);
                    if ( (LA21_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred10_OracleDMLCommons>() )))
                    {
                        alt21=1;
                    }
                }
                switch (alt21)
                {
            	case 1:
            	    // OracleDMLCommons.g:237:31: ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE]
            	    {
            	        PERIOD67 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_trigger_name1498);
            	        if  (this->hasException())
            	        {
            	            goto ruletrigger_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD67);


            	        this->followPush(FOLLOW_id_expression_in_trigger_name1500);
            	        id_expression68=id_expression(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletrigger_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression68_last = id_expression68.tree.get();
            	            stream_id_expression.add(id_expression68.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: id, id_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 238:9: -> ^( TRIGGER_NAME id ( id_expression )* )
            {
            	// OracleDMLCommons.g:238:11: ^( TRIGGER_NAME id ( id_expression )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TRIGGER_NAME, "TRIGGER_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	// OracleDMLCommons.g:238:29: ( id_expression )*
            	while ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletrigger_nameEx; /* Prevent compiler warnings */
    ruletrigger_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end trigger_name */

/**
 * $ANTLR start variable_name
 * OracleDMLCommons.g:241:1: variable_name : ( ( INTRODUCER char_set_name )? id_expression[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )? -> ^( VARIABLE_NAME ( char_set_name )? ( id_expression )* ) | bind_variable -> ^( HOSTED_VARIABLE_NAME bind_variable ) );
 */
OracleDML_OracleDMLCommons::variable_name_return
OracleDML_OracleDMLCommons::variable_name()
{
    OracleDML_OracleDMLCommons::variable_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* INTRODUCER69 = NULL;
    ImplTraits::CommonTokenType const* PERIOD72 = NULL;
    OracleDML_OracleDMLCommons::char_set_name_return char_set_name70;
    ImplTraits::TreeTypePtr::pointer char_set_name70_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression71;
    ImplTraits::TreeTypePtr::pointer id_expression71_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression73;
    ImplTraits::TreeTypePtr::pointer id_expression73_last = NULL;
    OracleDML_OracleDMLCommons::bind_variable_return bind_variable74;
    ImplTraits::TreeTypePtr::pointer bind_variable74_last = NULL;
    ImplTraits::TreeTypePtr INTRODUCER69_tree;
    ImplTraits::TreeTypePtr PERIOD72_tree;
    RewriteRuleTokenStream<ImplTraits> stream_INTRODUCER(get_psrstate()->get_treeAdaptor(), "token INTRODUCER");
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_bind_variable(get_psrstate()->get_treeAdaptor(), "rule bind_variable");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_char_set_name(get_psrstate()->get_treeAdaptor(), "rule char_set_name");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDMLCommons.g:242:5: ( ( INTRODUCER char_set_name )? id_expression[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )? -> ^( VARIABLE_NAME ( char_set_name )? ( id_expression )* ) | bind_variable -> ^( HOSTED_VARIABLE_NAME bind_variable ) )

            ANTLR_UINT32 alt24;

            alt24=2;

            switch ( this->LA(1) )
            {
            case DELIMITED_ID:
            case INTRODUCER:
            case REGULAR_ID:
            	{
            		alt24=1;
            	}
                break;
            case BINDVAR:
            case COLON:
            	{
            		alt24=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 24 );
                ex->set_state( 0 );


                goto rulevariable_nameEx;

            }

            switch (alt24)
            {
        	case 1:
        	    // OracleDMLCommons.g:242:10: ( INTRODUCER char_set_name )? id_expression[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )?
        	    {
        	        // OracleDMLCommons.g:242:10: ( INTRODUCER char_set_name )?
        	        {
        	            ANTLR_UINT32 alt22=2;
        	            switch ( this->LA(1) )
        	            {
        	                case INTRODUCER:
        	                	{
        	                		alt22=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt22)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:242:11: INTRODUCER char_set_name
        	        	    {
        	        	        INTRODUCER69 =  this->matchToken(INTRODUCER, &FOLLOW_INTRODUCER_in_variable_name1542);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulevariable_nameEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_INTRODUCER.add(INTRODUCER69);


        	        	        this->followPush(FOLLOW_char_set_name_in_variable_name1544);
        	        	        char_set_name70=char_set_name();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulevariable_nameEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            char_set_name70_last = char_set_name70.tree.get();
        	        	            stream_char_set_name.add(char_set_name70.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_id_expression_in_variable_name1560);
        	        id_expression71=id_expression(T_UNKNOWN, T_USE);

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            id_expression71_last = id_expression71.tree.get();
        	            stream_id_expression.add(id_expression71.tree);
        	        }

        	        // OracleDMLCommons.g:243:44: ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )?
        	        {
        	            ANTLR_UINT32 alt23=2;
        	            {
        	                ANTLR_UINT32 LA23_0 = this->LA(1);
        	                if ( (LA23_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred11_OracleDMLCommons>() )))
        	                {
        	                    alt23=1;
        	                }
        	            }
        	            switch (alt23)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:243:45: ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE]
        	        	    {
        	        	        PERIOD72 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_variable_name1572);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulevariable_nameEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD72);


        	        	        this->followPush(FOLLOW_id_expression_in_variable_name1574);
        	        	        id_expression73=id_expression(T_UNKNOWN, T_USE);

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulevariable_nameEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            id_expression73_last = id_expression73.tree.get();
        	        	            stream_id_expression.add(id_expression73.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // AST REWRITE
        	        // elements: id_expression, char_set_name
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 244:9: -> ^( VARIABLE_NAME ( char_set_name )? ( id_expression )* )
        	        {
        	        	// OracleDMLCommons.g:244:12: ^( VARIABLE_NAME ( char_set_name )? ( id_expression )* )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(VARIABLE_NAME, "VARIABLE_NAME"), root_1);
        	        	// OracleDMLCommons.g:244:28: ( char_set_name )?
        	        	if ( stream_char_set_name.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_char_set_name.nextTree());
        	        	}
        	        	stream_char_set_name.reset();

        	        	// OracleDMLCommons.g:244:43: ( id_expression )*
        	        	while ( stream_id_expression.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
        	        	}
        	        	stream_id_expression.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:245:10: bind_variable
        	    {
        	        this->followPush(FOLLOW_bind_variable_in_variable_name1608);
        	        bind_variable74=bind_variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            bind_variable74_last = bind_variable74.tree.get();
        	            stream_bind_variable.add(bind_variable74.tree);
        	        }

        	        // AST REWRITE
        	        // elements: bind_variable
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 246:9: -> ^( HOSTED_VARIABLE_NAME bind_variable )
        	        {
        	        	// OracleDMLCommons.g:246:12: ^( HOSTED_VARIABLE_NAME bind_variable )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(HOSTED_VARIABLE_NAME, "HOSTED_VARIABLE_NAME"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_bind_variable.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulevariable_nameEx; /* Prevent compiler warnings */
    rulevariable_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end variable_name */

/**
 * $ANTLR start index_name
 * OracleDMLCommons.g:249:1: index_name : id[T_UNKNOWN,T_USE] -> ^( INDEX_NAME id ) ;
 */
OracleDML_OracleDMLCommons::index_name_return
OracleDML_OracleDMLCommons::index_name()
{
    OracleDML_OracleDMLCommons::index_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id75;
    ImplTraits::TreeTypePtr::pointer id75_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:250:5: ( id[T_UNKNOWN,T_USE] -> ^( INDEX_NAME id ) )
        // OracleDMLCommons.g:250:10: id[T_UNKNOWN,T_USE]
        {
            this->followPush(FOLLOW_id_in_index_name1644);
            id75=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto ruleindex_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id75_last = id75.tree.get();
                stream_id.add(id75.tree);
            }

            // AST REWRITE
            // elements: id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 251:9: -> ^( INDEX_NAME id )
            {
            	// OracleDMLCommons.g:251:12: ^( INDEX_NAME id )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(INDEX_NAME, "INDEX_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleindex_nameEx; /* Prevent compiler warnings */
    ruleindex_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end index_name */

/**
 * $ANTLR start cursor_name
 * OracleDMLCommons.g:254:1: cursor_name : ( id[T_UNKNOWN,T_USE] | bind_variable ) -> ^( CURSOR_NAME ( id )? ( bind_variable )? ) ;
 */
OracleDML_OracleDMLCommons::cursor_name_return
OracleDML_OracleDMLCommons::cursor_name()
{
    OracleDML_OracleDMLCommons::cursor_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id76;
    ImplTraits::TreeTypePtr::pointer id76_last = NULL;
    OracleDML_OracleDMLCommons::bind_variable_return bind_variable77;
    ImplTraits::TreeTypePtr::pointer bind_variable77_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_bind_variable(get_psrstate()->get_treeAdaptor(), "rule bind_variable");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:255:5: ( ( id[T_UNKNOWN,T_USE] | bind_variable ) -> ^( CURSOR_NAME ( id )? ( bind_variable )? ) )
        // OracleDMLCommons.g:255:10: ( id[T_UNKNOWN,T_USE] | bind_variable )
        {
            // OracleDMLCommons.g:255:10: ( id[T_UNKNOWN,T_USE] | bind_variable )
            {
                ANTLR_UINT32 alt25=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case REGULAR_ID:
                	{
                		alt25=1;
                	}
                    break;
                case BINDVAR:
                case COLON:
                	{
                		alt25=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 25 );
                    ex->set_state( 0 );


                    goto rulecursor_nameEx;

                }

                switch (alt25)
                {
            	case 1:
            	    // OracleDMLCommons.g:255:11: id[T_UNKNOWN,T_USE]
            	    {
            	        this->followPush(FOLLOW_id_in_cursor_name1682);
            	        id76=id(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecursor_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id76_last = id76.tree.get();
            	            stream_id.add(id76.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:255:33: bind_variable
            	    {
            	        this->followPush(FOLLOW_bind_variable_in_cursor_name1687);
            	        bind_variable77=bind_variable();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecursor_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            bind_variable77_last = bind_variable77.tree.get();
            	            stream_bind_variable.add(bind_variable77.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: id, bind_variable
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 256:9: -> ^( CURSOR_NAME ( id )? ( bind_variable )? )
            {
            	// OracleDMLCommons.g:256:12: ^( CURSOR_NAME ( id )? ( bind_variable )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(CURSOR_NAME, "CURSOR_NAME"), root_1);
            	// OracleDMLCommons.g:256:26: ( id )?
            	if ( stream_id.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	}
            	stream_id.reset();

            	// OracleDMLCommons.g:256:30: ( bind_variable )?
            	if ( stream_bind_variable.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_bind_variable.nextTree());
            	}
            	stream_bind_variable.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecursor_nameEx; /* Prevent compiler warnings */
    rulecursor_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cursor_name */

/**
 * $ANTLR start record_name
 * OracleDMLCommons.g:259:1: record_name : ( id[T_UNKNOWN,T_USE] | bind_variable ) -> ^( RECORD_NAME id ) ;
 */
OracleDML_OracleDMLCommons::record_name_return
OracleDML_OracleDMLCommons::record_name()
{
    OracleDML_OracleDMLCommons::record_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id78;
    ImplTraits::TreeTypePtr::pointer id78_last = NULL;
    OracleDML_OracleDMLCommons::bind_variable_return bind_variable79;
    ImplTraits::TreeTypePtr::pointer bind_variable79_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_bind_variable(get_psrstate()->get_treeAdaptor(), "rule bind_variable");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:260:5: ( ( id[T_UNKNOWN,T_USE] | bind_variable ) -> ^( RECORD_NAME id ) )
        // OracleDMLCommons.g:260:10: ( id[T_UNKNOWN,T_USE] | bind_variable )
        {
            // OracleDMLCommons.g:260:10: ( id[T_UNKNOWN,T_USE] | bind_variable )
            {
                ANTLR_UINT32 alt26=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case REGULAR_ID:
                	{
                		alt26=1;
                	}
                    break;
                case BINDVAR:
                case COLON:
                	{
                		alt26=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 26 );
                    ex->set_state( 0 );


                    goto rulerecord_nameEx;

                }

                switch (alt26)
                {
            	case 1:
            	    // OracleDMLCommons.g:260:11: id[T_UNKNOWN,T_USE]
            	    {
            	        this->followPush(FOLLOW_id_in_record_name1729);
            	        id78=id(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerecord_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id78_last = id78.tree.get();
            	            stream_id.add(id78.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:260:33: bind_variable
            	    {
            	        this->followPush(FOLLOW_bind_variable_in_record_name1734);
            	        bind_variable79=bind_variable();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerecord_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            bind_variable79_last = bind_variable79.tree.get();
            	            stream_bind_variable.add(bind_variable79.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 261:9: -> ^( RECORD_NAME id )
            {
            	// OracleDMLCommons.g:261:11: ^( RECORD_NAME id )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(RECORD_NAME, "RECORD_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerecord_nameEx; /* Prevent compiler warnings */
    rulerecord_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end record_name */

/**
 * $ANTLR start collection_name
 * OracleDMLCommons.g:264:1: collection_name : id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )? -> ^( COLLECTION_NAME id ( id_expression )? ) ;
 */
OracleDML_OracleDMLCommons::collection_name_return
OracleDML_OracleDMLCommons::collection_name()
{
    OracleDML_OracleDMLCommons::collection_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD81 = NULL;
    OracleDML_OracleDMLCommons::id_return id80;
    ImplTraits::TreeTypePtr::pointer id80_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression82;
    ImplTraits::TreeTypePtr::pointer id_expression82_last = NULL;
    ImplTraits::TreeTypePtr PERIOD81_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:265:5: ( id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )? -> ^( COLLECTION_NAME id ( id_expression )? ) )
        // OracleDMLCommons.g:265:10: id[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )?
        {
            this->followPush(FOLLOW_id_in_collection_name1770);
            id80=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto rulecollection_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id80_last = id80.tree.get();
                stream_id.add(id80.tree);
            }

            // OracleDMLCommons.g:265:30: ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )?
            {
                ANTLR_UINT32 alt27=2;
                {
                    ANTLR_UINT32 LA27_0 = this->LA(1);
                    if ( (LA27_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred12_OracleDMLCommons>() )))
                    {
                        alt27=1;
                    }
                }
                switch (alt27)
                {
            	case 1:
            	    // OracleDMLCommons.g:265:31: ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE]
            	    {
            	        PERIOD81 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_collection_name1782);
            	        if  (this->hasException())
            	        {
            	            goto rulecollection_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD81);


            	        this->followPush(FOLLOW_id_expression_in_collection_name1784);
            	        id_expression82=id_expression(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecollection_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression82_last = id_expression82.tree.get();
            	            stream_id_expression.add(id_expression82.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: id, id_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 266:9: -> ^( COLLECTION_NAME id ( id_expression )? )
            {
            	// OracleDMLCommons.g:266:11: ^( COLLECTION_NAME id ( id_expression )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(COLLECTION_NAME, "COLLECTION_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	// OracleDMLCommons.g:266:32: ( id_expression )?
            	if ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecollection_nameEx; /* Prevent compiler warnings */
    rulecollection_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end collection_name */

/**
 * $ANTLR start link_name
 * OracleDMLCommons.g:269:1: link_name : id[T_UNKNOWN,T_USE] -> ^( LINK_NAME id ) ;
 */
OracleDML_OracleDMLCommons::link_name_return
OracleDML_OracleDMLCommons::link_name()
{
    OracleDML_OracleDMLCommons::link_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::id_return id83;
    ImplTraits::TreeTypePtr::pointer id83_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:270:5: ( id[T_UNKNOWN,T_USE] -> ^( LINK_NAME id ) )
        // OracleDMLCommons.g:270:10: id[T_UNKNOWN,T_USE]
        {
            this->followPush(FOLLOW_id_in_link_name1825);
            id83=id(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto rulelink_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id83_last = id83.tree.get();
                stream_id.add(id83.tree);
            }

            // AST REWRITE
            // elements: id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 271:9: -> ^( LINK_NAME id )
            {
            	// OracleDMLCommons.g:271:12: ^( LINK_NAME id )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(LINK_NAME, "LINK_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelink_nameEx; /* Prevent compiler warnings */
    rulelink_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end link_name */

/**
 * $ANTLR start column_name
 * OracleDMLCommons.g:274:1: column_name : ( ( id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] )=> id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] ( PERIOD id_expression[T_UNKNOWN,T_USE] )* | ( id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] | ( id[T_COLUMN_NAME,T_USE] )=> id[T_COLUMN_NAME,T_USE] ) -> ^( COLUMN_NAME id ( id_expression )* ) ;
 */
OracleDML_OracleDMLCommons::column_name_return
OracleDML_OracleDMLCommons::column_name()
{
    OracleDML_OracleDMLCommons::column_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD85 = NULL;
    ImplTraits::CommonTokenType const* PERIOD87 = NULL;
    ImplTraits::CommonTokenType const* PERIOD90 = NULL;
    OracleDML_OracleDMLCommons::id_return id84;
    ImplTraits::TreeTypePtr::pointer id84_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression86;
    ImplTraits::TreeTypePtr::pointer id_expression86_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression88;
    ImplTraits::TreeTypePtr::pointer id_expression88_last = NULL;
    OracleDML_OracleDMLCommons::id_return id89;
    ImplTraits::TreeTypePtr::pointer id89_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression91;
    ImplTraits::TreeTypePtr::pointer id_expression91_last = NULL;
    OracleDML_OracleDMLCommons::id_return id92;
    ImplTraits::TreeTypePtr::pointer id92_last = NULL;
    ImplTraits::TreeTypePtr PERIOD85_tree;
    ImplTraits::TreeTypePtr PERIOD87_tree;
    ImplTraits::TreeTypePtr PERIOD90_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:276:5: ( ( ( id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] )=> id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] ( PERIOD id_expression[T_UNKNOWN,T_USE] )* | ( id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] | ( id[T_COLUMN_NAME,T_USE] )=> id[T_COLUMN_NAME,T_USE] ) -> ^( COLUMN_NAME id ( id_expression )* ) )
        // OracleDMLCommons.g:276:10: ( ( id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] )=> id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] ( PERIOD id_expression[T_UNKNOWN,T_USE] )* | ( id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] | ( id[T_COLUMN_NAME,T_USE] )=> id[T_COLUMN_NAME,T_USE] )
        {
            // OracleDMLCommons.g:276:10: ( ( id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] )=> id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] ( PERIOD id_expression[T_UNKNOWN,T_USE] )* | ( id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] | ( id[T_COLUMN_NAME,T_USE] )=> id[T_COLUMN_NAME,T_USE] )
            {
                ANTLR_UINT32 alt29=3;
                alt29 = cdfa29.predict(this, this->get_rec(), this->get_istream(), cdfa29 );
                if  (this->hasException())
                {
                    goto rulecolumn_nameEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                switch (alt29)
                {
            	case 1:
            	    // OracleDMLCommons.g:277:15: ( id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] )=> id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] ( PERIOD id_expression[T_UNKNOWN,T_USE] )*
            	    {
            	        this->followPush(FOLLOW_id_in_column_name1914);
            	        id84=id(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecolumn_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id84_last = id84.tree.get();
            	            stream_id.add(id84.tree);
            	        }

            	        PERIOD85 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_column_name1917);
            	        if  (this->hasException())
            	        {
            	            goto rulecolumn_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD85);


            	        this->followPush(FOLLOW_id_expression_in_column_name1919);
            	        id_expression86=id_expression(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecolumn_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression86_last = id_expression86.tree.get();
            	            stream_id_expression.add(id_expression86.tree);
            	        }

            	        // OracleDMLCommons.g:278:80: ( PERIOD id_expression[T_UNKNOWN,T_USE] )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt28=2;
            	            switch ( this->LA(1) )
            	            {
            	            case PERIOD:
            	            	{
            	            		alt28=1;
            	            	}
            	                break;

            	            }

            	            switch (alt28)
            	            {
            	        	case 1:
            	        	    // OracleDMLCommons.g:278:82: PERIOD id_expression[T_UNKNOWN,T_USE]
            	        	    {
            	        	        PERIOD87 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_column_name1924);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecolumn_nameEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD87);


            	        	        this->followPush(FOLLOW_id_expression_in_column_name1926);
            	        	        id_expression88=id_expression(T_UNKNOWN, T_USE);

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecolumn_nameEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            id_expression88_last = id_expression88.tree.get();
            	        	            stream_id_expression.add(id_expression88.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop28;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop28: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:279:15: ( id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE]
            	    {
            	        this->followPush(FOLLOW_id_in_column_name1976);
            	        id89=id(T_SCHEMA_NAME, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecolumn_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id89_last = id89.tree.get();
            	            stream_id.add(id89.tree);
            	        }

            	        PERIOD90 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_column_name1979);
            	        if  (this->hasException())
            	        {
            	            goto rulecolumn_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD90);


            	        this->followPush(FOLLOW_id_expression_in_column_name1981);
            	        id_expression91=id_expression(T_COLUMN_NAME, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecolumn_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression91_last = id_expression91.tree.get();
            	            stream_id_expression.add(id_expression91.tree);
            	        }

            	    }
            	    break;
            	case 3:
            	    // OracleDMLCommons.g:281:15: ( id[T_COLUMN_NAME,T_USE] )=> id[T_COLUMN_NAME,T_USE]
            	    {
            	        this->followPush(FOLLOW_id_in_column_name2023);
            	        id92=id(T_COLUMN_NAME, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecolumn_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id92_last = id92.tree.get();
            	            stream_id.add(id92.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: id_expression, id
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 284:9: -> ^( COLUMN_NAME id ( id_expression )* )
            {
            	// OracleDMLCommons.g:284:12: ^( COLUMN_NAME id ( id_expression )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(COLUMN_NAME, "COLUMN_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	// OracleDMLCommons.g:284:29: ( id_expression )*
            	while ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecolumn_nameEx; /* Prevent compiler warnings */
    rulecolumn_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end column_name */

/**
 * $ANTLR start tableview_name
 * OracleDMLCommons.g:287:1: tableview_name : ( ( id[T_SCHEMA_NAME,T_USE] PERIOD )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_TABLE_NAME,T_USE] | id[T_TABLE_NAME,T_USE] ) ( AT_SIGN link_name |{...}? => partition_extension_clause )? -> ^( TABLEVIEW_NAME id ( id_expression )? ( link_name )? ( partition_extension_clause )? ) ;
 */
OracleDML_OracleDMLCommons::tableview_name_return
OracleDML_OracleDMLCommons::tableview_name()
{
    OracleDML_OracleDMLCommons::tableview_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD94 = NULL;
    ImplTraits::CommonTokenType const* AT_SIGN97 = NULL;
    OracleDML_OracleDMLCommons::id_return id93;
    ImplTraits::TreeTypePtr::pointer id93_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression95;
    ImplTraits::TreeTypePtr::pointer id_expression95_last = NULL;
    OracleDML_OracleDMLCommons::id_return id96;
    ImplTraits::TreeTypePtr::pointer id96_last = NULL;
    OracleDML_OracleDMLCommons::link_name_return link_name98;
    ImplTraits::TreeTypePtr::pointer link_name98_last = NULL;
    OracleDML_OracleDMLCommons::partition_extension_clause_return partition_extension_clause99;
    ImplTraits::TreeTypePtr::pointer partition_extension_clause99_last = NULL;
    ImplTraits::TreeTypePtr PERIOD94_tree;
    ImplTraits::TreeTypePtr AT_SIGN97_tree;
    RewriteRuleTokenStream<ImplTraits> stream_AT_SIGN(get_psrstate()->get_treeAdaptor(), "token AT_SIGN");
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_partition_extension_clause(get_psrstate()->get_treeAdaptor(), "rule partition_extension_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_link_name(get_psrstate()->get_treeAdaptor(), "rule link_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:289:5: ( ( ( id[T_SCHEMA_NAME,T_USE] PERIOD )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_TABLE_NAME,T_USE] | id[T_TABLE_NAME,T_USE] ) ( AT_SIGN link_name |{...}? => partition_extension_clause )? -> ^( TABLEVIEW_NAME id ( id_expression )? ( link_name )? ( partition_extension_clause )? ) )
        // OracleDMLCommons.g:289:9: ( ( id[T_SCHEMA_NAME,T_USE] PERIOD )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_TABLE_NAME,T_USE] | id[T_TABLE_NAME,T_USE] ) ( AT_SIGN link_name |{...}? => partition_extension_clause )?
        {
            // OracleDMLCommons.g:289:9: ( ( id[T_SCHEMA_NAME,T_USE] PERIOD )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_TABLE_NAME,T_USE] | id[T_TABLE_NAME,T_USE] )
            {
                ANTLR_UINT32 alt30=2;
                alt30 = cdfa30.predict(this, this->get_rec(), this->get_istream(), cdfa30 );
                if  (this->hasException())
                {
                    goto ruletableview_nameEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                switch (alt30)
                {
            	case 1:
            	    // OracleDMLCommons.g:290:13: ( id[T_SCHEMA_NAME,T_USE] PERIOD )=> id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_TABLE_NAME,T_USE]
            	    {
            	        this->followPush(FOLLOW_id_in_tableview_name2099);
            	        id93=id(T_SCHEMA_NAME, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id93_last = id93.tree.get();
            	            stream_id.add(id93.tree);
            	        }

            	        PERIOD94 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_tableview_name2102);
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD94);


            	        this->followPush(FOLLOW_id_expression_in_tableview_name2104);
            	        id_expression95=id_expression(T_TABLE_NAME, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression95_last = id_expression95.tree.get();
            	            stream_id_expression.add(id_expression95.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:291:13: id[T_TABLE_NAME,T_USE]
            	    {
            	        this->followPush(FOLLOW_id_in_tableview_name2119);
            	        id96=id(T_TABLE_NAME, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id96_last = id96.tree.get();
            	            stream_id.add(id96.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDMLCommons.g:293:5: ( AT_SIGN link_name |{...}? => partition_extension_clause )?
            {
                ANTLR_UINT32 alt31=3;
                switch ( this->LA(1) )
                {
                    case AT_SIGN:
                    	{
                    		alt31=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA31_2 = this->LA(2);
                    		    if ( (( ((!(LA(2) == SQL92_RESERVED_BY))) && ((((toUpper(LT(1)->getText()) == "PARTITION"))||((toUpper(LT(1)->getText()) == "SUBPARTITION")))) )))
                    		    {
                    		        alt31=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt31)
                {
            	case 1:
            	    // OracleDMLCommons.g:293:10: AT_SIGN link_name
            	    {
            	        AT_SIGN97 =  this->matchToken(AT_SIGN, &FOLLOW_AT_SIGN_in_tableview_name2141);
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_AT_SIGN.add(AT_SIGN97);


            	        this->followPush(FOLLOW_link_name_in_tableview_name2143);
            	        link_name98=link_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            link_name98_last = link_name98.tree.get();
            	            stream_link_name.add(link_name98.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:294:10: {...}? => partition_extension_clause
            	    {
            	        if ( !((!(LA(2) == SQL92_RESERVED_BY))) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return retval;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "!(LA(2) == SQL92_RESERVED_BY)" );
            	                ex->set_ruleName( "tableview_name" );


            	        }

            	        this->followPush(FOLLOW_partition_extension_clause_in_tableview_name2157);
            	        partition_extension_clause99=partition_extension_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            partition_extension_clause99_last = partition_extension_clause99.tree.get();
            	            stream_partition_extension_clause.add(partition_extension_clause99.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: id_expression, id, link_name, partition_extension_clause
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 296:9: -> ^( TABLEVIEW_NAME id ( id_expression )? ( link_name )? ( partition_extension_clause )? )
            {
            	// OracleDMLCommons.g:296:12: ^( TABLEVIEW_NAME id ( id_expression )? ( link_name )? ( partition_extension_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLEVIEW_NAME, "TABLEVIEW_NAME"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id.nextTree());
            	// OracleDMLCommons.g:296:32: ( id_expression )?
            	if ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	// OracleDMLCommons.g:296:47: ( link_name )?
            	if ( stream_link_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_link_name.nextTree());
            	}
            	stream_link_name.reset();

            	// OracleDMLCommons.g:296:58: ( partition_extension_clause )?
            	if ( stream_partition_extension_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_partition_extension_clause.nextTree());
            	}
            	stream_partition_extension_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletableview_nameEx; /* Prevent compiler warnings */
    ruletableview_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end tableview_name */

/**
 * $ANTLR start char_set_name
 * OracleDMLCommons.g:299:1: char_set_name : id_expression[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )* -> ^( CHAR_SET_NAME ( id_expression )+ ) ;
 */
OracleDML_OracleDMLCommons::char_set_name_return
OracleDML_OracleDMLCommons::char_set_name()
{
    OracleDML_OracleDMLCommons::char_set_name_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD101 = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression100;
    ImplTraits::TreeTypePtr::pointer id_expression100_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression102;
    ImplTraits::TreeTypePtr::pointer id_expression102_last = NULL;
    ImplTraits::TreeTypePtr PERIOD101_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:300:5: ( id_expression[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )* -> ^( CHAR_SET_NAME ( id_expression )+ ) )
        // OracleDMLCommons.g:300:10: id_expression[T_UNKNOWN,T_USE] ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )*
        {
            this->followPush(FOLLOW_id_expression_in_char_set_name2209);
            id_expression100=id_expression(T_UNKNOWN, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto rulechar_set_nameEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id_expression100_last = id_expression100.tree.get();
                stream_id_expression.add(id_expression100.tree);
            }

            // OracleDMLCommons.g:300:41: ( ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE] )*

            for (;;)
            {
                ANTLR_UINT32 alt32=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    ANTLR_UINT32 LA32_0 = this->LA(1);
                    if ( (LA32_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred17_OracleDMLCommons>() )))
                    {
                        alt32=1;
                    }

                }
                switch (alt32)
                {
            	case 1:
            	    // OracleDMLCommons.g:300:42: ( PERIOD id_expression[T_UNKNOWN,T_USE] )=> PERIOD id_expression[T_UNKNOWN,T_USE]
            	    {
            	        PERIOD101 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_char_set_name2221);
            	        if  (this->hasException())
            	        {
            	            goto rulechar_set_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD101);


            	        this->followPush(FOLLOW_id_expression_in_char_set_name2223);
            	        id_expression102=id_expression(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulechar_set_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression102_last = id_expression102.tree.get();
            	            stream_id_expression.add(id_expression102.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop32;	/* break out of the loop */
            	    break;
                }
            }
            loop32: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: id_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 301:9: -> ^( CHAR_SET_NAME ( id_expression )+ )
            {
            	// OracleDMLCommons.g:301:11: ^( CHAR_SET_NAME ( id_expression )+ )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(CHAR_SET_NAME, "CHAR_SET_NAME"), root_1);
            	if ( !(stream_id_expression.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "id_expression empty" );
            		goto rulechar_set_nameEx;
            	}
            	while ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulechar_set_nameEx; /* Prevent compiler warnings */
    rulechar_set_nameEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end char_set_name */

/**
 * $ANTLR start keep_clause
 * OracleDMLCommons.g:309:1: keep_clause : keep_key ^ LEFT_PAREN ! dense_rank_key ( first_key | last_key ) order_by_clause RIGHT_PAREN ! ( over_clause )? ;
 */
OracleDML_OracleDMLCommons::keep_clause_return
OracleDML_OracleDMLCommons::keep_clause()
{
    OracleDML_OracleDMLCommons::keep_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN104 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN109 = NULL;
    OracleDML_OracleDMLKeys::keep_key_return keep_key103;
    ImplTraits::TreeTypePtr::pointer keep_key103_last = NULL;
    OracleDML_OracleDMLKeys::dense_rank_key_return dense_rank_key105;
    ImplTraits::TreeTypePtr::pointer dense_rank_key105_last = NULL;
    OracleDML_OracleDMLKeys::first_key_return first_key106;
    ImplTraits::TreeTypePtr::pointer first_key106_last = NULL;
    OracleDML_OracleDMLKeys::last_key_return last_key107;
    ImplTraits::TreeTypePtr::pointer last_key107_last = NULL;
    OracleDML::order_by_clause_return order_by_clause108;
    ImplTraits::TreeTypePtr::pointer order_by_clause108_last = NULL;
    OracleDML::over_clause_return over_clause110;
    ImplTraits::TreeTypePtr::pointer over_clause110_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN104_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN109_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:310:5: ( keep_key ^ LEFT_PAREN ! dense_rank_key ( first_key | last_key ) order_by_clause RIGHT_PAREN ! ( over_clause )? )
        // OracleDMLCommons.g:310:9: keep_key ^ LEFT_PAREN ! dense_rank_key ( first_key | last_key ) order_by_clause RIGHT_PAREN ! ( over_clause )?
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_keep_key_in_keep_clause2266);
            keep_key103=m_gOracleDML->keep_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(keep_key103.tree, root_0);

            LEFT_PAREN104 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_keep_clause2277);
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            this->followPush(FOLLOW_dense_rank_key_in_keep_clause2292);
            dense_rank_key105=m_gOracleDML->dense_rank_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, dense_rank_key105.tree);


            // OracleDMLCommons.g:312:28: ( first_key | last_key )
            {
                ANTLR_UINT32 alt33=2;
                {
                    ANTLR_UINT32 LA33_0 = this->LA(1);
                    if ( (LA33_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "FIRST"))||((toUpper(LT(1)->getText()) == "LAST")))))
                    {
                        {
                            ANTLR_UINT32 LA33_1 = this->LA(2);
                            if ( ((toUpper(LT(1)->getText()) == "FIRST")))
                            {
                                alt33=1;
                            }
                            else if ( ((toUpper(LT(1)->getText()) == "LAST")))
                            {
                                alt33=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return retval;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 33 );
                                ex->set_state( 1 );


                                goto rulekeep_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 33 );
                        ex->set_state( 0 );


                        goto rulekeep_clauseEx;

                    }
                }
                switch (alt33)
                {
            	case 1:
            	    // OracleDMLCommons.g:312:29: first_key
            	    {
            	        this->followPush(FOLLOW_first_key_in_keep_clause2295);
            	        first_key106=m_gOracleDML->first_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulekeep_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, first_key106.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:312:39: last_key
            	    {
            	        this->followPush(FOLLOW_last_key_in_keep_clause2297);
            	        last_key107=m_gOracleDML->last_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulekeep_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, last_key107.tree);


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_order_by_clause_in_keep_clause2313);
            order_by_clause108=m_gOracleDML->order_by_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, order_by_clause108.tree);


            RIGHT_PAREN109 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_keep_clause2323);
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            // OracleDMLCommons.g:314:22: ( over_clause )?
            {
                ANTLR_UINT32 alt34=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA34_1 = this->LA(2);
                    		    if ( ((toUpper(LT(1)->getText()) == "OVER")))
                    		    {
                    		        alt34=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt34)
                {
            	case 1:
            	    // OracleDMLCommons.g:314:22: over_clause
            	    {
            	        this->followPush(FOLLOW_over_clause_in_keep_clause2326);
            	        over_clause110=m_gOracleDML->over_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulekeep_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, over_clause110.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulekeep_clauseEx; /* Prevent compiler warnings */
    rulekeep_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end keep_clause */

/**
 * $ANTLR start function_argument
 * OracleDMLCommons.g:317:1: function_argument : LEFT_PAREN ( argument )? ( COMMA argument )* RIGHT_PAREN ( keep_clause )? -> ^( ARGUMENTS ( argument )* ( keep_clause )? ) ;
 */
OracleDML_OracleDMLCommons::function_argument_return
OracleDML_OracleDMLCommons::function_argument()
{
    OracleDML_OracleDMLCommons::function_argument_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN111 = NULL;
    ImplTraits::CommonTokenType const* COMMA113 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN115 = NULL;
    OracleDML_OracleDMLCommons::argument_return argument112;
    ImplTraits::TreeTypePtr::pointer argument112_last = NULL;
    OracleDML_OracleDMLCommons::argument_return argument114;
    ImplTraits::TreeTypePtr::pointer argument114_last = NULL;
    OracleDML_OracleDMLCommons::keep_clause_return keep_clause116;
    ImplTraits::TreeTypePtr::pointer keep_clause116_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN111_tree;
    ImplTraits::TreeTypePtr COMMA113_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN115_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_argument(get_psrstate()->get_treeAdaptor(), "rule argument");
    RewriteRuleSubtreeStream<ImplTraits> stream_keep_clause(get_psrstate()->get_treeAdaptor(), "rule keep_clause");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:318:5: ( LEFT_PAREN ( argument )? ( COMMA argument )* RIGHT_PAREN ( keep_clause )? -> ^( ARGUMENTS ( argument )* ( keep_clause )? ) )
        // OracleDMLCommons.g:318:10: LEFT_PAREN ( argument )? ( COMMA argument )* RIGHT_PAREN ( keep_clause )?
        {
            LEFT_PAREN111 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_function_argument2347);
            if  (this->hasException())
            {
                goto rulefunction_argumentEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN111);


            // OracleDMLCommons.g:319:13: ( argument )?
            {
                ANTLR_UINT32 alt35=2;
                switch ( this->LA(1) )
                {
                    case APPROXIMATE_NUM_LIT:
                    case BINDVAR:
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case COLON:
                    case DELIMITED_ID:
                    case EXACT_NUM_LIT:
                    case INTRODUCER:
                    case LEFT_PAREN:
                    case MINUS_SIGN:
                    case NATIONAL_CHAR_STRING_LIT:
                    case PLSQL_NON_RESERVED_CAST:
                    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                    case PLUS_SIGN:
                    case REGULAR_ID:
                    case SQL92_RESERVED_ALL:
                    case SQL92_RESERVED_ANY:
                    case SQL92_RESERVED_CASE:
                    case SQL92_RESERVED_CURSOR:
                    case SQL92_RESERVED_DATE:
                    case SQL92_RESERVED_DEFAULT:
                    case SQL92_RESERVED_DISTINCT:
                    case SQL92_RESERVED_EXISTS:
                    case SQL92_RESERVED_FALSE:
                    case SQL92_RESERVED_NOT:
                    case SQL92_RESERVED_NULL:
                    case SQL92_RESERVED_PRIOR:
                    case SQL92_RESERVED_TRUE:
                    case UNSIGNED_INTEGER:
                    	{
                    		alt35=1;
                    	}
                        break;
                }

                switch (alt35)
                {
            	case 1:
            	    // OracleDMLCommons.g:319:13: argument
            	    {
            	        this->followPush(FOLLOW_argument_in_function_argument2362);
            	        argument112=argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            argument112_last = argument112.tree.get();
            	            stream_argument.add(argument112.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDMLCommons.g:319:23: ( COMMA argument )*

            for (;;)
            {
                ANTLR_UINT32 alt36=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt36=1;
                	}
                    break;

                }

                switch (alt36)
                {
            	case 1:
            	    // OracleDMLCommons.g:319:24: COMMA argument
            	    {
            	        COMMA113 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument2366);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA113);


            	        this->followPush(FOLLOW_argument_in_function_argument2368);
            	        argument114=argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            argument114_last = argument114.tree.get();
            	            stream_argument.add(argument114.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop36;	/* break out of the loop */
            	    break;
                }
            }
            loop36: ; /* Jump out to here if this rule does not match */


            RIGHT_PAREN115 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_function_argument2382);
            if  (this->hasException())
            {
                goto rulefunction_argumentEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN115);


            // OracleDMLCommons.g:321:9: ( keep_clause )?
            {
                ANTLR_UINT32 alt37=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case LEFT_PAREN:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case REGULAR_ID:
                    		    		    	{
                    		    		    		switch ( this->LA(4) )
                    		    		    		{
                    		    		    		    case REGULAR_ID:
                    		    		    		    	{
                    		    		    		    		{
                    		    		    		    		    ANTLR_UINT32 LA37_6 = this->LA(5);
                    		    		    		    		    if ( (LA37_6 == SQL92_RESERVED_ORDER) && ((toUpper(LT(1)->getText()) == "KEEP")))
                    		    		    		    		    {
                    		    		    		    		        alt37=1;
                    		    		    		    		    }
                    		    		    		    		}
                    		    		    		    	}
                    		    		    		        break;
                    		    		    		}

                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt37)
                {
            	case 1:
            	    // OracleDMLCommons.g:321:9: keep_clause
            	    {
            	        this->followPush(FOLLOW_keep_clause_in_function_argument2392);
            	        keep_clause116=keep_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            keep_clause116_last = keep_clause116.tree.get();
            	            stream_keep_clause.add(keep_clause116.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: keep_clause, argument
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 322:9: -> ^( ARGUMENTS ( argument )* ( keep_clause )? )
            {
            	// OracleDMLCommons.g:322:12: ^( ARGUMENTS ( argument )* ( keep_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ARGUMENTS, "ARGUMENTS"), root_1);
            	// OracleDMLCommons.g:322:24: ( argument )*
            	while ( stream_argument.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_argument.nextTree());
            	}
            	stream_argument.reset();

            	// OracleDMLCommons.g:322:34: ( keep_clause )?
            	if ( stream_keep_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_keep_clause.nextTree());
            	}
            	stream_keep_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefunction_argumentEx; /* Prevent compiler warnings */
    rulefunction_argumentEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end function_argument */

/**
 * $ANTLR start function_argument_analytic
 * OracleDMLCommons.g:325:1: function_argument_analytic : LEFT_PAREN ( argument ( respect_or_ignore_nulls )? )? ( COMMA argument ( respect_or_ignore_nulls )? )* RIGHT_PAREN ( keep_clause )? -> ^( ARGUMENTS ( argument )* ( keep_clause )? ) ;
 */
OracleDML_OracleDMLCommons::function_argument_analytic_return
OracleDML_OracleDMLCommons::function_argument_analytic()
{
    OracleDML_OracleDMLCommons::function_argument_analytic_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN117 = NULL;
    ImplTraits::CommonTokenType const* COMMA120 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN123 = NULL;
    OracleDML_OracleDMLCommons::argument_return argument118;
    ImplTraits::TreeTypePtr::pointer argument118_last = NULL;
    OracleDML_OracleDMLCommons::respect_or_ignore_nulls_return respect_or_ignore_nulls119;
    ImplTraits::TreeTypePtr::pointer respect_or_ignore_nulls119_last = NULL;
    OracleDML_OracleDMLCommons::argument_return argument121;
    ImplTraits::TreeTypePtr::pointer argument121_last = NULL;
    OracleDML_OracleDMLCommons::respect_or_ignore_nulls_return respect_or_ignore_nulls122;
    ImplTraits::TreeTypePtr::pointer respect_or_ignore_nulls122_last = NULL;
    OracleDML_OracleDMLCommons::keep_clause_return keep_clause124;
    ImplTraits::TreeTypePtr::pointer keep_clause124_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN117_tree;
    ImplTraits::TreeTypePtr COMMA120_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN123_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_argument(get_psrstate()->get_treeAdaptor(), "rule argument");
    RewriteRuleSubtreeStream<ImplTraits> stream_respect_or_ignore_nulls(get_psrstate()->get_treeAdaptor(), "rule respect_or_ignore_nulls");
    RewriteRuleSubtreeStream<ImplTraits> stream_keep_clause(get_psrstate()->get_treeAdaptor(), "rule keep_clause");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:326:5: ( LEFT_PAREN ( argument ( respect_or_ignore_nulls )? )? ( COMMA argument ( respect_or_ignore_nulls )? )* RIGHT_PAREN ( keep_clause )? -> ^( ARGUMENTS ( argument )* ( keep_clause )? ) )
        // OracleDMLCommons.g:326:10: LEFT_PAREN ( argument ( respect_or_ignore_nulls )? )? ( COMMA argument ( respect_or_ignore_nulls )? )* RIGHT_PAREN ( keep_clause )?
        {
            LEFT_PAREN117 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_function_argument_analytic2433);
            if  (this->hasException())
            {
                goto rulefunction_argument_analyticEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN117);


            // OracleDMLCommons.g:327:13: ( argument ( respect_or_ignore_nulls )? )?
            {
                ANTLR_UINT32 alt39=2;
                switch ( this->LA(1) )
                {
                    case APPROXIMATE_NUM_LIT:
                    case BINDVAR:
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case COLON:
                    case DELIMITED_ID:
                    case EXACT_NUM_LIT:
                    case INTRODUCER:
                    case LEFT_PAREN:
                    case MINUS_SIGN:
                    case NATIONAL_CHAR_STRING_LIT:
                    case PLSQL_NON_RESERVED_CAST:
                    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                    case PLUS_SIGN:
                    case REGULAR_ID:
                    case SQL92_RESERVED_ALL:
                    case SQL92_RESERVED_ANY:
                    case SQL92_RESERVED_CASE:
                    case SQL92_RESERVED_CURSOR:
                    case SQL92_RESERVED_DATE:
                    case SQL92_RESERVED_DEFAULT:
                    case SQL92_RESERVED_DISTINCT:
                    case SQL92_RESERVED_EXISTS:
                    case SQL92_RESERVED_FALSE:
                    case SQL92_RESERVED_NOT:
                    case SQL92_RESERVED_NULL:
                    case SQL92_RESERVED_PRIOR:
                    case SQL92_RESERVED_TRUE:
                    case UNSIGNED_INTEGER:
                    	{
                    		alt39=1;
                    	}
                        break;
                }

                switch (alt39)
                {
            	case 1:
            	    // OracleDMLCommons.g:327:14: argument ( respect_or_ignore_nulls )?
            	    {
            	        this->followPush(FOLLOW_argument_in_function_argument_analytic2448);
            	        argument118=argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_analyticEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            argument118_last = argument118.tree.get();
            	            stream_argument.add(argument118.tree);
            	        }

            	        // OracleDMLCommons.g:327:23: ( respect_or_ignore_nulls )?
            	        {
            	            ANTLR_UINT32 alt38=2;
            	            {
            	                ANTLR_UINT32 LA38_0 = this->LA(1);
            	                if ( (LA38_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "IGNORE"))||((toUpper(LT(1)->getText()) == "RESPECT")))))
            	                {
            	                    alt38=1;
            	                }
            	            }
            	            switch (alt38)
            	            {
            	        	case 1:
            	        	    // OracleDMLCommons.g:327:23: respect_or_ignore_nulls
            	        	    {
            	        	        this->followPush(FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic2450);
            	        	        respect_or_ignore_nulls119=respect_or_ignore_nulls();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_analyticEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            respect_or_ignore_nulls119_last = respect_or_ignore_nulls119.tree.get();
            	        	            stream_respect_or_ignore_nulls.add(respect_or_ignore_nulls119.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // OracleDMLCommons.g:328:13: ( COMMA argument ( respect_or_ignore_nulls )? )*

            for (;;)
            {
                ANTLR_UINT32 alt41=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt41=1;
                	}
                    break;

                }

                switch (alt41)
                {
            	case 1:
            	    // OracleDMLCommons.g:328:14: COMMA argument ( respect_or_ignore_nulls )?
            	    {
            	        COMMA120 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument_analytic2468);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_analyticEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA120);


            	        this->followPush(FOLLOW_argument_in_function_argument_analytic2470);
            	        argument121=argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_analyticEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            argument121_last = argument121.tree.get();
            	            stream_argument.add(argument121.tree);
            	        }

            	        // OracleDMLCommons.g:328:29: ( respect_or_ignore_nulls )?
            	        {
            	            ANTLR_UINT32 alt40=2;
            	            {
            	                ANTLR_UINT32 LA40_0 = this->LA(1);
            	                if ( (LA40_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "IGNORE"))||((toUpper(LT(1)->getText()) == "RESPECT")))))
            	                {
            	                    alt40=1;
            	                }
            	            }
            	            switch (alt40)
            	            {
            	        	case 1:
            	        	    // OracleDMLCommons.g:328:29: respect_or_ignore_nulls
            	        	    {
            	        	        this->followPush(FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic2472);
            	        	        respect_or_ignore_nulls122=respect_or_ignore_nulls();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_analyticEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            respect_or_ignore_nulls122_last = respect_or_ignore_nulls122.tree.get();
            	        	            stream_respect_or_ignore_nulls.add(respect_or_ignore_nulls122.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop41;	/* break out of the loop */
            	    break;
                }
            }
            loop41: ; /* Jump out to here if this rule does not match */


            RIGHT_PAREN123 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_function_argument_analytic2487);
            if  (this->hasException())
            {
                goto rulefunction_argument_analyticEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN123);


            // OracleDMLCommons.g:330:10: ( keep_clause )?
            {
                ANTLR_UINT32 alt42=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case LEFT_PAREN:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case REGULAR_ID:
                    		    		    	{
                    		    		    		switch ( this->LA(4) )
                    		    		    		{
                    		    		    		    case REGULAR_ID:
                    		    		    		    	{
                    		    		    		    		{
                    		    		    		    		    ANTLR_UINT32 LA42_15 = this->LA(5);
                    		    		    		    		    if ( (LA42_15 == SQL92_RESERVED_ORDER) && ((toUpper(LT(1)->getText()) == "KEEP")))
                    		    		    		    		    {
                    		    		    		    		        alt42=1;
                    		    		    		    		    }
                    		    		    		    		}
                    		    		    		    	}
                    		    		    		        break;
                    		    		    		}

                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt42)
                {
            	case 1:
            	    // OracleDMLCommons.g:330:10: keep_clause
            	    {
            	        this->followPush(FOLLOW_keep_clause_in_function_argument_analytic2498);
            	        keep_clause124=keep_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_analyticEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            keep_clause124_last = keep_clause124.tree.get();
            	            stream_keep_clause.add(keep_clause124.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: keep_clause, argument
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 331:10: -> ^( ARGUMENTS ( argument )* ( keep_clause )? )
            {
            	// OracleDMLCommons.g:331:13: ^( ARGUMENTS ( argument )* ( keep_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ARGUMENTS, "ARGUMENTS"), root_1);
            	// OracleDMLCommons.g:331:25: ( argument )*
            	while ( stream_argument.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_argument.nextTree());
            	}
            	stream_argument.reset();

            	// OracleDMLCommons.g:331:35: ( keep_clause )?
            	if ( stream_keep_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_keep_clause.nextTree());
            	}
            	stream_keep_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefunction_argument_analyticEx; /* Prevent compiler warnings */
    rulefunction_argument_analyticEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end function_argument_analytic */

/**
 * $ANTLR start function_argument_modeling
 * OracleDMLCommons.g:334:1: function_argument_modeling : LEFT_PAREN column_name ( COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )? )? using_key ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | ASTERISK | expression ( column_alias )? ( COMMA expression ( column_alias )? )* ) RIGHT_PAREN ( keep_clause )? -> ^( ARGUMENTS column_name ( keep_clause )? ) ;
 */
OracleDML_OracleDMLCommons::function_argument_modeling_return
OracleDML_OracleDMLCommons::function_argument_modeling()
{
    OracleDML_OracleDMLCommons::function_argument_modeling_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN125 = NULL;
    ImplTraits::CommonTokenType const* COMMA127 = NULL;
    ImplTraits::CommonTokenType const* COMMA130 = NULL;
    ImplTraits::CommonTokenType const* PERIOD135 = NULL;
    ImplTraits::CommonTokenType const* ASTERISK136 = NULL;
    ImplTraits::CommonTokenType const* ASTERISK137 = NULL;
    ImplTraits::CommonTokenType const* COMMA140 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN143 = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name126;
    ImplTraits::TreeTypePtr::pointer column_name126_last = NULL;
    OracleDML_OracleDMLCommons::numeric_return numeric128;
    ImplTraits::TreeTypePtr::pointer numeric128_last = NULL;
    OracleDML_OracleDMLKeys::null_key_return null_key129;
    ImplTraits::TreeTypePtr::pointer null_key129_last = NULL;
    OracleDML_OracleDMLCommons::numeric_return numeric131;
    ImplTraits::TreeTypePtr::pointer numeric131_last = NULL;
    OracleDML_OracleDMLKeys::null_key_return null_key132;
    ImplTraits::TreeTypePtr::pointer null_key132_last = NULL;
    OracleDML_OracleDMLKeys::using_key_return using_key133;
    ImplTraits::TreeTypePtr::pointer using_key133_last = NULL;
    OracleDML_OracleDMLCommons::tableview_name_return tableview_name134;
    ImplTraits::TreeTypePtr::pointer tableview_name134_last = NULL;
    OracleDML::expression_return expression138;
    ImplTraits::TreeTypePtr::pointer expression138_last = NULL;
    OracleDML_OracleDMLCommons::column_alias_return column_alias139;
    ImplTraits::TreeTypePtr::pointer column_alias139_last = NULL;
    OracleDML::expression_return expression141;
    ImplTraits::TreeTypePtr::pointer expression141_last = NULL;
    OracleDML_OracleDMLCommons::column_alias_return column_alias142;
    ImplTraits::TreeTypePtr::pointer column_alias142_last = NULL;
    OracleDML_OracleDMLCommons::keep_clause_return keep_clause144;
    ImplTraits::TreeTypePtr::pointer keep_clause144_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN125_tree;
    ImplTraits::TreeTypePtr COMMA127_tree;
    ImplTraits::TreeTypePtr COMMA130_tree;
    ImplTraits::TreeTypePtr PERIOD135_tree;
    ImplTraits::TreeTypePtr ASTERISK136_tree;
    ImplTraits::TreeTypePtr ASTERISK137_tree;
    ImplTraits::TreeTypePtr COMMA140_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN143_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleTokenStream<ImplTraits> stream_ASTERISK(get_psrstate()->get_treeAdaptor(), "token ASTERISK");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_using_key(get_psrstate()->get_treeAdaptor(), "rule using_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_numeric(get_psrstate()->get_treeAdaptor(), "rule numeric");
    RewriteRuleSubtreeStream<ImplTraits> stream_null_key(get_psrstate()->get_treeAdaptor(), "rule null_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_alias(get_psrstate()->get_treeAdaptor(), "rule column_alias");
    RewriteRuleSubtreeStream<ImplTraits> stream_keep_clause(get_psrstate()->get_treeAdaptor(), "rule keep_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_name(get_psrstate()->get_treeAdaptor(), "rule column_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_tableview_name(get_psrstate()->get_treeAdaptor(), "rule tableview_name");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:335:5: ( LEFT_PAREN column_name ( COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )? )? using_key ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | ASTERISK | expression ( column_alias )? ( COMMA expression ( column_alias )? )* ) RIGHT_PAREN ( keep_clause )? -> ^( ARGUMENTS column_name ( keep_clause )? ) )
        // OracleDMLCommons.g:335:10: LEFT_PAREN column_name ( COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )? )? using_key ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | ASTERISK | expression ( column_alias )? ( COMMA expression ( column_alias )? )* ) RIGHT_PAREN ( keep_clause )?
        {
            LEFT_PAREN125 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_function_argument_modeling2540);
            if  (this->hasException())
            {
                goto rulefunction_argument_modelingEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN125);


            this->followPush(FOLLOW_column_name_in_function_argument_modeling2554);
            column_name126=column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_argument_modelingEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                column_name126_last = column_name126.tree.get();
                stream_column_name.add(column_name126.tree);
            }

            // OracleDMLCommons.g:336:25: ( COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )? )?
            {
                ANTLR_UINT32 alt46=2;
                switch ( this->LA(1) )
                {
                    case COMMA:
                    	{
                    		alt46=1;
                    	}
                        break;
                }

                switch (alt46)
                {
            	case 1:
            	    // OracleDMLCommons.g:336:26: COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )?
            	    {
            	        COMMA127 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument_modeling2557);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA127);


            	        // OracleDMLCommons.g:336:32: ( numeric | null_key )
            	        {
            	            ANTLR_UINT32 alt43=2;
            	            switch ( this->LA(1) )
            	            {
            	            case APPROXIMATE_NUM_LIT:
            	            case EXACT_NUM_LIT:
            	            case UNSIGNED_INTEGER:
            	            	{
            	            		alt43=1;
            	            	}
            	                break;
            	            case SQL92_RESERVED_NULL:
            	            	{
            	            		alt43=2;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return retval;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 43 );
            	                ex->set_state( 0 );


            	                goto rulefunction_argument_modelingEx;

            	            }

            	            switch (alt43)
            	            {
            	        	case 1:
            	        	    // OracleDMLCommons.g:336:33: numeric
            	        	    {
            	        	        this->followPush(FOLLOW_numeric_in_function_argument_modeling2560);
            	        	        numeric128=numeric();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            numeric128_last = numeric128.tree.get();
            	        	            stream_numeric.add(numeric128.tree);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDMLCommons.g:336:41: null_key
            	        	    {
            	        	        this->followPush(FOLLOW_null_key_in_function_argument_modeling2562);
            	        	        null_key129=m_gOracleDML->null_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            null_key129_last = null_key129.tree.get();
            	        	            stream_null_key.add(null_key129.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	        // OracleDMLCommons.g:336:51: ( COMMA ( numeric | null_key ) )?
            	        {
            	            ANTLR_UINT32 alt45=2;
            	            switch ( this->LA(1) )
            	            {
            	                case COMMA:
            	                	{
            	                		alt45=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt45)
            	            {
            	        	case 1:
            	        	    // OracleDMLCommons.g:336:52: COMMA ( numeric | null_key )
            	        	    {
            	        	        COMMA130 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument_modeling2566);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA130);


            	        	        // OracleDMLCommons.g:336:58: ( numeric | null_key )
            	        	        {
            	        	            ANTLR_UINT32 alt44=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	            case APPROXIMATE_NUM_LIT:
            	        	            case EXACT_NUM_LIT:
            	        	            case UNSIGNED_INTEGER:
            	        	            	{
            	        	            		alt44=1;
            	        	            	}
            	        	                break;
            	        	            case SQL92_RESERVED_NULL:
            	        	            	{
            	        	            		alt44=2;
            	        	            	}
            	        	                break;

            	        	            default:
            	        	                if (this->get_backtracking()>0)
            	        	                {
            	        	                    this->set_failedflag( true );
            	        	                    return retval;
            	        	                }

            	        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	        	                ex->set_decisionNum( 44 );
            	        	                ex->set_state( 0 );


            	        	                goto rulefunction_argument_modelingEx;

            	        	            }

            	        	            switch (alt44)
            	        	            {
            	        	        	case 1:
            	        	        	    // OracleDMLCommons.g:336:59: numeric
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_numeric_in_function_argument_modeling2569);
            	        	        	        numeric131=numeric();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulefunction_argument_modelingEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }

            	        	        	        if ( this->get_backtracking()==0 ) 
            	        	        	        {
            	        	        	            numeric131_last = numeric131.tree.get();
            	        	        	            stream_numeric.add(numeric131.tree);
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // OracleDMLCommons.g:336:67: null_key
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_null_key_in_function_argument_modeling2571);
            	        	        	        null_key132=m_gOracleDML->null_key();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulefunction_argument_modelingEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }

            	        	        	        if ( this->get_backtracking()==0 ) 
            	        	        	        {
            	        	        	            null_key132_last = null_key132.tree.get();
            	        	        	            stream_null_key.add(null_key132.tree);
            	        	        	        }

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_using_key_in_function_argument_modeling2592);
            using_key133=m_gOracleDML->using_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_argument_modelingEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                using_key133_last = using_key133.tree.get();
                stream_using_key.add(using_key133.tree);
            }

            // OracleDMLCommons.g:338:17: ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | ASTERISK | expression ( column_alias )? ( COMMA expression ( column_alias )? )* )
            {
                ANTLR_UINT32 alt50=3;
                switch ( this->LA(1) )
                {
                case INTRODUCER:
                	{
                		{
                		    ANTLR_UINT32 LA50_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred18_OracleDMLCommons>() )))
                		    {
                		        alt50=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt50=3;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 50 );
                		        ex->set_state( 1 );


                		        goto rulefunction_argument_modelingEx;

                		    }
                		}
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    ANTLR_UINT32 LA50_2 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred18_OracleDMLCommons>() )))
                		    {
                		        alt50=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt50=3;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 50 );
                		        ex->set_state( 2 );


                		        goto rulefunction_argument_modelingEx;

                		    }
                		}
                	}
                    break;
                case DELIMITED_ID:
                	{
                		{
                		    ANTLR_UINT32 LA50_3 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred18_OracleDMLCommons>() )))
                		    {
                		        alt50=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt50=3;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 50 );
                		        ex->set_state( 3 );


                		        goto rulefunction_argument_modelingEx;

                		    }
                		}
                	}
                    break;
                case ASTERISK:
                	{
                		alt50=2;
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case EXACT_NUM_LIT:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CAST:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt50=3;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 50 );
                    ex->set_state( 0 );


                    goto rulefunction_argument_modelingEx;

                }

                switch (alt50)
                {
            	case 1:
            	    // OracleDMLCommons.g:338:19: ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK
            	    {
            	        this->followPush(FOLLOW_tableview_name_in_function_argument_modeling2621);
            	        tableview_name134=tableview_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            tableview_name134_last = tableview_name134.tree.get();
            	            stream_tableview_name.add(tableview_name134.tree);
            	        }

            	        PERIOD135 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_function_argument_modeling2623);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD135);


            	        ASTERISK136 =  this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_function_argument_modeling2625);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_ASTERISK.add(ASTERISK136);


            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:339:19: ASTERISK
            	    {
            	        ASTERISK137 =  this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_function_argument_modeling2645);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_ASTERISK.add(ASTERISK137);


            	    }
            	    break;
            	case 3:
            	    // OracleDMLCommons.g:340:19: expression ( column_alias )? ( COMMA expression ( column_alias )? )*
            	    {
            	        this->followPush(FOLLOW_expression_in_function_argument_modeling2665);
            	        expression138=m_gOracleDML->expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            expression138_last = expression138.tree.get();
            	            stream_expression.add(expression138.tree);
            	        }

            	        // OracleDMLCommons.g:340:30: ( column_alias )?
            	        {
            	            ANTLR_UINT32 alt47=2;
            	            switch ( this->LA(1) )
            	            {
            	                case CHAR_STRING:
            	                case CHAR_STRING_PERL:
            	                case DELIMITED_ID:
            	                case INTRODUCER:
            	                case NATIONAL_CHAR_STRING_LIT:
            	                case REGULAR_ID:
            	                case SQL92_RESERVED_AS:
            	                	{
            	                		alt47=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt47)
            	            {
            	        	case 1:
            	        	    // OracleDMLCommons.g:340:30: column_alias
            	        	    {
            	        	        this->followPush(FOLLOW_column_alias_in_function_argument_modeling2667);
            	        	        column_alias139=column_alias();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            column_alias139_last = column_alias139.tree.get();
            	        	            stream_column_alias.add(column_alias139.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	        // OracleDMLCommons.g:340:44: ( COMMA expression ( column_alias )? )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt49=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt49=1;
            	            	}
            	                break;

            	            }

            	            switch (alt49)
            	            {
            	        	case 1:
            	        	    // OracleDMLCommons.g:340:45: COMMA expression ( column_alias )?
            	        	    {
            	        	        COMMA140 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument_modeling2671);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA140);


            	        	        this->followPush(FOLLOW_expression_in_function_argument_modeling2673);
            	        	        expression141=m_gOracleDML->expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            expression141_last = expression141.tree.get();
            	        	            stream_expression.add(expression141.tree);
            	        	        }

            	        	        // OracleDMLCommons.g:340:62: ( column_alias )?
            	        	        {
            	        	            ANTLR_UINT32 alt48=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	                case CHAR_STRING:
            	        	                case CHAR_STRING_PERL:
            	        	                case DELIMITED_ID:
            	        	                case INTRODUCER:
            	        	                case NATIONAL_CHAR_STRING_LIT:
            	        	                case REGULAR_ID:
            	        	                case SQL92_RESERVED_AS:
            	        	                	{
            	        	                		alt48=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt48)
            	        	            {
            	        	        	case 1:
            	        	        	    // OracleDMLCommons.g:340:62: column_alias
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_column_alias_in_function_argument_modeling2675);
            	        	        	        column_alias142=column_alias();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulefunction_argument_modelingEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }

            	        	        	        if ( this->get_backtracking()==0 ) 
            	        	        	        {
            	        	        	            column_alias142_last = column_alias142.tree.get();
            	        	        	            stream_column_alias.add(column_alias142.tree);
            	        	        	        }

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop49;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop49: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            RIGHT_PAREN143 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_function_argument_modeling2707);
            if  (this->hasException())
            {
                goto rulefunction_argument_modelingEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN143);


            // OracleDMLCommons.g:343:10: ( keep_clause )?
            {
                ANTLR_UINT32 alt51=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case LEFT_PAREN:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case REGULAR_ID:
                    		    		    	{
                    		    		    		switch ( this->LA(4) )
                    		    		    		{
                    		    		    		    case REGULAR_ID:
                    		    		    		    	{
                    		    		    		    		{
                    		    		    		    		    ANTLR_UINT32 LA51_14 = this->LA(5);
                    		    		    		    		    if ( (LA51_14 == SQL92_RESERVED_ORDER) && ((toUpper(LT(1)->getText()) == "KEEP")))
                    		    		    		    		    {
                    		    		    		    		        alt51=1;
                    		    		    		    		    }
                    		    		    		    		}
                    		    		    		    	}
                    		    		    		        break;
                    		    		    		}

                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt51)
                {
            	case 1:
            	    // OracleDMLCommons.g:343:10: keep_clause
            	    {
            	        this->followPush(FOLLOW_keep_clause_in_function_argument_modeling2718);
            	        keep_clause144=keep_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            keep_clause144_last = keep_clause144.tree.get();
            	            stream_keep_clause.add(keep_clause144.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: keep_clause, column_name
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 344:10: -> ^( ARGUMENTS column_name ( keep_clause )? )
            {
            	// OracleDMLCommons.g:344:13: ^( ARGUMENTS column_name ( keep_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ARGUMENTS, "ARGUMENTS"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_name.nextTree());
            	// OracleDMLCommons.g:344:37: ( keep_clause )?
            	if ( stream_keep_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_keep_clause.nextTree());
            	}
            	stream_keep_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefunction_argument_modelingEx; /* Prevent compiler warnings */
    rulefunction_argument_modelingEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end function_argument_modeling */

/**
 * $ANTLR start respect_or_ignore_nulls
 * OracleDMLCommons.g:347:1: respect_or_ignore_nulls : ( respect_key | ignore_key ) nulls_key ;
 */
OracleDML_OracleDMLCommons::respect_or_ignore_nulls_return
OracleDML_OracleDMLCommons::respect_or_ignore_nulls()
{
    OracleDML_OracleDMLCommons::respect_or_ignore_nulls_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::respect_key_return respect_key145;
    ImplTraits::TreeTypePtr::pointer respect_key145_last = NULL;
    OracleDML_OracleDMLKeys::ignore_key_return ignore_key146;
    ImplTraits::TreeTypePtr::pointer ignore_key146_last = NULL;
    OracleDML_OracleDMLKeys::nulls_key_return nulls_key147;
    ImplTraits::TreeTypePtr::pointer nulls_key147_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:348:5: ( ( respect_key | ignore_key ) nulls_key )
        // OracleDMLCommons.g:348:10: ( respect_key | ignore_key ) nulls_key
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            // OracleDMLCommons.g:348:10: ( respect_key | ignore_key )
            {
                ANTLR_UINT32 alt52=2;
                {
                    ANTLR_UINT32 LA52_0 = this->LA(1);
                    if ( (LA52_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "IGNORE"))||((toUpper(LT(1)->getText()) == "RESPECT")))))
                    {
                        {
                            ANTLR_UINT32 LA52_1 = this->LA(2);
                            if ( ((toUpper(LT(1)->getText()) == "RESPECT")))
                            {
                                alt52=1;
                            }
                            else if ( ((toUpper(LT(1)->getText()) == "IGNORE")))
                            {
                                alt52=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return retval;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 52 );
                                ex->set_state( 1 );


                                goto rulerespect_or_ignore_nullsEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 52 );
                        ex->set_state( 0 );


                        goto rulerespect_or_ignore_nullsEx;

                    }
                }
                switch (alt52)
                {
            	case 1:
            	    // OracleDMLCommons.g:348:11: respect_key
            	    {
            	        this->followPush(FOLLOW_respect_key_in_respect_or_ignore_nulls2760);
            	        respect_key145=m_gOracleDML->respect_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerespect_or_ignore_nullsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, respect_key145.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:348:25: ignore_key
            	    {
            	        this->followPush(FOLLOW_ignore_key_in_respect_or_ignore_nulls2764);
            	        ignore_key146=m_gOracleDML->ignore_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerespect_or_ignore_nullsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, ignore_key146.tree);


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_nulls_key_in_respect_or_ignore_nulls2767);
            nulls_key147=m_gOracleDML->nulls_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerespect_or_ignore_nullsEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, nulls_key147.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerespect_or_ignore_nullsEx; /* Prevent compiler warnings */
    rulerespect_or_ignore_nullsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end respect_or_ignore_nulls */

/**
 * $ANTLR start argument
 * OracleDMLCommons.g:351:1: argument : ( ( id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )=> id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )? expression_wrapper -> {mode == 1}? ^( ARGUMENT expression_wrapper ^( PARAMETER_NAME[$EQUALS_OP] id ) ) -> ^( ARGUMENT expression_wrapper ) ;
 */
OracleDML_OracleDMLCommons::argument_return
OracleDML_OracleDMLCommons::argument()
{
    OracleDML_OracleDMLCommons::argument_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* EQUALS_OP149 = NULL;
    ImplTraits::CommonTokenType const* GREATER_THAN_OP150 = NULL;
    OracleDML_OracleDMLCommons::id_return id148;
    ImplTraits::TreeTypePtr::pointer id148_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper151;
    ImplTraits::TreeTypePtr::pointer expression_wrapper151_last = NULL;
    ImplTraits::TreeTypePtr EQUALS_OP149_tree;
    ImplTraits::TreeTypePtr GREATER_THAN_OP150_tree;
    RewriteRuleTokenStream<ImplTraits> stream_GREATER_THAN_OP(get_psrstate()->get_treeAdaptor(), "token GREATER_THAN_OP");
    RewriteRuleTokenStream<ImplTraits> stream_EQUALS_OP(get_psrstate()->get_treeAdaptor(), "token EQUALS_OP");
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression_wrapper(get_psrstate()->get_treeAdaptor(), "rule expression_wrapper");

    /* Initialize rule variables
     */

        int mode = 0;    
    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:353:5: ( ( ( id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )=> id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )? expression_wrapper -> {mode == 1}? ^( ARGUMENT expression_wrapper ^( PARAMETER_NAME[$EQUALS_OP] id ) ) -> ^( ARGUMENT expression_wrapper ) )
        // OracleDMLCommons.g:353:10: ( ( id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )=> id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )? expression_wrapper
        {
            // OracleDMLCommons.g:353:10: ( ( id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )=> id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )?
            {
                ANTLR_UINT32 alt53=2;
                alt53 = cdfa53.predict(this, this->get_rec(), this->get_istream(), cdfa53 );
                if  (this->hasException())
                {
                    goto ruleargumentEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                switch (alt53)
                {
            	case 1:
            	    // OracleDMLCommons.g:353:11: ( id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )=> id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP
            	    {
            	        this->followPush(FOLLOW_id_in_argument2806);
            	        id148=id(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleargumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id148_last = id148.tree.get();
            	            stream_id.add(id148.tree);
            	        }

            	        EQUALS_OP149 =  this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_argument2809);
            	        if  (this->hasException())
            	        {
            	            goto ruleargumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_EQUALS_OP.add(EQUALS_OP149);


            	        GREATER_THAN_OP150 =  this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_argument2811);
            	        if  (this->hasException())
            	        {
            	            goto ruleargumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_GREATER_THAN_OP.add(GREATER_THAN_OP150);


            	        if ( this->get_backtracking()==0 )
            	        {
            	            mode = 1;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_wrapper_in_argument2817);
            expression_wrapper151=m_gOracleDML->expression_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleargumentEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression_wrapper151_last = expression_wrapper151.tree.get();
                stream_expression_wrapper.add(expression_wrapper151.tree);
            }

            // AST REWRITE
            // elements: expression_wrapper, id, expression_wrapper
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 354:9: -> {mode == 1}? ^( ARGUMENT expression_wrapper ^( PARAMETER_NAME[$EQUALS_OP] id ) )
            if (mode == 1) {
            	// OracleDMLCommons.g:354:24: ^( ARGUMENT expression_wrapper ^( PARAMETER_NAME[$EQUALS_OP] id ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ARGUMENT, "ARGUMENT"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression_wrapper.nextTree());
            	// OracleDMLCommons.g:354:54: ^( PARAMETER_NAME[$EQUALS_OP] id )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(PARAMETER_NAME, EQUALS_OP149), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_id.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 355:9: -> ^( ARGUMENT expression_wrapper )
            {
            	// OracleDMLCommons.g:355:12: ^( ARGUMENT expression_wrapper )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ARGUMENT, "ARGUMENT"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression_wrapper.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleargumentEx; /* Prevent compiler warnings */
    ruleargumentEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end argument */

/**
 * $ANTLR start type_spec
 * OracleDMLCommons.g:358:1: type_spec : ( datatype | ( ref_key )? type_name ( percent_rowtype_key | percent_type_key )? -> ^( CUSTOM_TYPE type_name ( ref_key )? ( percent_rowtype_key )? ( percent_type_key )? ) );
 */
OracleDML_OracleDMLCommons::type_spec_return
OracleDML_OracleDMLCommons::type_spec()
{
    OracleDML_OracleDMLCommons::type_spec_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::datatype_return datatype152;
    ImplTraits::TreeTypePtr::pointer datatype152_last = NULL;
    OracleDML_OracleDMLKeys::ref_key_return ref_key153;
    ImplTraits::TreeTypePtr::pointer ref_key153_last = NULL;
    OracleDML_OracleDMLCommons::type_name_return type_name154;
    ImplTraits::TreeTypePtr::pointer type_name154_last = NULL;
    OracleDML_OracleDMLKeys::percent_rowtype_key_return percent_rowtype_key155;
    ImplTraits::TreeTypePtr::pointer percent_rowtype_key155_last = NULL;
    OracleDML_OracleDMLKeys::percent_type_key_return percent_type_key156;
    ImplTraits::TreeTypePtr::pointer percent_type_key156_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_percent_type_key(get_psrstate()->get_treeAdaptor(), "rule percent_type_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_type_name(get_psrstate()->get_treeAdaptor(), "rule type_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_percent_rowtype_key(get_psrstate()->get_treeAdaptor(), "rule percent_rowtype_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_ref_key(get_psrstate()->get_treeAdaptor(), "rule ref_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDMLCommons.g:359:5: ( datatype | ( ref_key )? type_name ( percent_rowtype_key | percent_type_key )? -> ^( CUSTOM_TYPE type_name ( ref_key )? ( percent_rowtype_key )? ( percent_type_key )? ) )

            ANTLR_UINT32 alt56;

            alt56=2;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    ANTLR_UINT32 LA56_1 = this->LA(2);
            		    if ( ((((toUpper(LT(1)->getText()) == "CHARACTER"))||((toUpper(LT(1)->getText()) == "INT"))||((toUpper(LT(1)->getText()) == "MONTH"))||((toUpper(LT(1)->getText()) == "TIMEZONE_REGION"))||((toUpper(LT(1)->getText()) == "DECIMAL"))||((toUpper(LT(1)->getText()) == "DSINTERVAL_UNCONSTRAINED"))||((toUpper(LT(1)->getText()) == "SIGNTYPE"))||((toUpper(LT(1)->getText()) == "TIMEZONE_ABBR"))||((toUpper(LT(1)->getText()) == "NATURALN"))||((toUpper(LT(1)->getText()) == "UROWID"))||((toUpper(LT(1)->getText()) == "DAY"))||((toUpper(LT(1)->getText()) == "BOOLEAN"))||((toUpper(LT(1)->getText()) == "BINARY_INTEGER"))||((toUpper(LT(1)->getText()) == "RAW"))||((toUpper(LT(1)->getText()) == "YMINTERVAL_UNCONSTRAINED"))||((toUpper(LT(1)->getText()) == "FLOAT"))||((toUpper(LT(1)->getText()) == "INTEGER"))||((toUpper(LT(1)->getText()) == "ROWID"))||((toUpper(LT(1)->getText()) == "REAL"))||((toUpper(LT(1)->getText()) == "PLS_iNTEGER"))||((toUpper(LT(1)->getText()) == "HOUR"))||((toUpper(LT(1)->getText()) == "CHAR"))||((toUpper(LT(1)->getText()) == "NATURAL"))||((toUpper(LT(1)->getText()) == "BFILE"))||((toUpper(LT(1)->getText()) == "TIMESTAMP"))||((toUpper(LT(1)->getText()) == "SECOND"))||((toUpper(LT(1)->getText()) == "TIMEZONE_MINUTE"))||((toUpper(LT(1)->getText()) == "TIMESTAMP_LTZ_UNCONSTRAINED"))||((toUpper(LT(1)->getText()) == "DOUBLE"))||((toUpper(LT(1)->getText()) == "BLOB"))||((toUpper(LT(1)->getText()) == "POSITIVEN"))||((toUpper(LT(1)->getText()) == "NUMBER"))||((toUpper(LT(1)->getText()) == "VARCHAR2"))||((toUpper(LT(1)->getText()) == "SMALLINT"))||((toUpper(LT(1)->getText()) == "DEC"))||((toUpper(LT(1)->getText()) == "YEAR"))||((toUpper(LT(1)->getText()) == "CLOB"))||((toUpper(LT(1)->getText()) == "POSITIVE"))||((toUpper(LT(1)->getText()) == "TIMESTAMP_UNCONSTRAINED"))||((toUpper(LT(1)->getText()) == "VARCHAR"))||((toUpper(LT(1)->getText()) == "SIMPLE_INTEGER"))||((toUpper(LT(1)->getText()) == "NUMERIC"))||((toUpper(LT(1)->getText()) == "BINARY_DOUBLE"))||((toUpper(LT(1)->getText()) == "NVARCHAR2"))||((toUpper(LT(1)->getText()) == "INTERVAL"))||((toUpper(LT(1)->getText()) == "BINARY_FLOAT"))||((toUpper(LT(1)->getText()) == "LONG"))||((toUpper(LT(1)->getText()) == "NCHAR"))||((toUpper(LT(1)->getText()) == "NCLOB"))||((toUpper(LT(1)->getText()) == "MINUTE"))||((toUpper(LT(1)->getText()) == "MLSLABEL"))||((toUpper(LT(1)->getText()) == "TIMEZONE_HOUR"))||((toUpper(LT(1)->getText()) == "TIMESTAMP_TZ_UNCONSTRAINED"))||((toUpper(LT(1)->getText()) == "STRING")))))
            		    {
            		        alt56=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt56=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 56 );
            		        ex->set_state( 1 );


            		        goto ruletype_specEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_DATE:
            	{
            		alt56=1;
            	}
                break;
            case DELIMITED_ID:
            	{
            		alt56=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 56 );
                ex->set_state( 0 );


                goto ruletype_specEx;

            }

            switch (alt56)
            {
        	case 1:
        	    // OracleDMLCommons.g:359:11: datatype
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_datatype_in_type_spec2878);
        	        datatype152=datatype();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletype_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, datatype152.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:360:10: ( ref_key )? type_name ( percent_rowtype_key | percent_type_key )?
        	    {
        	        // OracleDMLCommons.g:360:10: ( ref_key )?
        	        {
        	            ANTLR_UINT32 alt54=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    ANTLR_UINT32 LA54_1 = this->LA(2);
        	                		    if ( (LA54_1 == REGULAR_ID))
        	                		    {
        	                		        {
        	                		            ANTLR_UINT32 LA54_3 = this->LA(3);
        	                		            if ( ((toUpper(LT(1)->getText()) == "REF")))
        	                		            {
        	                		                alt54=1;
        	                		            }
        	                		        }
        	                		    }
        	                		    else if ( (LA54_1 == DELIMITED_ID) && ((toUpper(LT(1)->getText()) == "REF")))
        	                		    {
        	                		        alt54=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt54)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:360:10: ref_key
        	        	    {
        	        	        this->followPush(FOLLOW_ref_key_in_type_spec2889);
        	        	        ref_key153=m_gOracleDML->ref_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruletype_specEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            ref_key153_last = ref_key153.tree.get();
        	        	            stream_ref_key.add(ref_key153.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_type_name_in_type_spec2892);
        	        type_name154=type_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletype_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            type_name154_last = type_name154.tree.get();
        	            stream_type_name.add(type_name154.tree);
        	        }

        	        // OracleDMLCommons.g:360:29: ( percent_rowtype_key | percent_type_key )?
        	        {
        	            ANTLR_UINT32 alt55=3;
        	            {
        	                ANTLR_UINT32 LA55_0 = this->LA(1);
        	                if ( (LA55_0 == PERCENT) && ((((toUpper(LT(2)->getText()) == "ROWTYPE"))||((toUpper(LT(2)->getText()) == "TYPE")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA55_1 = this->LA(2);
        	                        if ( (LA55_1 == REGULAR_ID) && ((((toUpper(LT(2)->getText()) == "ROWTYPE"))||((toUpper(LT(2)->getText()) == "TYPE")))))
        	                        {
        	                            {
        	                                ANTLR_UINT32 LA55_5 = this->LA(3);
        	                                if ( ((toUpper(LT(2)->getText()) == "ROWTYPE")))
        	                                {
        	                                    alt55=1;
        	                                }
        	                                else if ( ((toUpper(LT(2)->getText()) == "TYPE")))
        	                                {
        	                                    alt55=2;
        	                                }
        	                            }
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt55)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:360:30: percent_rowtype_key
        	        	    {
        	        	        this->followPush(FOLLOW_percent_rowtype_key_in_type_spec2895);
        	        	        percent_rowtype_key155=m_gOracleDML->percent_rowtype_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruletype_specEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            percent_rowtype_key155_last = percent_rowtype_key155.tree.get();
        	        	            stream_percent_rowtype_key.add(percent_rowtype_key155.tree);
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDMLCommons.g:360:50: percent_type_key
        	        	    {
        	        	        this->followPush(FOLLOW_percent_type_key_in_type_spec2897);
        	        	        percent_type_key156=m_gOracleDML->percent_type_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruletype_specEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            percent_type_key156_last = percent_type_key156.tree.get();
        	        	            stream_percent_type_key.add(percent_type_key156.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // AST REWRITE
        	        // elements: type_name, percent_type_key, percent_rowtype_key, ref_key
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 360:69: -> ^( CUSTOM_TYPE type_name ( ref_key )? ( percent_rowtype_key )? ( percent_type_key )? )
        	        {
        	        	// OracleDMLCommons.g:360:72: ^( CUSTOM_TYPE type_name ( ref_key )? ( percent_rowtype_key )? ( percent_type_key )? )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(CUSTOM_TYPE, "CUSTOM_TYPE"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_type_name.nextTree());
        	        	// OracleDMLCommons.g:360:96: ( ref_key )?
        	        	if ( stream_ref_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_ref_key.nextTree());
        	        	}
        	        	stream_ref_key.reset();

        	        	// OracleDMLCommons.g:360:105: ( percent_rowtype_key )?
        	        	if ( stream_percent_rowtype_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_percent_rowtype_key.nextTree());
        	        	}
        	        	stream_percent_rowtype_key.reset();

        	        	// OracleDMLCommons.g:360:126: ( percent_type_key )?
        	        	if ( stream_percent_type_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_percent_type_key.nextTree());
        	        	}
        	        	stream_percent_type_key.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruletype_specEx; /* Prevent compiler warnings */
    ruletype_specEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end type_spec */

/**
 * $ANTLR start datatype
 * OracleDMLCommons.g:363:1: datatype : ( native_datatype_element ( precision_part )? ( with_key ( local_key )? time_key zone_key )? -> ^( NATIVE_DATATYPE native_datatype_element ( precision_part )? ( time_key )? ( local_key )? ) | interval_key ( year_key | day_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? to_key ( month_key | second_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? -> ^( INTERVAL_DATATYPE[$interval_key.start] ( year_key )? ( day_key )? ( month_key )? ( second_key )? ( expression_wrapper )* ) );
 */
OracleDML_OracleDMLCommons::datatype_return
OracleDML_OracleDMLCommons::datatype()
{
    OracleDML_OracleDMLCommons::datatype_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN166 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN168 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN172 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN174 = NULL;
    OracleDML_OracleDMLCommons::native_datatype_element_return native_datatype_element157;
    ImplTraits::TreeTypePtr::pointer native_datatype_element157_last = NULL;
    OracleDML_OracleDMLCommons::precision_part_return precision_part158;
    ImplTraits::TreeTypePtr::pointer precision_part158_last = NULL;
    OracleDML_OracleDMLKeys::with_key_return with_key159;
    ImplTraits::TreeTypePtr::pointer with_key159_last = NULL;
    OracleDML_OracleDMLKeys::local_key_return local_key160;
    ImplTraits::TreeTypePtr::pointer local_key160_last = NULL;
    OracleDML_OracleDMLKeys::time_key_return time_key161;
    ImplTraits::TreeTypePtr::pointer time_key161_last = NULL;
    OracleDML_OracleDMLKeys::zone_key_return zone_key162;
    ImplTraits::TreeTypePtr::pointer zone_key162_last = NULL;
    OracleDML_OracleDMLKeys::interval_key_return interval_key163;
    ImplTraits::TreeTypePtr::pointer interval_key163_last = NULL;
    OracleDML_OracleDMLKeys::year_key_return year_key164;
    ImplTraits::TreeTypePtr::pointer year_key164_last = NULL;
    OracleDML_OracleDMLKeys::day_key_return day_key165;
    ImplTraits::TreeTypePtr::pointer day_key165_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper167;
    ImplTraits::TreeTypePtr::pointer expression_wrapper167_last = NULL;
    OracleDML_OracleDMLKeys::to_key_return to_key169;
    ImplTraits::TreeTypePtr::pointer to_key169_last = NULL;
    OracleDML_OracleDMLKeys::month_key_return month_key170;
    ImplTraits::TreeTypePtr::pointer month_key170_last = NULL;
    OracleDML_OracleDMLKeys::second_key_return second_key171;
    ImplTraits::TreeTypePtr::pointer second_key171_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper173;
    ImplTraits::TreeTypePtr::pointer expression_wrapper173_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN166_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN168_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN172_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN174_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_year_key(get_psrstate()->get_treeAdaptor(), "rule year_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_with_key(get_psrstate()->get_treeAdaptor(), "rule with_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_day_key(get_psrstate()->get_treeAdaptor(), "rule day_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_second_key(get_psrstate()->get_treeAdaptor(), "rule second_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_interval_key(get_psrstate()->get_treeAdaptor(), "rule interval_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression_wrapper(get_psrstate()->get_treeAdaptor(), "rule expression_wrapper");
    RewriteRuleSubtreeStream<ImplTraits> stream_local_key(get_psrstate()->get_treeAdaptor(), "rule local_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_zone_key(get_psrstate()->get_treeAdaptor(), "rule zone_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_to_key(get_psrstate()->get_treeAdaptor(), "rule to_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_precision_part(get_psrstate()->get_treeAdaptor(), "rule precision_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_native_datatype_element(get_psrstate()->get_treeAdaptor(), "rule native_datatype_element");
    RewriteRuleSubtreeStream<ImplTraits> stream_time_key(get_psrstate()->get_treeAdaptor(), "rule time_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_month_key(get_psrstate()->get_treeAdaptor(), "rule month_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDMLCommons.g:364:5: ( native_datatype_element ( precision_part )? ( with_key ( local_key )? time_key zone_key )? -> ^( NATIVE_DATATYPE native_datatype_element ( precision_part )? ( time_key )? ( local_key )? ) | interval_key ( year_key | day_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? to_key ( month_key | second_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? -> ^( INTERVAL_DATATYPE[$interval_key.start] ( year_key )? ( day_key )? ( month_key )? ( second_key )? ( expression_wrapper )* ) )

            ANTLR_UINT32 alt64;

            alt64=2;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    ANTLR_UINT32 LA64_1 = this->LA(2);
            		    if ( ((((toUpper(LT(1)->getText()) == "CHARACTER"))||((toUpper(LT(1)->getText()) == "INT"))||((toUpper(LT(1)->getText()) == "MONTH"))||((toUpper(LT(1)->getText()) == "TIMEZONE_REGION"))||((toUpper(LT(1)->getText()) == "DECIMAL"))||((toUpper(LT(1)->getText()) == "DSINTERVAL_UNCONSTRAINED"))||((toUpper(LT(1)->getText()) == "SIGNTYPE"))||((toUpper(LT(1)->getText()) == "TIMEZONE_ABBR"))||((toUpper(LT(1)->getText()) == "NATURALN"))||((toUpper(LT(1)->getText()) == "UROWID"))||((toUpper(LT(1)->getText()) == "DAY"))||((toUpper(LT(1)->getText()) == "BOOLEAN"))||((toUpper(LT(1)->getText()) == "BINARY_INTEGER"))||((toUpper(LT(1)->getText()) == "RAW"))||((toUpper(LT(1)->getText()) == "YMINTERVAL_UNCONSTRAINED"))||((toUpper(LT(1)->getText()) == "FLOAT"))||((toUpper(LT(1)->getText()) == "INTEGER"))||((toUpper(LT(1)->getText()) == "ROWID"))||((toUpper(LT(1)->getText()) == "HOUR"))||((toUpper(LT(1)->getText()) == "PLS_iNTEGER"))||((toUpper(LT(1)->getText()) == "REAL"))||((toUpper(LT(1)->getText()) == "CHAR"))||((toUpper(LT(1)->getText()) == "BFILE"))||((toUpper(LT(1)->getText()) == "NATURAL"))||((toUpper(LT(1)->getText()) == "TIMESTAMP"))||((toUpper(LT(1)->getText()) == "SECOND"))||((toUpper(LT(1)->getText()) == "TIMEZONE_MINUTE"))||((toUpper(LT(1)->getText()) == "TIMESTAMP_LTZ_UNCONSTRAINED"))||((toUpper(LT(1)->getText()) == "DOUBLE"))||((toUpper(LT(1)->getText()) == "BLOB"))||((toUpper(LT(1)->getText()) == "POSITIVEN"))||((toUpper(LT(1)->getText()) == "NUMBER"))||((toUpper(LT(1)->getText()) == "VARCHAR2"))||((toUpper(LT(1)->getText()) == "SMALLINT"))||((toUpper(LT(1)->getText()) == "DEC"))||((toUpper(LT(1)->getText()) == "YEAR"))||((toUpper(LT(1)->getText()) == "CLOB"))||((toUpper(LT(1)->getText()) == "POSITIVE"))||((toUpper(LT(1)->getText()) == "TIMESTAMP_UNCONSTRAINED"))||((toUpper(LT(1)->getText()) == "VARCHAR"))||((toUpper(LT(1)->getText()) == "SIMPLE_INTEGER"))||((toUpper(LT(1)->getText()) == "NUMERIC"))||((toUpper(LT(1)->getText()) == "BINARY_DOUBLE"))||((toUpper(LT(1)->getText()) == "NVARCHAR2"))||((toUpper(LT(1)->getText()) == "BINARY_FLOAT"))||((toUpper(LT(1)->getText()) == "LONG"))||((toUpper(LT(1)->getText()) == "NCHAR"))||((toUpper(LT(1)->getText()) == "NCLOB"))||((toUpper(LT(1)->getText()) == "MLSLABEL"))||((toUpper(LT(1)->getText()) == "MINUTE"))||((toUpper(LT(1)->getText()) == "TIMEZONE_HOUR"))||((toUpper(LT(1)->getText()) == "TIMESTAMP_TZ_UNCONSTRAINED"))||((toUpper(LT(1)->getText()) == "STRING")))))
            		    {
            		        alt64=1;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "INTERVAL")))
            		    {
            		        alt64=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 64 );
            		        ex->set_state( 1 );


            		        goto ruledatatypeEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_DATE:
            	{
            		alt64=1;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 64 );
                ex->set_state( 0 );


                goto ruledatatypeEx;

            }

            switch (alt64)
            {
        	case 1:
        	    // OracleDMLCommons.g:364:10: native_datatype_element ( precision_part )? ( with_key ( local_key )? time_key zone_key )?
        	    {
        	        this->followPush(FOLLOW_native_datatype_element_in_datatype2936);
        	        native_datatype_element157=native_datatype_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledatatypeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            native_datatype_element157_last = native_datatype_element157.tree.get();
        	            stream_native_datatype_element.add(native_datatype_element157.tree);
        	        }

        	        // OracleDMLCommons.g:365:9: ( precision_part )?
        	        {
        	            ANTLR_UINT32 alt57=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		alt57=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt57)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:365:9: precision_part
        	        	    {
        	        	        this->followPush(FOLLOW_precision_part_in_datatype2946);
        	        	        precision_part158=precision_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            precision_part158_last = precision_part158.tree.get();
        	        	            stream_precision_part.add(precision_part158.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDMLCommons.g:366:9: ( with_key ( local_key )? time_key zone_key )?
        	        {
        	            ANTLR_UINT32 alt59=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_WITH:
        	                	{
        	                		alt59=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt59)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:366:10: with_key ( local_key )? time_key zone_key
        	        	    {
        	        	        this->followPush(FOLLOW_with_key_in_datatype2958);
        	        	        with_key159=m_gOracleDML->with_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            with_key159_last = with_key159.tree.get();
        	        	            stream_with_key.add(with_key159.tree);
        	        	        }

        	        	        // OracleDMLCommons.g:366:19: ( local_key )?
        	        	        {
        	        	            ANTLR_UINT32 alt58=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case REGULAR_ID:
        	        	                	{
        	        	                		switch ( this->LA(2) )
        	        	                		{
        	        	                		    case REGULAR_ID:
        	        	                		    	{
        	        	                		    		switch ( this->LA(3) )
        	        	                		    		{
        	        	                		    		    case REGULAR_ID:
        	        	                		    		    	{
        	        	                		    		    		{
        	        	                		    		    		    ANTLR_UINT32 LA58_3 = this->LA(4);
        	        	                		    		    		    if ( ((toUpper(LT(1)->getText()) == "LOCAL")))
        	        	                		    		    		    {
        	        	                		    		    		        alt58=1;
        	        	                		    		    		    }
        	        	                		    		    		}
        	        	                		    		    	}
        	        	                		    		        break;
        	        	                		    		}

        	        	                		    	}
        	        	                		        break;
        	        	                		}

        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt58)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDMLCommons.g:366:19: local_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_local_key_in_datatype2960);
        	        	        	        local_key160=m_gOracleDML->local_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruledatatypeEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) 
        	        	        	        {
        	        	        	            local_key160_last = local_key160.tree.get();
        	        	        	            stream_local_key.add(local_key160.tree);
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        this->followPush(FOLLOW_time_key_in_datatype2963);
        	        	        time_key161=m_gOracleDML->time_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            time_key161_last = time_key161.tree.get();
        	        	            stream_time_key.add(time_key161.tree);
        	        	        }

        	        	        this->followPush(FOLLOW_zone_key_in_datatype2965);
        	        	        zone_key162=m_gOracleDML->zone_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            zone_key162_last = zone_key162.tree.get();
        	        	            stream_zone_key.add(zone_key162.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // AST REWRITE
        	        // elements: precision_part, native_datatype_element, time_key, local_key
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 367:9: -> ^( NATIVE_DATATYPE native_datatype_element ( precision_part )? ( time_key )? ( local_key )? )
        	        {
        	        	// OracleDMLCommons.g:367:12: ^( NATIVE_DATATYPE native_datatype_element ( precision_part )? ( time_key )? ( local_key )? )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(NATIVE_DATATYPE, "NATIVE_DATATYPE"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_native_datatype_element.nextTree());
        	        	// OracleDMLCommons.g:367:54: ( precision_part )?
        	        	if ( stream_precision_part.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_precision_part.nextTree());
        	        	}
        	        	stream_precision_part.reset();

        	        	// OracleDMLCommons.g:367:70: ( time_key )?
        	        	if ( stream_time_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_time_key.nextTree());
        	        	}
        	        	stream_time_key.reset();

        	        	// OracleDMLCommons.g:367:80: ( local_key )?
        	        	if ( stream_local_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_local_key.nextTree());
        	        	}
        	        	stream_local_key.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:368:10: interval_key ( year_key | day_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? to_key ( month_key | second_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )?
        	    {
        	        this->followPush(FOLLOW_interval_key_in_datatype3003);
        	        interval_key163=m_gOracleDML->interval_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledatatypeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            interval_key163_last = interval_key163.tree.get();
        	            stream_interval_key.add(interval_key163.tree);
        	        }

        	        // OracleDMLCommons.g:368:23: ( year_key | day_key )
        	        {
        	            ANTLR_UINT32 alt60=2;
        	            {
        	                ANTLR_UINT32 LA60_0 = this->LA(1);
        	                if ( (LA60_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "DAY"))||((toUpper(LT(1)->getText()) == "YEAR")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA60_1 = this->LA(2);
        	                        if ( ((toUpper(LT(1)->getText()) == "YEAR")))
        	                        {
        	                            alt60=1;
        	                        }
        	                        else if ( ((toUpper(LT(1)->getText()) == "DAY")))
        	                        {
        	                            alt60=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return retval;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 60 );
        	                            ex->set_state( 1 );


        	                            goto ruledatatypeEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return retval;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 60 );
        	                    ex->set_state( 0 );


        	                    goto ruledatatypeEx;

        	                }
        	            }
        	            switch (alt60)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:368:24: year_key
        	        	    {
        	        	        this->followPush(FOLLOW_year_key_in_datatype3006);
        	        	        year_key164=m_gOracleDML->year_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            year_key164_last = year_key164.tree.get();
        	        	            stream_year_key.add(year_key164.tree);
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDMLCommons.g:368:33: day_key
        	        	    {
        	        	        this->followPush(FOLLOW_day_key_in_datatype3008);
        	        	        day_key165=m_gOracleDML->day_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            day_key165_last = day_key165.tree.get();
        	        	            stream_day_key.add(day_key165.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDMLCommons.g:369:17: ( LEFT_PAREN expression_wrapper RIGHT_PAREN )?
        	        {
        	            ANTLR_UINT32 alt61=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		alt61=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt61)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:369:18: LEFT_PAREN expression_wrapper RIGHT_PAREN
        	        	    {
        	        	        LEFT_PAREN166 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_datatype3028);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN166);


        	        	        this->followPush(FOLLOW_expression_wrapper_in_datatype3030);
        	        	        expression_wrapper167=m_gOracleDML->expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            expression_wrapper167_last = expression_wrapper167.tree.get();
        	        	            stream_expression_wrapper.add(expression_wrapper167.tree);
        	        	        }

        	        	        RIGHT_PAREN168 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_datatype3032);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN168);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_to_key_in_datatype3049);
        	        to_key169=m_gOracleDML->to_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledatatypeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            to_key169_last = to_key169.tree.get();
        	            stream_to_key.add(to_key169.tree);
        	        }

        	        // OracleDMLCommons.g:370:20: ( month_key | second_key )
        	        {
        	            ANTLR_UINT32 alt62=2;
        	            switch ( this->LA(1) )
        	            {
        	            case REGULAR_ID:
        	            	{
        	            		{
        	            		    ANTLR_UINT32 LA62_1 = this->LA(2);
        	            		    if ( ((toUpper(LT(1)->getText()) == "MONTH")))
        	            		    {
        	            		        alt62=1;
        	            		    }
        	            		    else if ( ((toUpper(LT(1)->getText()) == "SECOND")))
        	            		    {
        	            		        alt62=2;
        	            		    }
        	            		    else
        	            		    {
        	            		        if (this->get_backtracking()>0)
        	            		        {
        	            		            this->set_failedflag( true );
        	            		            return retval;
        	            		        }


        	            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            		        ex->set_decisionNum( 62 );
        	            		        ex->set_state( 1 );


        	            		        goto ruledatatypeEx;

        	            		    }
        	            		}
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return retval;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 62 );
        	                ex->set_state( 0 );


        	                goto ruledatatypeEx;

        	            }

        	            switch (alt62)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:370:21: month_key
        	        	    {
        	        	        this->followPush(FOLLOW_month_key_in_datatype3052);
        	        	        month_key170=m_gOracleDML->month_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            month_key170_last = month_key170.tree.get();
        	        	            stream_month_key.add(month_key170.tree);
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDMLCommons.g:370:31: second_key
        	        	    {
        	        	        this->followPush(FOLLOW_second_key_in_datatype3054);
        	        	        second_key171=m_gOracleDML->second_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            second_key171_last = second_key171.tree.get();
        	        	            stream_second_key.add(second_key171.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDMLCommons.g:371:17: ( LEFT_PAREN expression_wrapper RIGHT_PAREN )?
        	        {
        	            ANTLR_UINT32 alt63=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		alt63=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt63)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:371:18: LEFT_PAREN expression_wrapper RIGHT_PAREN
        	        	    {
        	        	        LEFT_PAREN172 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_datatype3075);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN172);


        	        	        this->followPush(FOLLOW_expression_wrapper_in_datatype3077);
        	        	        expression_wrapper173=m_gOracleDML->expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            expression_wrapper173_last = expression_wrapper173.tree.get();
        	        	            stream_expression_wrapper.add(expression_wrapper173.tree);
        	        	        }

        	        	        RIGHT_PAREN174 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_datatype3079);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN174);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // AST REWRITE
        	        // elements: expression_wrapper, day_key, month_key, second_key, year_key
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 372:9: -> ^( INTERVAL_DATATYPE[$interval_key.start] ( year_key )? ( day_key )? ( month_key )? ( second_key )? ( expression_wrapper )* )
        	        {
        	        	// OracleDMLCommons.g:372:12: ^( INTERVAL_DATATYPE[$interval_key.start] ( year_key )? ( day_key )? ( month_key )? ( second_key )? ( expression_wrapper )* )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(INTERVAL_DATATYPE, (interval_key163.start)), root_1);
        	        	// OracleDMLCommons.g:372:53: ( year_key )?
        	        	if ( stream_year_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_year_key.nextTree());
        	        	}
        	        	stream_year_key.reset();

        	        	// OracleDMLCommons.g:372:63: ( day_key )?
        	        	if ( stream_day_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_day_key.nextTree());
        	        	}
        	        	stream_day_key.reset();

        	        	// OracleDMLCommons.g:372:72: ( month_key )?
        	        	if ( stream_month_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_month_key.nextTree());
        	        	}
        	        	stream_month_key.reset();

        	        	// OracleDMLCommons.g:372:83: ( second_key )?
        	        	if ( stream_second_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_second_key.nextTree());
        	        	}
        	        	stream_second_key.reset();

        	        	// OracleDMLCommons.g:372:95: ( expression_wrapper )*
        	        	while ( stream_expression_wrapper.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression_wrapper.nextTree());
        	        	}
        	        	stream_expression_wrapper.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruledatatypeEx; /* Prevent compiler warnings */
    ruledatatypeEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end datatype */

/**
 * $ANTLR start precision_part
 * OracleDMLCommons.g:375:1: precision_part : LEFT_PAREN numeric ( COMMA numeric )? ( char_key | byte_key )? RIGHT_PAREN -> ^( PRECISION ( numeric )+ ( char_key )? ( byte_key )? ) ;
 */
OracleDML_OracleDMLCommons::precision_part_return
OracleDML_OracleDMLCommons::precision_part()
{
    OracleDML_OracleDMLCommons::precision_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN175 = NULL;
    ImplTraits::CommonTokenType const* COMMA177 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN181 = NULL;
    OracleDML_OracleDMLCommons::numeric_return numeric176;
    ImplTraits::TreeTypePtr::pointer numeric176_last = NULL;
    OracleDML_OracleDMLCommons::numeric_return numeric178;
    ImplTraits::TreeTypePtr::pointer numeric178_last = NULL;
    OracleDML_OracleDMLKeys::char_key_return char_key179;
    ImplTraits::TreeTypePtr::pointer char_key179_last = NULL;
    OracleDML_OracleDMLKeys::byte_key_return byte_key180;
    ImplTraits::TreeTypePtr::pointer byte_key180_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN175_tree;
    ImplTraits::TreeTypePtr COMMA177_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN181_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_numeric(get_psrstate()->get_treeAdaptor(), "rule numeric");
    RewriteRuleSubtreeStream<ImplTraits> stream_byte_key(get_psrstate()->get_treeAdaptor(), "rule byte_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_char_key(get_psrstate()->get_treeAdaptor(), "rule char_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:376:5: ( LEFT_PAREN numeric ( COMMA numeric )? ( char_key | byte_key )? RIGHT_PAREN -> ^( PRECISION ( numeric )+ ( char_key )? ( byte_key )? ) )
        // OracleDMLCommons.g:376:10: LEFT_PAREN numeric ( COMMA numeric )? ( char_key | byte_key )? RIGHT_PAREN
        {
            LEFT_PAREN175 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_precision_part3131);
            if  (this->hasException())
            {
                goto ruleprecision_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN175);


            this->followPush(FOLLOW_numeric_in_precision_part3133);
            numeric176=numeric();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprecision_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                numeric176_last = numeric176.tree.get();
                stream_numeric.add(numeric176.tree);
            }

            // OracleDMLCommons.g:376:29: ( COMMA numeric )?
            {
                ANTLR_UINT32 alt65=2;
                switch ( this->LA(1) )
                {
                    case COMMA:
                    	{
                    		alt65=1;
                    	}
                        break;
                }

                switch (alt65)
                {
            	case 1:
            	    // OracleDMLCommons.g:376:30: COMMA numeric
            	    {
            	        COMMA177 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_precision_part3136);
            	        if  (this->hasException())
            	        {
            	            goto ruleprecision_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA177);


            	        this->followPush(FOLLOW_numeric_in_precision_part3138);
            	        numeric178=numeric();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprecision_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            numeric178_last = numeric178.tree.get();
            	            stream_numeric.add(numeric178.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDMLCommons.g:376:46: ( char_key | byte_key )?
            {
                ANTLR_UINT32 alt66=3;
                {
                    ANTLR_UINT32 LA66_0 = this->LA(1);
                    if ( (LA66_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "BYTE"))||((toUpper(LT(1)->getText()) == "CHAR")))))
                    {
                        {
                            ANTLR_UINT32 LA66_1 = this->LA(2);
                            if ( ((toUpper(LT(1)->getText()) == "CHAR")))
                            {
                                alt66=1;
                            }
                            else if ( ((toUpper(LT(1)->getText()) == "BYTE")))
                            {
                                alt66=2;
                            }
                        }
                    }
                }
                switch (alt66)
                {
            	case 1:
            	    // OracleDMLCommons.g:376:47: char_key
            	    {
            	        this->followPush(FOLLOW_char_key_in_precision_part3143);
            	        char_key179=m_gOracleDML->char_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprecision_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            char_key179_last = char_key179.tree.get();
            	            stream_char_key.add(char_key179.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:376:58: byte_key
            	    {
            	        this->followPush(FOLLOW_byte_key_in_precision_part3147);
            	        byte_key180=m_gOracleDML->byte_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprecision_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            byte_key180_last = byte_key180.tree.get();
            	            stream_byte_key.add(byte_key180.tree);
            	        }

            	    }
            	    break;

                }
            }

            RIGHT_PAREN181 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_precision_part3151);
            if  (this->hasException())
            {
                goto ruleprecision_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN181);


            // AST REWRITE
            // elements: char_key, byte_key, numeric
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 377:9: -> ^( PRECISION ( numeric )+ ( char_key )? ( byte_key )? )
            {
            	// OracleDMLCommons.g:377:12: ^( PRECISION ( numeric )+ ( char_key )? ( byte_key )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(PRECISION, "PRECISION"), root_1);
            	if ( !(stream_numeric.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "numeric empty" );
            		goto ruleprecision_partEx;
            	}
            	while ( stream_numeric.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_numeric.nextTree());
            	}
            	stream_numeric.reset();

            	// OracleDMLCommons.g:377:33: ( char_key )?
            	if ( stream_char_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_char_key.nextTree());
            	}
            	stream_char_key.reset();

            	// OracleDMLCommons.g:377:43: ( byte_key )?
            	if ( stream_byte_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_byte_key.nextTree());
            	}
            	stream_byte_key.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleprecision_partEx; /* Prevent compiler warnings */
    ruleprecision_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end precision_part */

/**
 * $ANTLR start native_datatype_element
 * OracleDMLCommons.g:380:1: native_datatype_element : ( binary_integer_key | pls_integer_key | natural_key | binary_float_key | binary_double_key | naturaln_key | positive_key | positiven_key | signtype_key | simple_integer_key | nvarchar2_key | dec_key | integer_key | int_key | numeric_key | smallint_key | number_key | decimal_key | double_key ( precision_key )? | float_key | real_key | nchar_key | long_key ( raw_key )? | char_key | character_key | varchar2_key | varchar_key | string_key | raw_key | boolean_key | date_key | rowid_key | urowid_key | year_key | month_key | day_key | hour_key | minute_key | second_key | timezone_hour_key | timezone_minute_key | timezone_region_key | timezone_abbr_key | timestamp_key | timestamp_unconstrained_key | timestamp_tz_unconstrained_key | timestamp_ltz_unconstrained_key | yminterval_unconstrained_key | dsinterval_unconstrained_key | bfile_key | blob_key | clob_key | nclob_key | mlslabel_key );
 */
OracleDML_OracleDMLCommons::native_datatype_element_return
OracleDML_OracleDMLCommons::native_datatype_element()
{
    OracleDML_OracleDMLCommons::native_datatype_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::binary_integer_key_return binary_integer_key182;
    ImplTraits::TreeTypePtr::pointer binary_integer_key182_last = NULL;
    OracleDML_OracleDMLKeys::pls_integer_key_return pls_integer_key183;
    ImplTraits::TreeTypePtr::pointer pls_integer_key183_last = NULL;
    OracleDML_OracleDMLKeys::natural_key_return natural_key184;
    ImplTraits::TreeTypePtr::pointer natural_key184_last = NULL;
    OracleDML_OracleDMLKeys::binary_float_key_return binary_float_key185;
    ImplTraits::TreeTypePtr::pointer binary_float_key185_last = NULL;
    OracleDML_OracleDMLKeys::binary_double_key_return binary_double_key186;
    ImplTraits::TreeTypePtr::pointer binary_double_key186_last = NULL;
    OracleDML_OracleDMLKeys::naturaln_key_return naturaln_key187;
    ImplTraits::TreeTypePtr::pointer naturaln_key187_last = NULL;
    OracleDML_OracleDMLKeys::positive_key_return positive_key188;
    ImplTraits::TreeTypePtr::pointer positive_key188_last = NULL;
    OracleDML_OracleDMLKeys::positiven_key_return positiven_key189;
    ImplTraits::TreeTypePtr::pointer positiven_key189_last = NULL;
    OracleDML_OracleDMLKeys::signtype_key_return signtype_key190;
    ImplTraits::TreeTypePtr::pointer signtype_key190_last = NULL;
    OracleDML_OracleDMLKeys::simple_integer_key_return simple_integer_key191;
    ImplTraits::TreeTypePtr::pointer simple_integer_key191_last = NULL;
    OracleDML_OracleDMLKeys::nvarchar2_key_return nvarchar2_key192;
    ImplTraits::TreeTypePtr::pointer nvarchar2_key192_last = NULL;
    OracleDML_OracleDMLKeys::dec_key_return dec_key193;
    ImplTraits::TreeTypePtr::pointer dec_key193_last = NULL;
    OracleDML_OracleDMLKeys::integer_key_return integer_key194;
    ImplTraits::TreeTypePtr::pointer integer_key194_last = NULL;
    OracleDML_OracleDMLKeys::int_key_return int_key195;
    ImplTraits::TreeTypePtr::pointer int_key195_last = NULL;
    OracleDML_OracleDMLKeys::numeric_key_return numeric_key196;
    ImplTraits::TreeTypePtr::pointer numeric_key196_last = NULL;
    OracleDML_OracleDMLKeys::smallint_key_return smallint_key197;
    ImplTraits::TreeTypePtr::pointer smallint_key197_last = NULL;
    OracleDML_OracleDMLKeys::number_key_return number_key198;
    ImplTraits::TreeTypePtr::pointer number_key198_last = NULL;
    OracleDML_OracleDMLKeys::decimal_key_return decimal_key199;
    ImplTraits::TreeTypePtr::pointer decimal_key199_last = NULL;
    OracleDML_OracleDMLKeys::double_key_return double_key200;
    ImplTraits::TreeTypePtr::pointer double_key200_last = NULL;
    OracleDML_OracleDMLKeys::precision_key_return precision_key201;
    ImplTraits::TreeTypePtr::pointer precision_key201_last = NULL;
    OracleDML_OracleDMLKeys::float_key_return float_key202;
    ImplTraits::TreeTypePtr::pointer float_key202_last = NULL;
    OracleDML_OracleDMLKeys::real_key_return real_key203;
    ImplTraits::TreeTypePtr::pointer real_key203_last = NULL;
    OracleDML_OracleDMLKeys::nchar_key_return nchar_key204;
    ImplTraits::TreeTypePtr::pointer nchar_key204_last = NULL;
    OracleDML_OracleDMLKeys::long_key_return long_key205;
    ImplTraits::TreeTypePtr::pointer long_key205_last = NULL;
    OracleDML_OracleDMLKeys::raw_key_return raw_key206;
    ImplTraits::TreeTypePtr::pointer raw_key206_last = NULL;
    OracleDML_OracleDMLKeys::char_key_return char_key207;
    ImplTraits::TreeTypePtr::pointer char_key207_last = NULL;
    OracleDML_OracleDMLKeys::character_key_return character_key208;
    ImplTraits::TreeTypePtr::pointer character_key208_last = NULL;
    OracleDML_OracleDMLKeys::varchar2_key_return varchar2_key209;
    ImplTraits::TreeTypePtr::pointer varchar2_key209_last = NULL;
    OracleDML_OracleDMLKeys::varchar_key_return varchar_key210;
    ImplTraits::TreeTypePtr::pointer varchar_key210_last = NULL;
    OracleDML_OracleDMLKeys::string_key_return string_key211;
    ImplTraits::TreeTypePtr::pointer string_key211_last = NULL;
    OracleDML_OracleDMLKeys::raw_key_return raw_key212;
    ImplTraits::TreeTypePtr::pointer raw_key212_last = NULL;
    OracleDML_OracleDMLKeys::boolean_key_return boolean_key213;
    ImplTraits::TreeTypePtr::pointer boolean_key213_last = NULL;
    OracleDML_OracleDMLKeys::date_key_return date_key214;
    ImplTraits::TreeTypePtr::pointer date_key214_last = NULL;
    OracleDML_OracleDMLKeys::rowid_key_return rowid_key215;
    ImplTraits::TreeTypePtr::pointer rowid_key215_last = NULL;
    OracleDML_OracleDMLKeys::urowid_key_return urowid_key216;
    ImplTraits::TreeTypePtr::pointer urowid_key216_last = NULL;
    OracleDML_OracleDMLKeys::year_key_return year_key217;
    ImplTraits::TreeTypePtr::pointer year_key217_last = NULL;
    OracleDML_OracleDMLKeys::month_key_return month_key218;
    ImplTraits::TreeTypePtr::pointer month_key218_last = NULL;
    OracleDML_OracleDMLKeys::day_key_return day_key219;
    ImplTraits::TreeTypePtr::pointer day_key219_last = NULL;
    OracleDML_OracleDMLKeys::hour_key_return hour_key220;
    ImplTraits::TreeTypePtr::pointer hour_key220_last = NULL;
    OracleDML_OracleDMLKeys::minute_key_return minute_key221;
    ImplTraits::TreeTypePtr::pointer minute_key221_last = NULL;
    OracleDML_OracleDMLKeys::second_key_return second_key222;
    ImplTraits::TreeTypePtr::pointer second_key222_last = NULL;
    OracleDML_OracleDMLKeys::timezone_hour_key_return timezone_hour_key223;
    ImplTraits::TreeTypePtr::pointer timezone_hour_key223_last = NULL;
    OracleDML_OracleDMLKeys::timezone_minute_key_return timezone_minute_key224;
    ImplTraits::TreeTypePtr::pointer timezone_minute_key224_last = NULL;
    OracleDML_OracleDMLKeys::timezone_region_key_return timezone_region_key225;
    ImplTraits::TreeTypePtr::pointer timezone_region_key225_last = NULL;
    OracleDML_OracleDMLKeys::timezone_abbr_key_return timezone_abbr_key226;
    ImplTraits::TreeTypePtr::pointer timezone_abbr_key226_last = NULL;
    OracleDML_OracleDMLKeys::timestamp_key_return timestamp_key227;
    ImplTraits::TreeTypePtr::pointer timestamp_key227_last = NULL;
    OracleDML_OracleDMLKeys::timestamp_unconstrained_key_return timestamp_unconstrained_key228;
    ImplTraits::TreeTypePtr::pointer timestamp_unconstrained_key228_last = NULL;
    OracleDML_OracleDMLKeys::timestamp_tz_unconstrained_key_return timestamp_tz_unconstrained_key229;
    ImplTraits::TreeTypePtr::pointer timestamp_tz_unconstrained_key229_last = NULL;
    OracleDML_OracleDMLKeys::timestamp_ltz_unconstrained_key_return timestamp_ltz_unconstrained_key230;
    ImplTraits::TreeTypePtr::pointer timestamp_ltz_unconstrained_key230_last = NULL;
    OracleDML_OracleDMLKeys::yminterval_unconstrained_key_return yminterval_unconstrained_key231;
    ImplTraits::TreeTypePtr::pointer yminterval_unconstrained_key231_last = NULL;
    OracleDML_OracleDMLKeys::dsinterval_unconstrained_key_return dsinterval_unconstrained_key232;
    ImplTraits::TreeTypePtr::pointer dsinterval_unconstrained_key232_last = NULL;
    OracleDML_OracleDMLKeys::bfile_key_return bfile_key233;
    ImplTraits::TreeTypePtr::pointer bfile_key233_last = NULL;
    OracleDML_OracleDMLKeys::blob_key_return blob_key234;
    ImplTraits::TreeTypePtr::pointer blob_key234_last = NULL;
    OracleDML_OracleDMLKeys::clob_key_return clob_key235;
    ImplTraits::TreeTypePtr::pointer clob_key235_last = NULL;
    OracleDML_OracleDMLKeys::nclob_key_return nclob_key236;
    ImplTraits::TreeTypePtr::pointer nclob_key236_last = NULL;
    OracleDML_OracleDMLKeys::mlslabel_key_return mlslabel_key237;
    ImplTraits::TreeTypePtr::pointer mlslabel_key237_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDMLCommons.g:381:5: ( binary_integer_key | pls_integer_key | natural_key | binary_float_key | binary_double_key | naturaln_key | positive_key | positiven_key | signtype_key | simple_integer_key | nvarchar2_key | dec_key | integer_key | int_key | numeric_key | smallint_key | number_key | decimal_key | double_key ( precision_key )? | float_key | real_key | nchar_key | long_key ( raw_key )? | char_key | character_key | varchar2_key | varchar_key | string_key | raw_key | boolean_key | date_key | rowid_key | urowid_key | year_key | month_key | day_key | hour_key | minute_key | second_key | timezone_hour_key | timezone_minute_key | timezone_region_key | timezone_abbr_key | timestamp_key | timestamp_unconstrained_key | timestamp_tz_unconstrained_key | timestamp_ltz_unconstrained_key | yminterval_unconstrained_key | dsinterval_unconstrained_key | bfile_key | blob_key | clob_key | nclob_key | mlslabel_key )

            ANTLR_UINT32 alt69;

            alt69=54;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    ANTLR_UINT32 LA69_1 = this->LA(2);
            		    if ( ((toUpper(LT(1)->getText()) == "BINARY_INTEGER")))
            		    {
            		        alt69=1;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "PLS_iNTEGER")))
            		    {
            		        alt69=2;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "NATURAL")))
            		    {
            		        alt69=3;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "BINARY_FLOAT")))
            		    {
            		        alt69=4;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "BINARY_DOUBLE")))
            		    {
            		        alt69=5;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "NATURALN")))
            		    {
            		        alt69=6;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "POSITIVE")))
            		    {
            		        alt69=7;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "POSITIVEN")))
            		    {
            		        alt69=8;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "SIGNTYPE")))
            		    {
            		        alt69=9;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "SIMPLE_INTEGER")))
            		    {
            		        alt69=10;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "NVARCHAR2")))
            		    {
            		        alt69=11;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "DEC")))
            		    {
            		        alt69=12;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "INTEGER")))
            		    {
            		        alt69=13;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "INT")))
            		    {
            		        alt69=14;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "NUMERIC")))
            		    {
            		        alt69=15;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "SMALLINT")))
            		    {
            		        alt69=16;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "NUMBER")))
            		    {
            		        alt69=17;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "DECIMAL")))
            		    {
            		        alt69=18;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "DOUBLE")))
            		    {
            		        alt69=19;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "FLOAT")))
            		    {
            		        alt69=20;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "REAL")))
            		    {
            		        alt69=21;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "NCHAR")))
            		    {
            		        alt69=22;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "LONG")))
            		    {
            		        alt69=23;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "CHAR")))
            		    {
            		        alt69=24;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "CHARACTER")))
            		    {
            		        alt69=25;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "VARCHAR2")))
            		    {
            		        alt69=26;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "VARCHAR")))
            		    {
            		        alt69=27;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "STRING")))
            		    {
            		        alt69=28;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "RAW")))
            		    {
            		        alt69=29;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "BOOLEAN")))
            		    {
            		        alt69=30;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "ROWID")))
            		    {
            		        alt69=32;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "UROWID")))
            		    {
            		        alt69=33;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "YEAR")))
            		    {
            		        alt69=34;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "MONTH")))
            		    {
            		        alt69=35;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "DAY")))
            		    {
            		        alt69=36;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "HOUR")))
            		    {
            		        alt69=37;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "MINUTE")))
            		    {
            		        alt69=38;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "SECOND")))
            		    {
            		        alt69=39;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "TIMEZONE_HOUR")))
            		    {
            		        alt69=40;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "TIMEZONE_MINUTE")))
            		    {
            		        alt69=41;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "TIMEZONE_REGION")))
            		    {
            		        alt69=42;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "TIMEZONE_ABBR")))
            		    {
            		        alt69=43;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "TIMESTAMP")))
            		    {
            		        alt69=44;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "TIMESTAMP_UNCONSTRAINED")))
            		    {
            		        alt69=45;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "TIMESTAMP_TZ_UNCONSTRAINED")))
            		    {
            		        alt69=46;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "TIMESTAMP_LTZ_UNCONSTRAINED")))
            		    {
            		        alt69=47;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "YMINTERVAL_UNCONSTRAINED")))
            		    {
            		        alt69=48;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "DSINTERVAL_UNCONSTRAINED")))
            		    {
            		        alt69=49;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "BFILE")))
            		    {
            		        alt69=50;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "BLOB")))
            		    {
            		        alt69=51;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "CLOB")))
            		    {
            		        alt69=52;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "NCLOB")))
            		    {
            		        alt69=53;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "MLSLABEL")))
            		    {
            		        alt69=54;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 69 );
            		        ex->set_state( 1 );


            		        goto rulenative_datatype_elementEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_DATE:
            	{
            		alt69=31;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 69 );
                ex->set_state( 0 );


                goto rulenative_datatype_elementEx;

            }

            switch (alt69)
            {
        	case 1:
        	    // OracleDMLCommons.g:381:10: binary_integer_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_binary_integer_key_in_native_datatype_element3194);
        	        binary_integer_key182=m_gOracleDML->binary_integer_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, binary_integer_key182.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:382:10: pls_integer_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_pls_integer_key_in_native_datatype_element3205);
        	        pls_integer_key183=m_gOracleDML->pls_integer_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, pls_integer_key183.tree);


        	    }
        	    break;
        	case 3:
        	    // OracleDMLCommons.g:383:10: natural_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_natural_key_in_native_datatype_element3216);
        	        natural_key184=m_gOracleDML->natural_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, natural_key184.tree);


        	    }
        	    break;
        	case 4:
        	    // OracleDMLCommons.g:384:10: binary_float_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_binary_float_key_in_native_datatype_element3227);
        	        binary_float_key185=m_gOracleDML->binary_float_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, binary_float_key185.tree);


        	    }
        	    break;
        	case 5:
        	    // OracleDMLCommons.g:385:10: binary_double_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_binary_double_key_in_native_datatype_element3238);
        	        binary_double_key186=m_gOracleDML->binary_double_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, binary_double_key186.tree);


        	    }
        	    break;
        	case 6:
        	    // OracleDMLCommons.g:386:10: naturaln_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_naturaln_key_in_native_datatype_element3249);
        	        naturaln_key187=m_gOracleDML->naturaln_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, naturaln_key187.tree);


        	    }
        	    break;
        	case 7:
        	    // OracleDMLCommons.g:387:10: positive_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_positive_key_in_native_datatype_element3260);
        	        positive_key188=m_gOracleDML->positive_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, positive_key188.tree);


        	    }
        	    break;
        	case 8:
        	    // OracleDMLCommons.g:388:10: positiven_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_positiven_key_in_native_datatype_element3271);
        	        positiven_key189=m_gOracleDML->positiven_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, positiven_key189.tree);


        	    }
        	    break;
        	case 9:
        	    // OracleDMLCommons.g:389:10: signtype_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_signtype_key_in_native_datatype_element3282);
        	        signtype_key190=m_gOracleDML->signtype_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, signtype_key190.tree);


        	    }
        	    break;
        	case 10:
        	    // OracleDMLCommons.g:390:10: simple_integer_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_simple_integer_key_in_native_datatype_element3293);
        	        simple_integer_key191=m_gOracleDML->simple_integer_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, simple_integer_key191.tree);


        	    }
        	    break;
        	case 11:
        	    // OracleDMLCommons.g:391:10: nvarchar2_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_nvarchar2_key_in_native_datatype_element3304);
        	        nvarchar2_key192=m_gOracleDML->nvarchar2_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, nvarchar2_key192.tree);


        	    }
        	    break;
        	case 12:
        	    // OracleDMLCommons.g:392:10: dec_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_dec_key_in_native_datatype_element3315);
        	        dec_key193=m_gOracleDML->dec_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, dec_key193.tree);


        	    }
        	    break;
        	case 13:
        	    // OracleDMLCommons.g:393:10: integer_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_integer_key_in_native_datatype_element3326);
        	        integer_key194=m_gOracleDML->integer_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, integer_key194.tree);


        	    }
        	    break;
        	case 14:
        	    // OracleDMLCommons.g:394:10: int_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_int_key_in_native_datatype_element3337);
        	        int_key195=m_gOracleDML->int_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, int_key195.tree);


        	    }
        	    break;
        	case 15:
        	    // OracleDMLCommons.g:395:10: numeric_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_numeric_key_in_native_datatype_element3348);
        	        numeric_key196=m_gOracleDML->numeric_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, numeric_key196.tree);


        	    }
        	    break;
        	case 16:
        	    // OracleDMLCommons.g:396:10: smallint_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_smallint_key_in_native_datatype_element3359);
        	        smallint_key197=m_gOracleDML->smallint_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, smallint_key197.tree);


        	    }
        	    break;
        	case 17:
        	    // OracleDMLCommons.g:397:10: number_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_number_key_in_native_datatype_element3370);
        	        number_key198=m_gOracleDML->number_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, number_key198.tree);


        	    }
        	    break;
        	case 18:
        	    // OracleDMLCommons.g:398:10: decimal_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_decimal_key_in_native_datatype_element3381);
        	        decimal_key199=m_gOracleDML->decimal_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, decimal_key199.tree);


        	    }
        	    break;
        	case 19:
        	    // OracleDMLCommons.g:399:10: double_key ( precision_key )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_double_key_in_native_datatype_element3393);
        	        double_key200=m_gOracleDML->double_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, double_key200.tree);


        	        // OracleDMLCommons.g:399:21: ( precision_key )?
        	        {
        	            ANTLR_UINT32 alt67=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    ANTLR_UINT32 LA67_1 = this->LA(2);
        	                		    if ( ((toUpper(LT(1)->getText()) == "PRECISION")))
        	                		    {
        	                		        alt67=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt67)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:399:21: precision_key
        	        	    {
        	        	        this->followPush(FOLLOW_precision_key_in_native_datatype_element3395);
        	        	        precision_key201=m_gOracleDML->precision_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulenative_datatype_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, precision_key201.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 20:
        	    // OracleDMLCommons.g:400:10: float_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_float_key_in_native_datatype_element3407);
        	        float_key202=m_gOracleDML->float_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, float_key202.tree);


        	    }
        	    break;
        	case 21:
        	    // OracleDMLCommons.g:401:10: real_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_real_key_in_native_datatype_element3418);
        	        real_key203=m_gOracleDML->real_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, real_key203.tree);


        	    }
        	    break;
        	case 22:
        	    // OracleDMLCommons.g:402:10: nchar_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_nchar_key_in_native_datatype_element3429);
        	        nchar_key204=m_gOracleDML->nchar_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, nchar_key204.tree);


        	    }
        	    break;
        	case 23:
        	    // OracleDMLCommons.g:403:10: long_key ( raw_key )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_long_key_in_native_datatype_element3440);
        	        long_key205=m_gOracleDML->long_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, long_key205.tree);


        	        // OracleDMLCommons.g:403:19: ( raw_key )?
        	        {
        	            ANTLR_UINT32 alt68=2;
        	            {
        	                ANTLR_UINT32 LA68_0 = this->LA(1);
        	                if ( (LA68_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "HIDE"))||((toUpper(LT(1)->getText()) == "INDENT"))||((toUpper(LT(1)->getText()) == "SHOW"))||((toUpper(LT(1)->getText()) == "VERSION"))||((toUpper(LT(1)->getText()) == "ENCODING"))||((toUpper(LT(1)->getText()) == "NO"))||((toUpper(LT(1)->getText()) == "PATH"))||((toUpper(LT(1)->getText()) == "RAW")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA68_1 = this->LA(2);
        	                        if ( ((toUpper(LT(1)->getText()) == "RAW")))
        	                        {
        	                            alt68=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt68)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:403:19: raw_key
        	        	    {
        	        	        this->followPush(FOLLOW_raw_key_in_native_datatype_element3442);
        	        	        raw_key206=m_gOracleDML->raw_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulenative_datatype_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, raw_key206.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 24:
        	    // OracleDMLCommons.g:404:10: char_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_char_key_in_native_datatype_element3454);
        	        char_key207=m_gOracleDML->char_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, char_key207.tree);


        	    }
        	    break;
        	case 25:
        	    // OracleDMLCommons.g:405:10: character_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_character_key_in_native_datatype_element3467);
        	        character_key208=m_gOracleDML->character_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, character_key208.tree);


        	    }
        	    break;
        	case 26:
        	    // OracleDMLCommons.g:406:10: varchar2_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_varchar2_key_in_native_datatype_element3479);
        	        varchar2_key209=m_gOracleDML->varchar2_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, varchar2_key209.tree);


        	    }
        	    break;
        	case 27:
        	    // OracleDMLCommons.g:407:10: varchar_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_varchar_key_in_native_datatype_element3490);
        	        varchar_key210=m_gOracleDML->varchar_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, varchar_key210.tree);


        	    }
        	    break;
        	case 28:
        	    // OracleDMLCommons.g:408:10: string_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_string_key_in_native_datatype_element3501);
        	        string_key211=m_gOracleDML->string_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, string_key211.tree);


        	    }
        	    break;
        	case 29:
        	    // OracleDMLCommons.g:409:10: raw_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_raw_key_in_native_datatype_element3512);
        	        raw_key212=m_gOracleDML->raw_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, raw_key212.tree);


        	    }
        	    break;
        	case 30:
        	    // OracleDMLCommons.g:410:10: boolean_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_boolean_key_in_native_datatype_element3523);
        	        boolean_key213=m_gOracleDML->boolean_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, boolean_key213.tree);


        	    }
        	    break;
        	case 31:
        	    // OracleDMLCommons.g:411:10: date_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_date_key_in_native_datatype_element3534);
        	        date_key214=m_gOracleDML->date_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, date_key214.tree);


        	    }
        	    break;
        	case 32:
        	    // OracleDMLCommons.g:412:10: rowid_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_rowid_key_in_native_datatype_element3545);
        	        rowid_key215=m_gOracleDML->rowid_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, rowid_key215.tree);


        	    }
        	    break;
        	case 33:
        	    // OracleDMLCommons.g:413:10: urowid_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_urowid_key_in_native_datatype_element3556);
        	        urowid_key216=m_gOracleDML->urowid_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, urowid_key216.tree);


        	    }
        	    break;
        	case 34:
        	    // OracleDMLCommons.g:414:10: year_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_year_key_in_native_datatype_element3567);
        	        year_key217=m_gOracleDML->year_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, year_key217.tree);


        	    }
        	    break;
        	case 35:
        	    // OracleDMLCommons.g:415:10: month_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_month_key_in_native_datatype_element3578);
        	        month_key218=m_gOracleDML->month_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, month_key218.tree);


        	    }
        	    break;
        	case 36:
        	    // OracleDMLCommons.g:416:10: day_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_day_key_in_native_datatype_element3589);
        	        day_key219=m_gOracleDML->day_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, day_key219.tree);


        	    }
        	    break;
        	case 37:
        	    // OracleDMLCommons.g:417:10: hour_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_hour_key_in_native_datatype_element3600);
        	        hour_key220=m_gOracleDML->hour_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, hour_key220.tree);


        	    }
        	    break;
        	case 38:
        	    // OracleDMLCommons.g:418:10: minute_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_minute_key_in_native_datatype_element3611);
        	        minute_key221=m_gOracleDML->minute_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, minute_key221.tree);


        	    }
        	    break;
        	case 39:
        	    // OracleDMLCommons.g:419:10: second_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_second_key_in_native_datatype_element3622);
        	        second_key222=m_gOracleDML->second_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, second_key222.tree);


        	    }
        	    break;
        	case 40:
        	    // OracleDMLCommons.g:420:10: timezone_hour_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_timezone_hour_key_in_native_datatype_element3633);
        	        timezone_hour_key223=m_gOracleDML->timezone_hour_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, timezone_hour_key223.tree);


        	    }
        	    break;
        	case 41:
        	    // OracleDMLCommons.g:421:10: timezone_minute_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_timezone_minute_key_in_native_datatype_element3644);
        	        timezone_minute_key224=m_gOracleDML->timezone_minute_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, timezone_minute_key224.tree);


        	    }
        	    break;
        	case 42:
        	    // OracleDMLCommons.g:422:10: timezone_region_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_timezone_region_key_in_native_datatype_element3655);
        	        timezone_region_key225=m_gOracleDML->timezone_region_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, timezone_region_key225.tree);


        	    }
        	    break;
        	case 43:
        	    // OracleDMLCommons.g:423:10: timezone_abbr_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_timezone_abbr_key_in_native_datatype_element3666);
        	        timezone_abbr_key226=m_gOracleDML->timezone_abbr_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, timezone_abbr_key226.tree);


        	    }
        	    break;
        	case 44:
        	    // OracleDMLCommons.g:424:10: timestamp_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_timestamp_key_in_native_datatype_element3677);
        	        timestamp_key227=m_gOracleDML->timestamp_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, timestamp_key227.tree);


        	    }
        	    break;
        	case 45:
        	    // OracleDMLCommons.g:425:10: timestamp_unconstrained_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_timestamp_unconstrained_key_in_native_datatype_element3688);
        	        timestamp_unconstrained_key228=m_gOracleDML->timestamp_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, timestamp_unconstrained_key228.tree);


        	    }
        	    break;
        	case 46:
        	    // OracleDMLCommons.g:426:10: timestamp_tz_unconstrained_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_timestamp_tz_unconstrained_key_in_native_datatype_element3699);
        	        timestamp_tz_unconstrained_key229=m_gOracleDML->timestamp_tz_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, timestamp_tz_unconstrained_key229.tree);


        	    }
        	    break;
        	case 47:
        	    // OracleDMLCommons.g:427:10: timestamp_ltz_unconstrained_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_timestamp_ltz_unconstrained_key_in_native_datatype_element3710);
        	        timestamp_ltz_unconstrained_key230=m_gOracleDML->timestamp_ltz_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, timestamp_ltz_unconstrained_key230.tree);


        	    }
        	    break;
        	case 48:
        	    // OracleDMLCommons.g:428:10: yminterval_unconstrained_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_yminterval_unconstrained_key_in_native_datatype_element3721);
        	        yminterval_unconstrained_key231=m_gOracleDML->yminterval_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, yminterval_unconstrained_key231.tree);


        	    }
        	    break;
        	case 49:
        	    // OracleDMLCommons.g:429:10: dsinterval_unconstrained_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_dsinterval_unconstrained_key_in_native_datatype_element3732);
        	        dsinterval_unconstrained_key232=m_gOracleDML->dsinterval_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, dsinterval_unconstrained_key232.tree);


        	    }
        	    break;
        	case 50:
        	    // OracleDMLCommons.g:430:10: bfile_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_bfile_key_in_native_datatype_element3743);
        	        bfile_key233=m_gOracleDML->bfile_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, bfile_key233.tree);


        	    }
        	    break;
        	case 51:
        	    // OracleDMLCommons.g:431:10: blob_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_blob_key_in_native_datatype_element3754);
        	        blob_key234=m_gOracleDML->blob_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, blob_key234.tree);


        	    }
        	    break;
        	case 52:
        	    // OracleDMLCommons.g:432:10: clob_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_clob_key_in_native_datatype_element3765);
        	        clob_key235=m_gOracleDML->clob_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, clob_key235.tree);


        	    }
        	    break;
        	case 53:
        	    // OracleDMLCommons.g:433:10: nclob_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_nclob_key_in_native_datatype_element3776);
        	        nclob_key236=m_gOracleDML->nclob_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, nclob_key236.tree);


        	    }
        	    break;
        	case 54:
        	    // OracleDMLCommons.g:434:10: mlslabel_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_mlslabel_key_in_native_datatype_element3787);
        	        mlslabel_key237=m_gOracleDML->mlslabel_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, mlslabel_key237.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulenative_datatype_elementEx; /* Prevent compiler warnings */
    rulenative_datatype_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end native_datatype_element */

/**
 * $ANTLR start bind_variable
 * OracleDMLCommons.g:437:1: bind_variable : (b1= BINDVAR | COLON u1= UNSIGNED_INTEGER ) ( ( indicator_key )? (b2= BINDVAR | COLON u2= UNSIGNED_INTEGER ) )? ( ( PERIOD general_element_part )=> PERIOD general_element_part )* -> ^( HOSTED_VARIABLE_NAME ( $b1)? ( $u1)? ( indicator_key )? ( $b2)? ( $u2)? ( general_element_part )* ) ;
 */
OracleDML_OracleDMLCommons::bind_variable_return
OracleDML_OracleDMLCommons::bind_variable()
{
    OracleDML_OracleDMLCommons::bind_variable_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* b1 = NULL;
    ImplTraits::CommonTokenType const* u1 = NULL;
    ImplTraits::CommonTokenType const* b2 = NULL;
    ImplTraits::CommonTokenType const* u2 = NULL;
    ImplTraits::CommonTokenType const* COLON238 = NULL;
    ImplTraits::CommonTokenType const* COLON240 = NULL;
    ImplTraits::CommonTokenType const* PERIOD241 = NULL;
    OracleDML_OracleDMLKeys::indicator_key_return indicator_key239;
    ImplTraits::TreeTypePtr::pointer indicator_key239_last = NULL;
    OracleDML_OracleDMLCommons::general_element_part_return general_element_part242;
    ImplTraits::TreeTypePtr::pointer general_element_part242_last = NULL;
    ImplTraits::TreeTypePtr b1_tree;
    ImplTraits::TreeTypePtr u1_tree;
    ImplTraits::TreeTypePtr b2_tree;
    ImplTraits::TreeTypePtr u2_tree;
    ImplTraits::TreeTypePtr COLON238_tree;
    ImplTraits::TreeTypePtr COLON240_tree;
    ImplTraits::TreeTypePtr PERIOD241_tree;
    RewriteRuleTokenStream<ImplTraits> stream_COLON(get_psrstate()->get_treeAdaptor(), "token COLON");
    RewriteRuleTokenStream<ImplTraits> stream_BINDVAR(get_psrstate()->get_treeAdaptor(), "token BINDVAR");
    RewriteRuleTokenStream<ImplTraits> stream_UNSIGNED_INTEGER(get_psrstate()->get_treeAdaptor(), "token UNSIGNED_INTEGER");
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_indicator_key(get_psrstate()->get_treeAdaptor(), "rule indicator_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_general_element_part(get_psrstate()->get_treeAdaptor(), "rule general_element_part");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:438:5: ( (b1= BINDVAR | COLON u1= UNSIGNED_INTEGER ) ( ( indicator_key )? (b2= BINDVAR | COLON u2= UNSIGNED_INTEGER ) )? ( ( PERIOD general_element_part )=> PERIOD general_element_part )* -> ^( HOSTED_VARIABLE_NAME ( $b1)? ( $u1)? ( indicator_key )? ( $b2)? ( $u2)? ( general_element_part )* ) )
        // OracleDMLCommons.g:438:10: (b1= BINDVAR | COLON u1= UNSIGNED_INTEGER ) ( ( indicator_key )? (b2= BINDVAR | COLON u2= UNSIGNED_INTEGER ) )? ( ( PERIOD general_element_part )=> PERIOD general_element_part )*
        {
            // OracleDMLCommons.g:438:10: (b1= BINDVAR | COLON u1= UNSIGNED_INTEGER )
            {
                ANTLR_UINT32 alt70=2;
                switch ( this->LA(1) )
                {
                case BINDVAR:
                	{
                		alt70=1;
                	}
                    break;
                case COLON:
                	{
                		alt70=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 70 );
                    ex->set_state( 0 );


                    goto rulebind_variableEx;

                }

                switch (alt70)
                {
            	case 1:
            	    // OracleDMLCommons.g:438:12: b1= BINDVAR
            	    {
            	        b1 =  this->matchToken(BINDVAR, &FOLLOW_BINDVAR_in_bind_variable3811);
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_BINDVAR.add(b1);


            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:438:25: COLON u1= UNSIGNED_INTEGER
            	    {
            	        COLON238 =  this->matchToken(COLON, &FOLLOW_COLON_in_bind_variable3815);
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COLON.add(COLON238);


            	        u1 =  this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_bind_variable3819);
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_UNSIGNED_INTEGER.add(u1);


            	    }
            	    break;

                }
            }

            // OracleDMLCommons.g:439:10: ( ( indicator_key )? (b2= BINDVAR | COLON u2= UNSIGNED_INTEGER ) )?
            {
                ANTLR_UINT32 alt73=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case BINDVAR:
                    		    	{
                    		    		{
                    		    		    ANTLR_UINT32 LA73_4 = this->LA(3);
                    		    		    if ( ((toUpper(LT(1)->getText()) == "INDICATOR")))
                    		    		    {
                    		    		        alt73=1;
                    		    		    }
                    		    		}
                    		    	}
                    		        break;
                    		    case COLON:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case UNSIGNED_INTEGER:
                    		    		    	{
                    		    		    		{
                    		    		    		    ANTLR_UINT32 LA73_11 = this->LA(4);
                    		    		    		    if ( ((toUpper(LT(1)->getText()) == "INDICATOR")))
                    		    		    		    {
                    		    		    		        alt73=1;
                    		    		    		    }
                    		    		    		}
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                    case BINDVAR:
                    case COLON:
                    	{
                    		alt73=1;
                    	}
                        break;
                }

                switch (alt73)
                {
            	case 1:
            	    // OracleDMLCommons.g:439:12: ( indicator_key )? (b2= BINDVAR | COLON u2= UNSIGNED_INTEGER )
            	    {
            	        // OracleDMLCommons.g:439:12: ( indicator_key )?
            	        {
            	            ANTLR_UINT32 alt71=2;
            	            switch ( this->LA(1) )
            	            {
            	                case REGULAR_ID:
            	                	{
            	                		alt71=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt71)
            	            {
            	        	case 1:
            	        	    // OracleDMLCommons.g:439:12: indicator_key
            	        	    {
            	        	        this->followPush(FOLLOW_indicator_key_in_bind_variable3833);
            	        	        indicator_key239=m_gOracleDML->indicator_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulebind_variableEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            indicator_key239_last = indicator_key239.tree.get();
            	        	            stream_indicator_key.add(indicator_key239.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	        // OracleDMLCommons.g:439:27: (b2= BINDVAR | COLON u2= UNSIGNED_INTEGER )
            	        {
            	            ANTLR_UINT32 alt72=2;
            	            switch ( this->LA(1) )
            	            {
            	            case BINDVAR:
            	            	{
            	            		alt72=1;
            	            	}
            	                break;
            	            case COLON:
            	            	{
            	            		alt72=2;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return retval;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 72 );
            	                ex->set_state( 0 );


            	                goto rulebind_variableEx;

            	            }

            	            switch (alt72)
            	            {
            	        	case 1:
            	        	    // OracleDMLCommons.g:439:28: b2= BINDVAR
            	        	    {
            	        	        b2 =  this->matchToken(BINDVAR, &FOLLOW_BINDVAR_in_bind_variable3839);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulebind_variableEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_BINDVAR.add(b2);


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDMLCommons.g:439:41: COLON u2= UNSIGNED_INTEGER
            	        	    {
            	        	        COLON240 =  this->matchToken(COLON, &FOLLOW_COLON_in_bind_variable3843);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulebind_variableEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COLON.add(COLON240);


            	        	        u2 =  this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_bind_variable3847);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulebind_variableEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_UNSIGNED_INTEGER.add(u2);


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // OracleDMLCommons.g:440:10: ( ( PERIOD general_element_part )=> PERIOD general_element_part )*

            for (;;)
            {
                ANTLR_UINT32 alt74=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    ANTLR_UINT32 LA74_0 = this->LA(1);
                    if ( (LA74_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred20_OracleDMLCommons>() )))
                    {
                        alt74=1;
                    }

                }
                switch (alt74)
                {
            	case 1:
            	    // OracleDMLCommons.g:440:11: ( PERIOD general_element_part )=> PERIOD general_element_part
            	    {
            	        PERIOD241 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_bind_variable3869);
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD241);


            	        this->followPush(FOLLOW_general_element_part_in_bind_variable3871);
            	        general_element_part242=general_element_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            general_element_part242_last = general_element_part242.tree.get();
            	            stream_general_element_part.add(general_element_part242.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop74;	/* break out of the loop */
            	    break;
                }
            }
            loop74: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: general_element_part, u2, b1, b2, u1, indicator_key
            // token labels: u2, u1, b1, b2
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleTokenStream<ImplTraits> stream_u2(get_psrstate()->get_treeAdaptor(), "token u2",u2);
            RewriteRuleTokenStream<ImplTraits> stream_u1(get_psrstate()->get_treeAdaptor(), "token u1",u1);
            RewriteRuleTokenStream<ImplTraits> stream_b1(get_psrstate()->get_treeAdaptor(), "token b1",b1);
            RewriteRuleTokenStream<ImplTraits> stream_b2(get_psrstate()->get_treeAdaptor(), "token b2",b2);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 441:10: -> ^( HOSTED_VARIABLE_NAME ( $b1)? ( $u1)? ( indicator_key )? ( $b2)? ( $u2)? ( general_element_part )* )
            {
            	// OracleDMLCommons.g:441:12: ^( HOSTED_VARIABLE_NAME ( $b1)? ( $u1)? ( indicator_key )? ( $b2)? ( $u2)? ( general_element_part )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(HOSTED_VARIABLE_NAME, "HOSTED_VARIABLE_NAME"), root_1);
            	// OracleDMLCommons.g:441:36: ( $b1)?
            	if ( stream_b1.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_b1.nextNode());
            	}
            	stream_b1.reset();

            	// OracleDMLCommons.g:441:41: ( $u1)?
            	if ( stream_u1.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_u1.nextNode());
            	}
            	stream_u1.reset();

            	// OracleDMLCommons.g:441:45: ( indicator_key )?
            	if ( stream_indicator_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_indicator_key.nextTree());
            	}
            	stream_indicator_key.reset();

            	// OracleDMLCommons.g:441:61: ( $b2)?
            	if ( stream_b2.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_b2.nextNode());
            	}
            	stream_b2.reset();

            	// OracleDMLCommons.g:441:66: ( $u2)?
            	if ( stream_u2.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_u2.nextNode());
            	}
            	stream_u2.reset();

            	// OracleDMLCommons.g:441:70: ( general_element_part )*
            	while ( stream_general_element_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_general_element_part.nextTree());
            	}
            	stream_general_element_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebind_variableEx; /* Prevent compiler warnings */
    rulebind_variableEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end bind_variable */

/**
 * $ANTLR start general_element
 * OracleDMLCommons.g:444:1: general_element : general_element_part ( ( PERIOD general_element_part )=> PERIOD general_element_part )* -> {isCascated}? ^( CASCATED_ELEMENT ( general_element_part )+ ) -> general_element_part ;
 */
OracleDML_OracleDMLCommons::general_element_return
OracleDML_OracleDMLCommons::general_element()
{
    OracleDML_OracleDMLCommons::general_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD244 = NULL;
    OracleDML_OracleDMLCommons::general_element_part_return general_element_part243;
    ImplTraits::TreeTypePtr::pointer general_element_part243_last = NULL;
    OracleDML_OracleDMLCommons::general_element_part_return general_element_part245;
    ImplTraits::TreeTypePtr::pointer general_element_part245_last = NULL;
    ImplTraits::TreeTypePtr PERIOD244_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_general_element_part(get_psrstate()->get_treeAdaptor(), "rule general_element_part");

    /* Initialize rule variables
     */

     int isCascated = true; 
    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:446:5: ( general_element_part ( ( PERIOD general_element_part )=> PERIOD general_element_part )* -> {isCascated}? ^( CASCATED_ELEMENT ( general_element_part )+ ) -> general_element_part )
        // OracleDMLCommons.g:446:10: general_element_part ( ( PERIOD general_element_part )=> PERIOD general_element_part )*
        {
            this->followPush(FOLLOW_general_element_part_in_general_element3937);
            general_element_part243=general_element_part();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegeneral_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                general_element_part243_last = general_element_part243.tree.get();
                stream_general_element_part.add(general_element_part243.tree);
            }

            // OracleDMLCommons.g:446:31: ( ( PERIOD general_element_part )=> PERIOD general_element_part )*

            for (;;)
            {
                ANTLR_UINT32 alt75=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    ANTLR_UINT32 LA75_0 = this->LA(1);
                    if ( (LA75_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred21_OracleDMLCommons>() )))
                    {
                        alt75=1;
                    }

                }
                switch (alt75)
                {
            	case 1:
            	    // OracleDMLCommons.g:446:32: ( PERIOD general_element_part )=> PERIOD general_element_part
            	    {
            	        PERIOD244 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_general_element3947);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD244);


            	        this->followPush(FOLLOW_general_element_part_in_general_element3949);
            	        general_element_part245=general_element_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            general_element_part245_last = general_element_part245.tree.get();
            	            stream_general_element_part.add(general_element_part245.tree);
            	        }

            	        if ( this->get_backtracking()==0 )
            	        {
            	            isCascated = true;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop75;	/* break out of the loop */
            	    break;
                }
            }
            loop75: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: general_element_part, general_element_part
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 447:9: -> {isCascated}? ^( CASCATED_ELEMENT ( general_element_part )+ )
            if (isCascated) {
            	// OracleDMLCommons.g:447:25: ^( CASCATED_ELEMENT ( general_element_part )+ )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(CASCATED_ELEMENT, "CASCATED_ELEMENT"), root_1);
            	if ( !(stream_general_element_part.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "general_element_part empty" );
            		goto rulegeneral_elementEx;
            	}
            	while ( stream_general_element_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_general_element_part.nextTree());
            	}
            	stream_general_element_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 448:9: -> general_element_part
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, stream_general_element_part.nextTree());
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulegeneral_elementEx; /* Prevent compiler warnings */
    rulegeneral_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end general_element */

/**
 * $ANTLR start general_element_part
 * OracleDMLCommons.g:451:1: general_element_part : ( INTRODUCER char_set_name )? id_expression[T_COLUMN_NAME,T_USE] ( ( PERIOD id_expression[T_COLUMN_NAME,T_USE] )=> PERIOD id_expression[T_COLUMN_NAME,T_USE] )* ( function_argument )? -> {isRoutineCall}? ^( ROUTINE_CALL ^( ROUTINE_NAME ( char_set_name )? ( id_expression )+ ) function_argument ) -> ^( ANY_ELEMENT ( char_set_name )? ( id_expression )+ ) ;
 */
OracleDML_OracleDMLCommons::general_element_part_return
OracleDML_OracleDMLCommons::general_element_part()
{
    OracleDML_OracleDMLCommons::general_element_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* INTRODUCER246 = NULL;
    ImplTraits::CommonTokenType const* PERIOD249 = NULL;
    OracleDML_OracleDMLCommons::char_set_name_return char_set_name247;
    ImplTraits::TreeTypePtr::pointer char_set_name247_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression248;
    ImplTraits::TreeTypePtr::pointer id_expression248_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression250;
    ImplTraits::TreeTypePtr::pointer id_expression250_last = NULL;
    OracleDML_OracleDMLCommons::function_argument_return function_argument251;
    ImplTraits::TreeTypePtr::pointer function_argument251_last = NULL;
    ImplTraits::TreeTypePtr INTRODUCER246_tree;
    ImplTraits::TreeTypePtr PERIOD249_tree;
    RewriteRuleTokenStream<ImplTraits> stream_INTRODUCER(get_psrstate()->get_treeAdaptor(), "token INTRODUCER");
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_function_argument(get_psrstate()->get_treeAdaptor(), "rule function_argument");
    RewriteRuleSubtreeStream<ImplTraits> stream_char_set_name(get_psrstate()->get_treeAdaptor(), "rule char_set_name");

    /* Initialize rule variables
     */

     int isRoutineCall = false; 
    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:453:5: ( ( INTRODUCER char_set_name )? id_expression[T_COLUMN_NAME,T_USE] ( ( PERIOD id_expression[T_COLUMN_NAME,T_USE] )=> PERIOD id_expression[T_COLUMN_NAME,T_USE] )* ( function_argument )? -> {isRoutineCall}? ^( ROUTINE_CALL ^( ROUTINE_NAME ( char_set_name )? ( id_expression )+ ) function_argument ) -> ^( ANY_ELEMENT ( char_set_name )? ( id_expression )+ ) )
        // OracleDMLCommons.g:453:10: ( INTRODUCER char_set_name )? id_expression[T_COLUMN_NAME,T_USE] ( ( PERIOD id_expression[T_COLUMN_NAME,T_USE] )=> PERIOD id_expression[T_COLUMN_NAME,T_USE] )* ( function_argument )?
        {
            // OracleDMLCommons.g:453:10: ( INTRODUCER char_set_name )?
            {
                ANTLR_UINT32 alt76=2;
                switch ( this->LA(1) )
                {
                    case INTRODUCER:
                    	{
                    		alt76=1;
                    	}
                        break;
                }

                switch (alt76)
                {
            	case 1:
            	    // OracleDMLCommons.g:453:11: INTRODUCER char_set_name
            	    {
            	        INTRODUCER246 =  this->matchToken(INTRODUCER, &FOLLOW_INTRODUCER_in_general_element_part4012);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_INTRODUCER.add(INTRODUCER246);


            	        this->followPush(FOLLOW_char_set_name_in_general_element_part4014);
            	        char_set_name247=char_set_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            char_set_name247_last = char_set_name247.tree.get();
            	            stream_char_set_name.add(char_set_name247.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_id_expression_in_general_element_part4018);
            id_expression248=id_expression(T_COLUMN_NAME, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto rulegeneral_element_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id_expression248_last = id_expression248.tree.get();
                stream_id_expression.add(id_expression248.tree);
            }

            // OracleDMLCommons.g:454:13: ( ( PERIOD id_expression[T_COLUMN_NAME,T_USE] )=> PERIOD id_expression[T_COLUMN_NAME,T_USE] )*

            for (;;)
            {
                ANTLR_UINT32 alt77=2;
                switch ( this->LA(1) )
                {
                case PERIOD:
                	{
                		switch ( this->LA(2) )
                		{
                		case REGULAR_ID:
                			{
                				{
                				   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                				    */
                				    ANTLR_UINT32 LA77_3 = this->LA(3);
                				    if ( (this->msynpred( antlr3::ClassForwarder<synpred22_OracleDMLCommons>() )))
                				    {
                				        alt77=1;
                				    }

                				}
                			}
                		    break;
                		case DELIMITED_ID:
                			{
                				{
                				   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                				    */
                				    ANTLR_UINT32 LA77_4 = this->LA(3);
                				    if ( (this->msynpred( antlr3::ClassForwarder<synpred22_OracleDMLCommons>() )))
                				    {
                				        alt77=1;
                				    }

                				}
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt77)
                {
            	case 1:
            	    // OracleDMLCommons.g:454:14: ( PERIOD id_expression[T_COLUMN_NAME,T_USE] )=> PERIOD id_expression[T_COLUMN_NAME,T_USE]
            	    {
            	        PERIOD249 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_general_element_part4042);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD249);


            	        this->followPush(FOLLOW_id_expression_in_general_element_part4044);
            	        id_expression250=id_expression(T_COLUMN_NAME, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression250_last = id_expression250.tree.get();
            	            stream_id_expression.add(id_expression250.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop77;	/* break out of the loop */
            	    break;
                }
            }
            loop77: ; /* Jump out to here if this rule does not match */


            // OracleDMLCommons.g:454:104: ( function_argument )?
            {
                ANTLR_UINT32 alt78=2;
                switch ( this->LA(1) )
                {
                    case LEFT_PAREN:
                    	{
                    		alt78=1;
                    	}
                        break;
                }

                switch (alt78)
                {
            	case 1:
            	    // OracleDMLCommons.g:454:105: function_argument
            	    {
            	        this->followPush(FOLLOW_function_argument_in_general_element_part4050);
            	        function_argument251=function_argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            function_argument251_last = function_argument251.tree.get();
            	            stream_function_argument.add(function_argument251.tree);
            	        }

            	        if ( this->get_backtracking()==0 )
            	        {
            	            isRoutineCall = true;
            	        }


            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: char_set_name, function_argument, id_expression, char_set_name, id_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 455:9: -> {isRoutineCall}? ^( ROUTINE_CALL ^( ROUTINE_NAME ( char_set_name )? ( id_expression )+ ) function_argument )
            if (isRoutineCall) {
            	// OracleDMLCommons.g:455:28: ^( ROUTINE_CALL ^( ROUTINE_NAME ( char_set_name )? ( id_expression )+ ) function_argument )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ROUTINE_CALL, "ROUTINE_CALL"), root_1);
            	// OracleDMLCommons.g:455:43: ^( ROUTINE_NAME ( char_set_name )? ( id_expression )+ )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ROUTINE_NAME, "ROUTINE_NAME"), root_2);
            	// OracleDMLCommons.g:455:58: ( char_set_name )?
            	if ( stream_char_set_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_char_set_name.nextTree());
            	}
            	stream_char_set_name.reset();

            	if ( !(stream_id_expression.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "id_expression empty" );
            		goto rulegeneral_element_partEx;
            	}
            	while ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_function_argument.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 456:9: -> ^( ANY_ELEMENT ( char_set_name )? ( id_expression )+ )
            {
            	// OracleDMLCommons.g:456:12: ^( ANY_ELEMENT ( char_set_name )? ( id_expression )+ )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ANY_ELEMENT, "ANY_ELEMENT"), root_1);
            	// OracleDMLCommons.g:456:26: ( char_set_name )?
            	if ( stream_char_set_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_char_set_name.nextTree());
            	}
            	stream_char_set_name.reset();

            	if ( !(stream_id_expression.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "id_expression empty" );
            		goto rulegeneral_element_partEx;
            	}
            	while ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulegeneral_element_partEx; /* Prevent compiler warnings */
    rulegeneral_element_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end general_element_part */

/**
 * $ANTLR start table_element
 * OracleDMLCommons.g:459:1: table_element : ( INTRODUCER char_set_name )? id_expression[T_COLUMN_NAME,T_USE] ( PERIOD id_expression[T_COLUMN_NAME,T_USE] )* -> ^( ANY_ELEMENT ( char_set_name )? ( id_expression )+ ) ;
 */
OracleDML_OracleDMLCommons::table_element_return
OracleDML_OracleDMLCommons::table_element()
{
    OracleDML_OracleDMLCommons::table_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* INTRODUCER252 = NULL;
    ImplTraits::CommonTokenType const* PERIOD255 = NULL;
    OracleDML_OracleDMLCommons::char_set_name_return char_set_name253;
    ImplTraits::TreeTypePtr::pointer char_set_name253_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression254;
    ImplTraits::TreeTypePtr::pointer id_expression254_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression256;
    ImplTraits::TreeTypePtr::pointer id_expression256_last = NULL;
    ImplTraits::TreeTypePtr INTRODUCER252_tree;
    ImplTraits::TreeTypePtr PERIOD255_tree;
    RewriteRuleTokenStream<ImplTraits> stream_INTRODUCER(get_psrstate()->get_treeAdaptor(), "token INTRODUCER");
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_char_set_name(get_psrstate()->get_treeAdaptor(), "rule char_set_name");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:460:5: ( ( INTRODUCER char_set_name )? id_expression[T_COLUMN_NAME,T_USE] ( PERIOD id_expression[T_COLUMN_NAME,T_USE] )* -> ^( ANY_ELEMENT ( char_set_name )? ( id_expression )+ ) )
        // OracleDMLCommons.g:460:10: ( INTRODUCER char_set_name )? id_expression[T_COLUMN_NAME,T_USE] ( PERIOD id_expression[T_COLUMN_NAME,T_USE] )*
        {
            // OracleDMLCommons.g:460:10: ( INTRODUCER char_set_name )?
            {
                ANTLR_UINT32 alt79=2;
                switch ( this->LA(1) )
                {
                    case INTRODUCER:
                    	{
                    		alt79=1;
                    	}
                        break;
                }

                switch (alt79)
                {
            	case 1:
            	    // OracleDMLCommons.g:460:11: INTRODUCER char_set_name
            	    {
            	        INTRODUCER252 =  this->matchToken(INTRODUCER, &FOLLOW_INTRODUCER_in_table_element4122);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_INTRODUCER.add(INTRODUCER252);


            	        this->followPush(FOLLOW_char_set_name_in_table_element4124);
            	        char_set_name253=char_set_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            char_set_name253_last = char_set_name253.tree.get();
            	            stream_char_set_name.add(char_set_name253.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_id_expression_in_table_element4128);
            id_expression254=id_expression(T_COLUMN_NAME, T_USE);

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                id_expression254_last = id_expression254.tree.get();
                stream_id_expression.add(id_expression254.tree);
            }

            // OracleDMLCommons.g:460:73: ( PERIOD id_expression[T_COLUMN_NAME,T_USE] )*

            for (;;)
            {
                ANTLR_UINT32 alt80=2;
                switch ( this->LA(1) )
                {
                case PERIOD:
                	{
                		alt80=1;
                	}
                    break;

                }

                switch (alt80)
                {
            	case 1:
            	    // OracleDMLCommons.g:460:74: PERIOD id_expression[T_COLUMN_NAME,T_USE]
            	    {
            	        PERIOD255 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_table_element4132);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD255);


            	        this->followPush(FOLLOW_id_expression_in_table_element4134);
            	        id_expression256=id_expression(T_COLUMN_NAME, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id_expression256_last = id_expression256.tree.get();
            	            stream_id_expression.add(id_expression256.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop80;	/* break out of the loop */
            	    break;
                }
            }
            loop80: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: id_expression, char_set_name
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 461:10: -> ^( ANY_ELEMENT ( char_set_name )? ( id_expression )+ )
            {
            	// OracleDMLCommons.g:461:13: ^( ANY_ELEMENT ( char_set_name )? ( id_expression )+ )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ANY_ELEMENT, "ANY_ELEMENT"), root_1);
            	// OracleDMLCommons.g:461:27: ( char_set_name )?
            	if ( stream_char_set_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_char_set_name.nextTree());
            	}
            	stream_char_set_name.reset();

            	if ( !(stream_id_expression.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "id_expression empty" );
            		goto ruletable_elementEx;
            	}
            	while ( stream_id_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_id_expression.nextTree());
            	}
            	stream_id_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletable_elementEx; /* Prevent compiler warnings */
    ruletable_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end table_element */

/**
 * $ANTLR start constant
 * OracleDMLCommons.g:468:1: constant : ( timestamp_key ( quoted_string | bind_variable ) ( at_key time_key zone_key quoted_string )? | interval_key ( quoted_string | bind_variable | general_element_part ) ( day_key | hour_key | minute_key | second_key ) ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN )? ( to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? ) )? | numeric | date_key quoted_string | quoted_string | null_key | true_key | false_key | dbtimezone_key | sessiontimezone_key | minvalue_key | maxvalue_key | default_key );
 */
OracleDML_OracleDMLCommons::constant_return
OracleDML_OracleDMLCommons::constant()
{
    OracleDML_OracleDMLCommons::constant_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN272 = NULL;
    ImplTraits::CommonTokenType const* UNSIGNED_INTEGER273 = NULL;
    ImplTraits::CommonTokenType const* COMMA275 = NULL;
    ImplTraits::CommonTokenType const* UNSIGNED_INTEGER276 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN278 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN284 = NULL;
    ImplTraits::CommonTokenType const* UNSIGNED_INTEGER285 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN287 = NULL;
    OracleDML_OracleDMLKeys::timestamp_key_return timestamp_key257;
    ImplTraits::TreeTypePtr::pointer timestamp_key257_last = NULL;
    OracleDML_OracleDMLCommons::quoted_string_return quoted_string258;
    ImplTraits::TreeTypePtr::pointer quoted_string258_last = NULL;
    OracleDML_OracleDMLCommons::bind_variable_return bind_variable259;
    ImplTraits::TreeTypePtr::pointer bind_variable259_last = NULL;
    OracleDML_OracleDMLKeys::at_key_return at_key260;
    ImplTraits::TreeTypePtr::pointer at_key260_last = NULL;
    OracleDML_OracleDMLKeys::time_key_return time_key261;
    ImplTraits::TreeTypePtr::pointer time_key261_last = NULL;
    OracleDML_OracleDMLKeys::zone_key_return zone_key262;
    ImplTraits::TreeTypePtr::pointer zone_key262_last = NULL;
    OracleDML_OracleDMLCommons::quoted_string_return quoted_string263;
    ImplTraits::TreeTypePtr::pointer quoted_string263_last = NULL;
    OracleDML_OracleDMLKeys::interval_key_return interval_key264;
    ImplTraits::TreeTypePtr::pointer interval_key264_last = NULL;
    OracleDML_OracleDMLCommons::quoted_string_return quoted_string265;
    ImplTraits::TreeTypePtr::pointer quoted_string265_last = NULL;
    OracleDML_OracleDMLCommons::bind_variable_return bind_variable266;
    ImplTraits::TreeTypePtr::pointer bind_variable266_last = NULL;
    OracleDML_OracleDMLCommons::general_element_part_return general_element_part267;
    ImplTraits::TreeTypePtr::pointer general_element_part267_last = NULL;
    OracleDML_OracleDMLKeys::day_key_return day_key268;
    ImplTraits::TreeTypePtr::pointer day_key268_last = NULL;
    OracleDML_OracleDMLKeys::hour_key_return hour_key269;
    ImplTraits::TreeTypePtr::pointer hour_key269_last = NULL;
    OracleDML_OracleDMLKeys::minute_key_return minute_key270;
    ImplTraits::TreeTypePtr::pointer minute_key270_last = NULL;
    OracleDML_OracleDMLKeys::second_key_return second_key271;
    ImplTraits::TreeTypePtr::pointer second_key271_last = NULL;
    OracleDML_OracleDMLCommons::bind_variable_return bind_variable274;
    ImplTraits::TreeTypePtr::pointer bind_variable274_last = NULL;
    OracleDML_OracleDMLCommons::bind_variable_return bind_variable277;
    ImplTraits::TreeTypePtr::pointer bind_variable277_last = NULL;
    OracleDML_OracleDMLKeys::to_key_return to_key279;
    ImplTraits::TreeTypePtr::pointer to_key279_last = NULL;
    OracleDML_OracleDMLKeys::day_key_return day_key280;
    ImplTraits::TreeTypePtr::pointer day_key280_last = NULL;
    OracleDML_OracleDMLKeys::hour_key_return hour_key281;
    ImplTraits::TreeTypePtr::pointer hour_key281_last = NULL;
    OracleDML_OracleDMLKeys::minute_key_return minute_key282;
    ImplTraits::TreeTypePtr::pointer minute_key282_last = NULL;
    OracleDML_OracleDMLKeys::second_key_return second_key283;
    ImplTraits::TreeTypePtr::pointer second_key283_last = NULL;
    OracleDML_OracleDMLCommons::bind_variable_return bind_variable286;
    ImplTraits::TreeTypePtr::pointer bind_variable286_last = NULL;
    OracleDML_OracleDMLCommons::numeric_return numeric288;
    ImplTraits::TreeTypePtr::pointer numeric288_last = NULL;
    OracleDML_OracleDMLKeys::date_key_return date_key289;
    ImplTraits::TreeTypePtr::pointer date_key289_last = NULL;
    OracleDML_OracleDMLCommons::quoted_string_return quoted_string290;
    ImplTraits::TreeTypePtr::pointer quoted_string290_last = NULL;
    OracleDML_OracleDMLCommons::quoted_string_return quoted_string291;
    ImplTraits::TreeTypePtr::pointer quoted_string291_last = NULL;
    OracleDML_OracleDMLKeys::null_key_return null_key292;
    ImplTraits::TreeTypePtr::pointer null_key292_last = NULL;
    OracleDML_OracleDMLKeys::true_key_return true_key293;
    ImplTraits::TreeTypePtr::pointer true_key293_last = NULL;
    OracleDML_OracleDMLKeys::false_key_return false_key294;
    ImplTraits::TreeTypePtr::pointer false_key294_last = NULL;
    OracleDML_OracleDMLKeys::dbtimezone_key_return dbtimezone_key295;
    ImplTraits::TreeTypePtr::pointer dbtimezone_key295_last = NULL;
    OracleDML_OracleDMLKeys::sessiontimezone_key_return sessiontimezone_key296;
    ImplTraits::TreeTypePtr::pointer sessiontimezone_key296_last = NULL;
    OracleDML_OracleDMLKeys::minvalue_key_return minvalue_key297;
    ImplTraits::TreeTypePtr::pointer minvalue_key297_last = NULL;
    OracleDML_OracleDMLKeys::maxvalue_key_return maxvalue_key298;
    ImplTraits::TreeTypePtr::pointer maxvalue_key298_last = NULL;
    OracleDML_OracleDMLKeys::default_key_return default_key299;
    ImplTraits::TreeTypePtr::pointer default_key299_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN272_tree;
    ImplTraits::TreeTypePtr UNSIGNED_INTEGER273_tree;
    ImplTraits::TreeTypePtr COMMA275_tree;
    ImplTraits::TreeTypePtr UNSIGNED_INTEGER276_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN278_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN284_tree;
    ImplTraits::TreeTypePtr UNSIGNED_INTEGER285_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN287_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDMLCommons.g:469:5: ( timestamp_key ( quoted_string | bind_variable ) ( at_key time_key zone_key quoted_string )? | interval_key ( quoted_string | bind_variable | general_element_part ) ( day_key | hour_key | minute_key | second_key ) ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN )? ( to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? ) )? | numeric | date_key quoted_string | quoted_string | null_key | true_key | false_key | dbtimezone_key | sessiontimezone_key | minvalue_key | maxvalue_key | default_key )

            ANTLR_UINT32 alt93;

            alt93=13;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    ANTLR_UINT32 LA93_1 = this->LA(2);
            		    if ( ((toUpper(LT(1)->getText()) == "TIMESTAMP")))
            		    {
            		        alt93=1;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "INTERVAL")))
            		    {
            		        alt93=2;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "DBTIMEZONE")))
            		    {
            		        alt93=9;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "SESSIONTIMEZONE")))
            		    {
            		        alt93=10;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "MINVALUE")))
            		    {
            		        alt93=11;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "MAXVALUE")))
            		    {
            		        alt93=12;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 93 );
            		        ex->set_state( 1 );


            		        goto ruleconstantEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case EXACT_NUM_LIT:
            case UNSIGNED_INTEGER:
            	{
            		alt93=3;
            	}
                break;
            case SQL92_RESERVED_DATE:
            	{
            		alt93=4;
            	}
                break;
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case NATIONAL_CHAR_STRING_LIT:
            	{
            		alt93=5;
            	}
                break;
            case SQL92_RESERVED_NULL:
            	{
            		alt93=6;
            	}
                break;
            case SQL92_RESERVED_TRUE:
            	{
            		alt93=7;
            	}
                break;
            case SQL92_RESERVED_FALSE:
            	{
            		alt93=8;
            	}
                break;
            case SQL92_RESERVED_DEFAULT:
            	{
            		alt93=13;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 93 );
                ex->set_state( 0 );


                goto ruleconstantEx;

            }

            switch (alt93)
            {
        	case 1:
        	    // OracleDMLCommons.g:469:10: timestamp_key ( quoted_string | bind_variable ) ( at_key time_key zone_key quoted_string )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_timestamp_key_in_constant4182);
        	        timestamp_key257=m_gOracleDML->timestamp_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, timestamp_key257.tree);


        	        // OracleDMLCommons.g:469:24: ( quoted_string | bind_variable )
        	        {
        	            ANTLR_UINT32 alt81=2;
        	            switch ( this->LA(1) )
        	            {
        	            case CHAR_STRING:
        	            case CHAR_STRING_PERL:
        	            case NATIONAL_CHAR_STRING_LIT:
        	            	{
        	            		alt81=1;
        	            	}
        	                break;
        	            case BINDVAR:
        	            case COLON:
        	            	{
        	            		alt81=2;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return retval;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 81 );
        	                ex->set_state( 0 );


        	                goto ruleconstantEx;

        	            }

        	            switch (alt81)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:469:25: quoted_string
        	        	    {
        	        	        this->followPush(FOLLOW_quoted_string_in_constant4185);
        	        	        quoted_string258=quoted_string();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, quoted_string258.tree);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDMLCommons.g:469:41: bind_variable
        	        	    {
        	        	        this->followPush(FOLLOW_bind_variable_in_constant4189);
        	        	        bind_variable259=bind_variable();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, bind_variable259.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDMLCommons.g:469:56: ( at_key time_key zone_key quoted_string )?
        	        {
        	            ANTLR_UINT32 alt82=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		switch ( this->LA(2) )
        	                		{
        	                		    case REGULAR_ID:
        	                		    	{
        	                		    		switch ( this->LA(3) )
        	                		    		{
        	                		    		    case REGULAR_ID:
        	                		    		    	{
        	                		    		    		switch ( this->LA(4) )
        	                		    		    		{
        	                		    		    		    case CHAR_STRING:
        	                		    		    		    case CHAR_STRING_PERL:
        	                		    		    		    case NATIONAL_CHAR_STRING_LIT:
        	                		    		    		    	{
        	                		    		    		    		{
        	                		    		    		    		    ANTLR_UINT32 LA82_15 = this->LA(5);
        	                		    		    		    		    if ( ((toUpper(LT(1)->getText()) == "AT")))
        	                		    		    		    		    {
        	                		    		    		    		        alt82=1;
        	                		    		    		    		    }
        	                		    		    		    		}
        	                		    		    		    	}
        	                		    		    		        break;
        	                		    		    		}

        	                		    		    	}
        	                		    		        break;
        	                		    		}

        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt82)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:469:57: at_key time_key zone_key quoted_string
        	        	    {
        	        	        this->followPush(FOLLOW_at_key_in_constant4193);
        	        	        at_key260=m_gOracleDML->at_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, at_key260.tree);


        	        	        this->followPush(FOLLOW_time_key_in_constant4195);
        	        	        time_key261=m_gOracleDML->time_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, time_key261.tree);


        	        	        this->followPush(FOLLOW_zone_key_in_constant4197);
        	        	        zone_key262=m_gOracleDML->zone_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, zone_key262.tree);


        	        	        this->followPush(FOLLOW_quoted_string_in_constant4199);
        	        	        quoted_string263=quoted_string();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, quoted_string263.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:470:10: interval_key ( quoted_string | bind_variable | general_element_part ) ( day_key | hour_key | minute_key | second_key ) ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN )? ( to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? ) )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_interval_key_in_constant4212);
        	        interval_key264=m_gOracleDML->interval_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, interval_key264.tree);


        	        // OracleDMLCommons.g:470:23: ( quoted_string | bind_variable | general_element_part )
        	        {
        	            ANTLR_UINT32 alt83=3;
        	            switch ( this->LA(1) )
        	            {
        	            case CHAR_STRING:
        	            case CHAR_STRING_PERL:
        	            case NATIONAL_CHAR_STRING_LIT:
        	            	{
        	            		alt83=1;
        	            	}
        	                break;
        	            case BINDVAR:
        	            case COLON:
        	            	{
        	            		alt83=2;
        	            	}
        	                break;
        	            case DELIMITED_ID:
        	            case INTRODUCER:
        	            case REGULAR_ID:
        	            	{
        	            		alt83=3;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return retval;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 83 );
        	                ex->set_state( 0 );


        	                goto ruleconstantEx;

        	            }

        	            switch (alt83)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:470:24: quoted_string
        	        	    {
        	        	        this->followPush(FOLLOW_quoted_string_in_constant4215);
        	        	        quoted_string265=quoted_string();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, quoted_string265.tree);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDMLCommons.g:470:40: bind_variable
        	        	    {
        	        	        this->followPush(FOLLOW_bind_variable_in_constant4219);
        	        	        bind_variable266=bind_variable();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, bind_variable266.tree);


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // OracleDMLCommons.g:470:56: general_element_part
        	        	    {
        	        	        this->followPush(FOLLOW_general_element_part_in_constant4223);
        	        	        general_element_part267=general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, general_element_part267.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDMLCommons.g:471:10: ( day_key | hour_key | minute_key | second_key )
        	        {
        	            ANTLR_UINT32 alt84=4;
        	            switch ( this->LA(1) )
        	            {
        	            case REGULAR_ID:
        	            	{
        	            		{
        	            		    ANTLR_UINT32 LA84_1 = this->LA(2);
        	            		    if ( ((toUpper(LT(1)->getText()) == "DAY")))
        	            		    {
        	            		        alt84=1;
        	            		    }
        	            		    else if ( ((toUpper(LT(1)->getText()) == "HOUR")))
        	            		    {
        	            		        alt84=2;
        	            		    }
        	            		    else if ( ((toUpper(LT(1)->getText()) == "MINUTE")))
        	            		    {
        	            		        alt84=3;
        	            		    }
        	            		    else if ( ((toUpper(LT(1)->getText()) == "SECOND")))
        	            		    {
        	            		        alt84=4;
        	            		    }
        	            		    else
        	            		    {
        	            		        if (this->get_backtracking()>0)
        	            		        {
        	            		            this->set_failedflag( true );
        	            		            return retval;
        	            		        }


        	            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            		        ex->set_decisionNum( 84 );
        	            		        ex->set_state( 1 );


        	            		        goto ruleconstantEx;

        	            		    }
        	            		}
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return retval;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 84 );
        	                ex->set_state( 0 );


        	                goto ruleconstantEx;

        	            }

        	            switch (alt84)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:471:12: day_key
        	        	    {
        	        	        this->followPush(FOLLOW_day_key_in_constant4237);
        	        	        day_key268=m_gOracleDML->day_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, day_key268.tree);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDMLCommons.g:471:22: hour_key
        	        	    {
        	        	        this->followPush(FOLLOW_hour_key_in_constant4241);
        	        	        hour_key269=m_gOracleDML->hour_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, hour_key269.tree);


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // OracleDMLCommons.g:471:33: minute_key
        	        	    {
        	        	        this->followPush(FOLLOW_minute_key_in_constant4245);
        	        	        minute_key270=m_gOracleDML->minute_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, minute_key270.tree);


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // OracleDMLCommons.g:471:46: second_key
        	        	    {
        	        	        this->followPush(FOLLOW_second_key_in_constant4249);
        	        	        second_key271=m_gOracleDML->second_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, second_key271.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDMLCommons.g:472:10: ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN )?
        	        {
        	            ANTLR_UINT32 alt88=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		alt88=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt88)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:472:12: LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN
        	        	    {
        	        	        LEFT_PAREN272 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_constant4263);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        LEFT_PAREN272_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN272));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN272_tree);
        	        	        }


        	        	        // OracleDMLCommons.g:472:23: ( UNSIGNED_INTEGER | bind_variable )
        	        	        {
        	        	            ANTLR_UINT32 alt85=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	            case UNSIGNED_INTEGER:
        	        	            	{
        	        	            		alt85=1;
        	        	            	}
        	        	                break;
        	        	            case BINDVAR:
        	        	            case COLON:
        	        	            	{
        	        	            		alt85=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (this->get_backtracking()>0)
        	        	                {
        	        	                    this->set_failedflag( true );
        	        	                    return retval;
        	        	                }

        	        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                ex->set_decisionNum( 85 );
        	        	                ex->set_state( 0 );


        	        	                goto ruleconstantEx;

        	        	            }

        	        	            switch (alt85)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDMLCommons.g:472:24: UNSIGNED_INTEGER
        	        	        	    {
        	        	        	        UNSIGNED_INTEGER273 =  this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_constant4266);
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) {
        	        	        	        UNSIGNED_INTEGER273_tree = std::move(get_psrstate()->get_treeAdaptor()->create(UNSIGNED_INTEGER273));
        	        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, UNSIGNED_INTEGER273_tree);
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // OracleDMLCommons.g:472:43: bind_variable
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_bind_variable_in_constant4270);
        	        	        	        bind_variable274=bind_variable();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, bind_variable274.tree);


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        // OracleDMLCommons.g:472:58: ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )?
        	        	        {
        	        	            ANTLR_UINT32 alt87=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case COMMA:
        	        	                	{
        	        	                		alt87=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt87)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDMLCommons.g:472:59: COMMA ( UNSIGNED_INTEGER | bind_variable )
        	        	        	    {
        	        	        	        COMMA275 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_constant4274);
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) {
        	        	        	        COMMA275_tree = std::move(get_psrstate()->get_treeAdaptor()->create(COMMA275));
        	        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, COMMA275_tree);
        	        	        	        }


        	        	        	        // OracleDMLCommons.g:472:65: ( UNSIGNED_INTEGER | bind_variable )
        	        	        	        {
        	        	        	            ANTLR_UINT32 alt86=2;
        	        	        	            switch ( this->LA(1) )
        	        	        	            {
        	        	        	            case UNSIGNED_INTEGER:
        	        	        	            	{
        	        	        	            		alt86=1;
        	        	        	            	}
        	        	        	                break;
        	        	        	            case BINDVAR:
        	        	        	            case COLON:
        	        	        	            	{
        	        	        	            		alt86=2;
        	        	        	            	}
        	        	        	                break;

        	        	        	            default:
        	        	        	                if (this->get_backtracking()>0)
        	        	        	                {
        	        	        	                    this->set_failedflag( true );
        	        	        	                    return retval;
        	        	        	                }

        	        	        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	        	                ex->set_decisionNum( 86 );
        	        	        	                ex->set_state( 0 );


        	        	        	                goto ruleconstantEx;

        	        	        	            }

        	        	        	            switch (alt86)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // OracleDMLCommons.g:472:66: UNSIGNED_INTEGER
        	        	        	        	    {
        	        	        	        	        UNSIGNED_INTEGER276 =  this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_constant4277);
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return retval;
        	        	        	        	        }

        	        	        	        	        if ( this->get_backtracking()==0 ) {
        	        	        	        	        UNSIGNED_INTEGER276_tree = std::move(get_psrstate()->get_treeAdaptor()->create(UNSIGNED_INTEGER276));
        	        	        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, UNSIGNED_INTEGER276_tree);
        	        	        	        	        }


        	        	        	        	    }
        	        	        	        	    break;
        	        	        	        	case 2:
        	        	        	        	    // OracleDMLCommons.g:472:85: bind_variable
        	        	        	        	    {
        	        	        	        	        this->followPush(FOLLOW_bind_variable_in_constant4281);
        	        	        	        	        bind_variable277=bind_variable();

        	        	        	        	        this->followPop();
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return retval;
        	        	        	        	        }

        	        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, bind_variable277.tree);


        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        RIGHT_PAREN278 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_constant4287);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        RIGHT_PAREN278_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN278));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN278_tree);
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDMLCommons.g:473:10: ( to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? ) )?
        	        {
        	            ANTLR_UINT32 alt92=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_TO:
        	                	{
        	                		alt92=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt92)
        	            {
        	        	case 1:
        	        	    // OracleDMLCommons.g:473:12: to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? )
        	        	    {
        	        	        this->followPush(FOLLOW_to_key_in_constant4302);
        	        	        to_key279=m_gOracleDML->to_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, to_key279.tree);


        	        	        // OracleDMLCommons.g:474:14: ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? )
        	        	        {
        	        	            ANTLR_UINT32 alt91=4;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	            case REGULAR_ID:
        	        	            	{
        	        	            		{
        	        	            		    ANTLR_UINT32 LA91_1 = this->LA(2);
        	        	            		    if ( ((toUpper(LT(1)->getText()) == "DAY")))
        	        	            		    {
        	        	            		        alt91=1;
        	        	            		    }
        	        	            		    else if ( ((toUpper(LT(1)->getText()) == "HOUR")))
        	        	            		    {
        	        	            		        alt91=2;
        	        	            		    }
        	        	            		    else if ( ((toUpper(LT(1)->getText()) == "MINUTE")))
        	        	            		    {
        	        	            		        alt91=3;
        	        	            		    }
        	        	            		    else if ( ((toUpper(LT(1)->getText()) == "SECOND")))
        	        	            		    {
        	        	            		        alt91=4;
        	        	            		    }
        	        	            		    else
        	        	            		    {
        	        	            		        if (this->get_backtracking()>0)
        	        	            		        {
        	        	            		            this->set_failedflag( true );
        	        	            		            return retval;
        	        	            		        }


        	        	            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	            		        ex->set_decisionNum( 91 );
        	        	            		        ex->set_state( 1 );


        	        	            		        goto ruleconstantEx;

        	        	            		    }
        	        	            		}
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (this->get_backtracking()>0)
        	        	                {
        	        	                    this->set_failedflag( true );
        	        	                    return retval;
        	        	                }

        	        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                ex->set_decisionNum( 91 );
        	        	                ex->set_state( 0 );


        	        	                goto ruleconstantEx;

        	        	            }

        	        	            switch (alt91)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDMLCommons.g:474:16: day_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_day_key_in_constant4319);
        	        	        	        day_key280=m_gOracleDML->day_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, day_key280.tree);


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // OracleDMLCommons.g:474:26: hour_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_hour_key_in_constant4323);
        	        	        	        hour_key281=m_gOracleDML->hour_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, hour_key281.tree);


        	        	        	    }
        	        	        	    break;
        	        	        	case 3:
        	        	        	    // OracleDMLCommons.g:474:37: minute_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_minute_key_in_constant4327);
        	        	        	        minute_key282=m_gOracleDML->minute_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, minute_key282.tree);


        	        	        	    }
        	        	        	    break;
        	        	        	case 4:
        	        	        	    // OracleDMLCommons.g:474:50: second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )?
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_second_key_in_constant4331);
        	        	        	        second_key283=m_gOracleDML->second_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, second_key283.tree);


        	        	        	        // OracleDMLCommons.g:474:61: ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )?
        	        	        	        {
        	        	        	            ANTLR_UINT32 alt90=2;
        	        	        	            switch ( this->LA(1) )
        	        	        	            {
        	        	        	                case LEFT_PAREN:
        	        	        	                	{
        	        	        	                		alt90=1;
        	        	        	                	}
        	        	        	                    break;
        	        	        	            }

        	        	        	            switch (alt90)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // OracleDMLCommons.g:474:62: LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN
        	        	        	        	    {
        	        	        	        	        LEFT_PAREN284 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_constant4334);
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return retval;
        	        	        	        	        }

        	        	        	        	        if ( this->get_backtracking()==0 ) {
        	        	        	        	        LEFT_PAREN284_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN284));
        	        	        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN284_tree);
        	        	        	        	        }


        	        	        	        	        // OracleDMLCommons.g:474:73: ( UNSIGNED_INTEGER | bind_variable )
        	        	        	        	        {
        	        	        	        	            ANTLR_UINT32 alt89=2;
        	        	        	        	            switch ( this->LA(1) )
        	        	        	        	            {
        	        	        	        	            case UNSIGNED_INTEGER:
        	        	        	        	            	{
        	        	        	        	            		alt89=1;
        	        	        	        	            	}
        	        	        	        	                break;
        	        	        	        	            case BINDVAR:
        	        	        	        	            case COLON:
        	        	        	        	            	{
        	        	        	        	            		alt89=2;
        	        	        	        	            	}
        	        	        	        	                break;

        	        	        	        	            default:
        	        	        	        	                if (this->get_backtracking()>0)
        	        	        	        	                {
        	        	        	        	                    this->set_failedflag( true );
        	        	        	        	                    return retval;
        	        	        	        	                }

        	        	        	        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	        	        	                ex->set_decisionNum( 89 );
        	        	        	        	                ex->set_state( 0 );


        	        	        	        	                goto ruleconstantEx;

        	        	        	        	            }

        	        	        	        	            switch (alt89)
        	        	        	        	            {
        	        	        	        	        	case 1:
        	        	        	        	        	    // OracleDMLCommons.g:474:74: UNSIGNED_INTEGER
        	        	        	        	        	    {
        	        	        	        	        	        UNSIGNED_INTEGER285 =  this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_constant4337);
        	        	        	        	        	        if  (this->hasException())
        	        	        	        	        	        {
        	        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        	        }
        	        	        	        	        	        if (this->hasFailed())
        	        	        	        	        	        {
        	        	        	        	        	            return retval;
        	        	        	        	        	        }

        	        	        	        	        	        if ( this->get_backtracking()==0 ) {
        	        	        	        	        	        UNSIGNED_INTEGER285_tree = std::move(get_psrstate()->get_treeAdaptor()->create(UNSIGNED_INTEGER285));
        	        	        	        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, UNSIGNED_INTEGER285_tree);
        	        	        	        	        	        }


        	        	        	        	        	    }
        	        	        	        	        	    break;
        	        	        	        	        	case 2:
        	        	        	        	        	    // OracleDMLCommons.g:474:93: bind_variable
        	        	        	        	        	    {
        	        	        	        	        	        this->followPush(FOLLOW_bind_variable_in_constant4341);
        	        	        	        	        	        bind_variable286=bind_variable();

        	        	        	        	        	        this->followPop();
        	        	        	        	        	        if  (this->hasException())
        	        	        	        	        	        {
        	        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        	        }
        	        	        	        	        	        if (this->hasFailed())
        	        	        	        	        	        {
        	        	        	        	        	            return retval;
        	        	        	        	        	        }

        	        	        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, bind_variable286.tree);


        	        	        	        	        	    }
        	        	        	        	        	    break;

        	        	        	        	            }
        	        	        	        	        }

        	        	        	        	        RIGHT_PAREN287 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_constant4344);
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return retval;
        	        	        	        	        }

        	        	        	        	        if ( this->get_backtracking()==0 ) {
        	        	        	        	        RIGHT_PAREN287_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN287));
        	        	        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN287_tree);
        	        	        	        	        }


        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // OracleDMLCommons.g:476:10: numeric
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_numeric_in_constant4371);
        	        numeric288=numeric();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, numeric288.tree);


        	    }
        	    break;
        	case 4:
        	    // OracleDMLCommons.g:477:10: date_key quoted_string
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_date_key_in_constant4382);
        	        date_key289=m_gOracleDML->date_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, date_key289.tree);


        	        this->followPush(FOLLOW_quoted_string_in_constant4384);
        	        quoted_string290=quoted_string();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, quoted_string290.tree);


        	    }
        	    break;
        	case 5:
        	    // OracleDMLCommons.g:478:10: quoted_string
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_quoted_string_in_constant4395);
        	        quoted_string291=quoted_string();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, quoted_string291.tree);


        	    }
        	    break;
        	case 6:
        	    // OracleDMLCommons.g:479:10: null_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_null_key_in_constant4406);
        	        null_key292=m_gOracleDML->null_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, null_key292.tree);


        	    }
        	    break;
        	case 7:
        	    // OracleDMLCommons.g:480:10: true_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_true_key_in_constant4417);
        	        true_key293=m_gOracleDML->true_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, true_key293.tree);


        	    }
        	    break;
        	case 8:
        	    // OracleDMLCommons.g:481:10: false_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_false_key_in_constant4428);
        	        false_key294=m_gOracleDML->false_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, false_key294.tree);


        	    }
        	    break;
        	case 9:
        	    // OracleDMLCommons.g:482:10: dbtimezone_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_dbtimezone_key_in_constant4439);
        	        dbtimezone_key295=m_gOracleDML->dbtimezone_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, dbtimezone_key295.tree);


        	    }
        	    break;
        	case 10:
        	    // OracleDMLCommons.g:483:10: sessiontimezone_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_sessiontimezone_key_in_constant4451);
        	        sessiontimezone_key296=m_gOracleDML->sessiontimezone_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, sessiontimezone_key296.tree);


        	    }
        	    break;
        	case 11:
        	    // OracleDMLCommons.g:484:10: minvalue_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_minvalue_key_in_constant4462);
        	        minvalue_key297=m_gOracleDML->minvalue_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, minvalue_key297.tree);


        	    }
        	    break;
        	case 12:
        	    // OracleDMLCommons.g:485:10: maxvalue_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_maxvalue_key_in_constant4473);
        	        maxvalue_key298=m_gOracleDML->maxvalue_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, maxvalue_key298.tree);


        	    }
        	    break;
        	case 13:
        	    // OracleDMLCommons.g:486:10: default_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_default_key_in_constant4484);
        	        default_key299=m_gOracleDML->default_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, default_key299.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruleconstantEx; /* Prevent compiler warnings */
    ruleconstantEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end constant */

/**
 * $ANTLR start numeric
 * OracleDMLCommons.g:489:1: numeric : ( UNSIGNED_INTEGER | EXACT_NUM_LIT | APPROXIMATE_NUM_LIT );
 */
OracleDML_OracleDMLCommons::numeric_return
OracleDML_OracleDMLCommons::numeric()
{
    OracleDML_OracleDMLCommons::numeric_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* set300 = NULL;

    ImplTraits::TreeTypePtr set300_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:490:5: ( UNSIGNED_INTEGER | EXACT_NUM_LIT | APPROXIMATE_NUM_LIT )
        // OracleDMLCommons.g:
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            set300=(ImplTraits::CommonTokenType const*) this->LT(1);

            if ( this->LA(1) == APPROXIMATE_NUM_LIT || this->LA(1) == EXACT_NUM_LIT || this->LA(1) == UNSIGNED_INTEGER )
            {
                this->consume();
                if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(set300));
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulenumericEx;
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulenumericEx; /* Prevent compiler warnings */
    rulenumericEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end numeric */

/**
 * $ANTLR start quoted_string
 * OracleDMLCommons.g:494:1: quoted_string : ( CHAR_STRING | CHAR_STRING_PERL | NATIONAL_CHAR_STRING_LIT );
 */
OracleDML_OracleDMLCommons::quoted_string_return
OracleDML_OracleDMLCommons::quoted_string()
{
    OracleDML_OracleDMLCommons::quoted_string_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* set301 = NULL;

    ImplTraits::TreeTypePtr set301_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:495:5: ( CHAR_STRING | CHAR_STRING_PERL | NATIONAL_CHAR_STRING_LIT )
        // OracleDMLCommons.g:
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            set301=(ImplTraits::CommonTokenType const*) this->LT(1);

            if ( ((this->LA(1) >= CHAR_STRING) && (this->LA(1) <= CHAR_STRING_PERL)) || this->LA(1) == NATIONAL_CHAR_STRING_LIT )
            {
                this->consume();
                if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(set301));
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulequoted_stringEx;
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulequoted_stringEx; /* Prevent compiler warnings */
    rulequoted_stringEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end quoted_string */

/**
 * $ANTLR start id
 * OracleDMLCommons.g:500:1: id[int identifierClass, int usageType] : ( INTRODUCER char_set_name )? r= id_expression[identifierClass, usageType] ;
 */
OracleDML_OracleDMLCommons::id_return
OracleDML_OracleDMLCommons::id(int identifierClass, int usageType)
{
    OracleDML_OracleDMLCommons::id_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* INTRODUCER302 = NULL;
    OracleDML_OracleDMLCommons::id_expression_return r;
    ImplTraits::TreeTypePtr::pointer r_last = NULL;
    OracleDML_OracleDMLCommons::char_set_name_return char_set_name303;
    ImplTraits::TreeTypePtr::pointer char_set_name303_last = NULL;
    ImplTraits::TreeTypePtr INTRODUCER302_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:501:5: ( ( INTRODUCER char_set_name )? r= id_expression[identifierClass, usageType] )
        // OracleDMLCommons.g:501:10: ( INTRODUCER char_set_name )? r= id_expression[identifierClass, usageType]
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            // OracleDMLCommons.g:501:10: ( INTRODUCER char_set_name )?
            {
                ANTLR_UINT32 alt94=2;
                switch ( this->LA(1) )
                {
                    case INTRODUCER:
                    	{
                    		alt94=1;
                    	}
                        break;
                }

                switch (alt94)
                {
            	case 1:
            	    // OracleDMLCommons.g:501:11: INTRODUCER char_set_name
            	    {
            	        INTRODUCER302 =  this->matchToken(INTRODUCER, &FOLLOW_INTRODUCER_in_id4585);
            	        if  (this->hasException())
            	        {
            	            goto ruleidEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) {
            	        INTRODUCER302_tree = std::move(get_psrstate()->get_treeAdaptor()->create(INTRODUCER302));
            	        get_psrstate()->get_treeAdaptor()->addChild(root_0, INTRODUCER302_tree);
            	        }


            	        this->followPush(FOLLOW_char_set_name_in_id4587);
            	        char_set_name303=char_set_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleidEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, char_set_name303.tree);


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_id_expression_in_id4601);
            r=id_expression(identifierClass, usageType);

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, r.tree);


            if ( this->get_backtracking()==0 )
            {
                 /* int i = r.tree->getType(); r.tree->UserData.identifierClass = 1235; */ 
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleidEx; /* Prevent compiler warnings */
    ruleidEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end id */

/**
 * $ANTLR start id_expression
 * OracleDMLCommons.g:506:1: id_expression[int identifierClass, int usageType] : (r= REGULAR_ID |d= DELIMITED_ID );
 */
OracleDML_OracleDMLCommons::id_expression_return
OracleDML_OracleDMLCommons::id_expression(int identifierClass, int usageType)
{
    OracleDML_OracleDMLCommons::id_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* r = NULL;
    ImplTraits::CommonTokenType const* d = NULL;

    ImplTraits::TreeTypePtr r_tree;
    ImplTraits::TreeTypePtr d_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDMLCommons.g:509:5: (r= REGULAR_ID |d= DELIMITED_ID )

            ANTLR_UINT32 alt95;

            alt95=2;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		alt95=1;
            	}
                break;
            case DELIMITED_ID:
            	{
            		alt95=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 95 );
                ex->set_state( 0 );


                goto ruleid_expressionEx;

            }

            switch (alt95)
            {
        	case 1:
        	    // OracleDMLCommons.g:509:10: r= REGULAR_ID
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        r =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_id_expression4638);
        	        if  (this->hasException())
        	        {
        	            goto ruleid_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        r_tree = std::move(get_psrstate()->get_treeAdaptor()->create(r));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, r_tree);
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	             const_cast<CommonTokenType*>(r)->set_type(ID);
        	                                      const_cast<CommonTokenType*>(r)->UserData.identifierClass = identifierClass;
        	                                      const_cast<CommonTokenType*>(r)->UserData.usageType = usageType;
        	                                    
        	        }


        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:513:10: d= DELIMITED_ID
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        d =  this->matchToken(DELIMITED_ID, &FOLLOW_DELIMITED_ID_in_id_expression4655);
        	        if  (this->hasException())
        	        {
        	            goto ruleid_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        d_tree = std::move(get_psrstate()->get_treeAdaptor()->create(d));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, d_tree);
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	             const_cast<CommonTokenType*>(d)->set_type(ID);
        	                                      const_cast<CommonTokenType*>(d)->UserData.identifierClass = identifierClass;
        	                                      const_cast<CommonTokenType*>(d)->UserData.usageType = usageType;
        	                                    
        	        }


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruleid_expressionEx; /* Prevent compiler warnings */
    ruleid_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end id_expression */

/**
 * $ANTLR start not_equal_op
 * OracleDMLCommons.g:519:1: not_equal_op : ( NOT_EQUAL_OP | LESS_THAN_OP GREATER_THAN_OP | EXCLAMATION_OPERATOR_PART EQUALS_OP | CARRET_OPERATOR_PART EQUALS_OP );
 */
OracleDML_OracleDMLCommons::not_equal_op_return
OracleDML_OracleDMLCommons::not_equal_op()
{
    OracleDML_OracleDMLCommons::not_equal_op_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* NOT_EQUAL_OP304 = NULL;
    ImplTraits::CommonTokenType const* LESS_THAN_OP305 = NULL;
    ImplTraits::CommonTokenType const* GREATER_THAN_OP306 = NULL;
    ImplTraits::CommonTokenType const* EXCLAMATION_OPERATOR_PART307 = NULL;
    ImplTraits::CommonTokenType const* EQUALS_OP308 = NULL;
    ImplTraits::CommonTokenType const* CARRET_OPERATOR_PART309 = NULL;
    ImplTraits::CommonTokenType const* EQUALS_OP310 = NULL;

    ImplTraits::TreeTypePtr NOT_EQUAL_OP304_tree;
    ImplTraits::TreeTypePtr LESS_THAN_OP305_tree;
    ImplTraits::TreeTypePtr GREATER_THAN_OP306_tree;
    ImplTraits::TreeTypePtr EXCLAMATION_OPERATOR_PART307_tree;
    ImplTraits::TreeTypePtr EQUALS_OP308_tree;
    ImplTraits::TreeTypePtr CARRET_OPERATOR_PART309_tree;
    ImplTraits::TreeTypePtr EQUALS_OP310_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDMLCommons.g:520:5: ( NOT_EQUAL_OP | LESS_THAN_OP GREATER_THAN_OP | EXCLAMATION_OPERATOR_PART EQUALS_OP | CARRET_OPERATOR_PART EQUALS_OP )

            ANTLR_UINT32 alt96;

            alt96=4;

            switch ( this->LA(1) )
            {
            case NOT_EQUAL_OP:
            	{
            		alt96=1;
            	}
                break;
            case LESS_THAN_OP:
            	{
            		alt96=2;
            	}
                break;
            case EXCLAMATION_OPERATOR_PART:
            	{
            		alt96=3;
            	}
                break;
            case CARRET_OPERATOR_PART:
            	{
            		alt96=4;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 96 );
                ex->set_state( 0 );


                goto rulenot_equal_opEx;

            }

            switch (alt96)
            {
        	case 1:
        	    // OracleDMLCommons.g:520:10: NOT_EQUAL_OP
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        NOT_EQUAL_OP304 =  this->matchToken(NOT_EQUAL_OP, &FOLLOW_NOT_EQUAL_OP_in_not_equal_op4677);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        NOT_EQUAL_OP304_tree = std::move(get_psrstate()->get_treeAdaptor()->create(NOT_EQUAL_OP304));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, NOT_EQUAL_OP304_tree);
        	        }


        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:521:10: LESS_THAN_OP GREATER_THAN_OP
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        LESS_THAN_OP305 =  this->matchToken(LESS_THAN_OP, &FOLLOW_LESS_THAN_OP_in_not_equal_op4688);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LESS_THAN_OP305_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LESS_THAN_OP305));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LESS_THAN_OP305_tree);
        	        }


        	        GREATER_THAN_OP306 =  this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_not_equal_op4690);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        GREATER_THAN_OP306_tree = std::move(get_psrstate()->get_treeAdaptor()->create(GREATER_THAN_OP306));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, GREATER_THAN_OP306_tree);
        	        }


        	    }
        	    break;
        	case 3:
        	    // OracleDMLCommons.g:522:10: EXCLAMATION_OPERATOR_PART EQUALS_OP
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        EXCLAMATION_OPERATOR_PART307 =  this->matchToken(EXCLAMATION_OPERATOR_PART, &FOLLOW_EXCLAMATION_OPERATOR_PART_in_not_equal_op4701);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        EXCLAMATION_OPERATOR_PART307_tree = std::move(get_psrstate()->get_treeAdaptor()->create(EXCLAMATION_OPERATOR_PART307));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, EXCLAMATION_OPERATOR_PART307_tree);
        	        }


        	        EQUALS_OP308 =  this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_not_equal_op4703);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        EQUALS_OP308_tree = std::move(get_psrstate()->get_treeAdaptor()->create(EQUALS_OP308));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, EQUALS_OP308_tree);
        	        }


        	    }
        	    break;
        	case 4:
        	    // OracleDMLCommons.g:523:10: CARRET_OPERATOR_PART EQUALS_OP
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        CARRET_OPERATOR_PART309 =  this->matchToken(CARRET_OPERATOR_PART, &FOLLOW_CARRET_OPERATOR_PART_in_not_equal_op4714);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        CARRET_OPERATOR_PART309_tree = std::move(get_psrstate()->get_treeAdaptor()->create(CARRET_OPERATOR_PART309));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, CARRET_OPERATOR_PART309_tree);
        	        }


        	        EQUALS_OP310 =  this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_not_equal_op4716);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        EQUALS_OP310_tree = std::move(get_psrstate()->get_treeAdaptor()->create(EQUALS_OP310));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, EQUALS_OP310_tree);
        	        }


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulenot_equal_opEx; /* Prevent compiler warnings */
    rulenot_equal_opEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end not_equal_op */

/**
 * $ANTLR start greater_than_or_equals_op
 * OracleDMLCommons.g:526:1: greater_than_or_equals_op : ( GREATER_THAN_OR_EQUALS_OP | GREATER_THAN_OP EQUALS_OP );
 */
OracleDML_OracleDMLCommons::greater_than_or_equals_op_return
OracleDML_OracleDMLCommons::greater_than_or_equals_op()
{
    OracleDML_OracleDMLCommons::greater_than_or_equals_op_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* GREATER_THAN_OR_EQUALS_OP311 = NULL;
    ImplTraits::CommonTokenType const* GREATER_THAN_OP312 = NULL;
    ImplTraits::CommonTokenType const* EQUALS_OP313 = NULL;

    ImplTraits::TreeTypePtr GREATER_THAN_OR_EQUALS_OP311_tree;
    ImplTraits::TreeTypePtr GREATER_THAN_OP312_tree;
    ImplTraits::TreeTypePtr EQUALS_OP313_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDMLCommons.g:527:5: ( GREATER_THAN_OR_EQUALS_OP | GREATER_THAN_OP EQUALS_OP )

            ANTLR_UINT32 alt97;

            alt97=2;

            switch ( this->LA(1) )
            {
            case GREATER_THAN_OR_EQUALS_OP:
            	{
            		alt97=1;
            	}
                break;
            case GREATER_THAN_OP:
            	{
            		alt97=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 97 );
                ex->set_state( 0 );


                goto rulegreater_than_or_equals_opEx;

            }

            switch (alt97)
            {
        	case 1:
        	    // OracleDMLCommons.g:527:10: GREATER_THAN_OR_EQUALS_OP
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        GREATER_THAN_OR_EQUALS_OP311 =  this->matchToken(GREATER_THAN_OR_EQUALS_OP, &FOLLOW_GREATER_THAN_OR_EQUALS_OP_in_greater_than_or_equals_op4736);
        	        if  (this->hasException())
        	        {
        	            goto rulegreater_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        GREATER_THAN_OR_EQUALS_OP311_tree = std::move(get_psrstate()->get_treeAdaptor()->create(GREATER_THAN_OR_EQUALS_OP311));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, GREATER_THAN_OR_EQUALS_OP311_tree);
        	        }


        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:528:10: GREATER_THAN_OP EQUALS_OP
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        GREATER_THAN_OP312 =  this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_greater_than_or_equals_op4747);
        	        if  (this->hasException())
        	        {
        	            goto rulegreater_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        GREATER_THAN_OP312_tree = std::move(get_psrstate()->get_treeAdaptor()->create(GREATER_THAN_OP312));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, GREATER_THAN_OP312_tree);
        	        }


        	        EQUALS_OP313 =  this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_greater_than_or_equals_op4749);
        	        if  (this->hasException())
        	        {
        	            goto rulegreater_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        EQUALS_OP313_tree = std::move(get_psrstate()->get_treeAdaptor()->create(EQUALS_OP313));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, EQUALS_OP313_tree);
        	        }


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulegreater_than_or_equals_opEx; /* Prevent compiler warnings */
    rulegreater_than_or_equals_opEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end greater_than_or_equals_op */

/**
 * $ANTLR start less_than_or_equals_op
 * OracleDMLCommons.g:531:1: less_than_or_equals_op : ( LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP EQUALS_OP );
 */
OracleDML_OracleDMLCommons::less_than_or_equals_op_return
OracleDML_OracleDMLCommons::less_than_or_equals_op()
{
    OracleDML_OracleDMLCommons::less_than_or_equals_op_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LESS_THAN_OR_EQUALS_OP314 = NULL;
    ImplTraits::CommonTokenType const* LESS_THAN_OP315 = NULL;
    ImplTraits::CommonTokenType const* EQUALS_OP316 = NULL;

    ImplTraits::TreeTypePtr LESS_THAN_OR_EQUALS_OP314_tree;
    ImplTraits::TreeTypePtr LESS_THAN_OP315_tree;
    ImplTraits::TreeTypePtr EQUALS_OP316_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDMLCommons.g:532:5: ( LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP EQUALS_OP )

            ANTLR_UINT32 alt98;

            alt98=2;

            switch ( this->LA(1) )
            {
            case LESS_THAN_OR_EQUALS_OP:
            	{
            		alt98=1;
            	}
                break;
            case LESS_THAN_OP:
            	{
            		alt98=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 98 );
                ex->set_state( 0 );


                goto ruleless_than_or_equals_opEx;

            }

            switch (alt98)
            {
        	case 1:
        	    // OracleDMLCommons.g:532:10: LESS_THAN_OR_EQUALS_OP
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        LESS_THAN_OR_EQUALS_OP314 =  this->matchToken(LESS_THAN_OR_EQUALS_OP, &FOLLOW_LESS_THAN_OR_EQUALS_OP_in_less_than_or_equals_op4769);
        	        if  (this->hasException())
        	        {
        	            goto ruleless_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LESS_THAN_OR_EQUALS_OP314_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LESS_THAN_OR_EQUALS_OP314));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LESS_THAN_OR_EQUALS_OP314_tree);
        	        }


        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:533:10: LESS_THAN_OP EQUALS_OP
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        LESS_THAN_OP315 =  this->matchToken(LESS_THAN_OP, &FOLLOW_LESS_THAN_OP_in_less_than_or_equals_op4780);
        	        if  (this->hasException())
        	        {
        	            goto ruleless_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LESS_THAN_OP315_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LESS_THAN_OP315));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LESS_THAN_OP315_tree);
        	        }


        	        EQUALS_OP316 =  this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_less_than_or_equals_op4782);
        	        if  (this->hasException())
        	        {
        	            goto ruleless_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        EQUALS_OP316_tree = std::move(get_psrstate()->get_treeAdaptor()->create(EQUALS_OP316));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, EQUALS_OP316_tree);
        	        }


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruleless_than_or_equals_opEx; /* Prevent compiler warnings */
    ruleless_than_or_equals_opEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end less_than_or_equals_op */

/**
 * $ANTLR start concatenation_op
 * OracleDMLCommons.g:536:1: concatenation_op : ( CONCATENATION_OP | VERTICAL_BAR VERTICAL_BAR );
 */
OracleDML_OracleDMLCommons::concatenation_op_return
OracleDML_OracleDMLCommons::concatenation_op()
{
    OracleDML_OracleDMLCommons::concatenation_op_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* CONCATENATION_OP317 = NULL;
    ImplTraits::CommonTokenType const* VERTICAL_BAR318 = NULL;
    ImplTraits::CommonTokenType const* VERTICAL_BAR319 = NULL;

    ImplTraits::TreeTypePtr CONCATENATION_OP317_tree;
    ImplTraits::TreeTypePtr VERTICAL_BAR318_tree;
    ImplTraits::TreeTypePtr VERTICAL_BAR319_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDMLCommons.g:537:5: ( CONCATENATION_OP | VERTICAL_BAR VERTICAL_BAR )

            ANTLR_UINT32 alt99;

            alt99=2;

            switch ( this->LA(1) )
            {
            case CONCATENATION_OP:
            	{
            		alt99=1;
            	}
                break;
            case VERTICAL_BAR:
            	{
            		alt99=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 99 );
                ex->set_state( 0 );


                goto ruleconcatenation_opEx;

            }

            switch (alt99)
            {
        	case 1:
        	    // OracleDMLCommons.g:537:10: CONCATENATION_OP
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        CONCATENATION_OP317 =  this->matchToken(CONCATENATION_OP, &FOLLOW_CONCATENATION_OP_in_concatenation_op4802);
        	        if  (this->hasException())
        	        {
        	            goto ruleconcatenation_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        CONCATENATION_OP317_tree = std::move(get_psrstate()->get_treeAdaptor()->create(CONCATENATION_OP317));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, CONCATENATION_OP317_tree);
        	        }


        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:538:10: VERTICAL_BAR VERTICAL_BAR
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        VERTICAL_BAR318 =  this->matchToken(VERTICAL_BAR, &FOLLOW_VERTICAL_BAR_in_concatenation_op4813);
        	        if  (this->hasException())
        	        {
        	            goto ruleconcatenation_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        VERTICAL_BAR318_tree = std::move(get_psrstate()->get_treeAdaptor()->create(VERTICAL_BAR318));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, VERTICAL_BAR318_tree);
        	        }


        	        VERTICAL_BAR319 =  this->matchToken(VERTICAL_BAR, &FOLLOW_VERTICAL_BAR_in_concatenation_op4815);
        	        if  (this->hasException())
        	        {
        	            goto ruleconcatenation_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        VERTICAL_BAR319_tree = std::move(get_psrstate()->get_treeAdaptor()->create(VERTICAL_BAR319));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, VERTICAL_BAR319_tree);
        	        }


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruleconcatenation_opEx; /* Prevent compiler warnings */
    ruleconcatenation_opEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end concatenation_op */

/**
 * $ANTLR start multiset_op
 * OracleDMLCommons.g:541:1: multiset_op : multiset_key ( except_key | intersect_key | union_key ) ( all_key | distinct_key )? ;
 */
OracleDML_OracleDMLCommons::multiset_op_return
OracleDML_OracleDMLCommons::multiset_op()
{
    OracleDML_OracleDMLCommons::multiset_op_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::multiset_key_return multiset_key320;
    ImplTraits::TreeTypePtr::pointer multiset_key320_last = NULL;
    OracleDML_OracleDMLKeys::except_key_return except_key321;
    ImplTraits::TreeTypePtr::pointer except_key321_last = NULL;
    OracleDML_OracleDMLKeys::intersect_key_return intersect_key322;
    ImplTraits::TreeTypePtr::pointer intersect_key322_last = NULL;
    OracleDML_OracleDMLKeys::union_key_return union_key323;
    ImplTraits::TreeTypePtr::pointer union_key323_last = NULL;
    OracleDML_OracleDMLKeys::all_key_return all_key324;
    ImplTraits::TreeTypePtr::pointer all_key324_last = NULL;
    OracleDML_OracleDMLKeys::distinct_key_return distinct_key325;
    ImplTraits::TreeTypePtr::pointer distinct_key325_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:542:5: ( multiset_key ( except_key | intersect_key | union_key ) ( all_key | distinct_key )? )
        // OracleDMLCommons.g:542:10: multiset_key ( except_key | intersect_key | union_key ) ( all_key | distinct_key )?
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_multiset_key_in_multiset_op4835);
            multiset_key320=m_gOracleDML->multiset_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultiset_opEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, multiset_key320.tree);


            // OracleDMLCommons.g:543:10: ( except_key | intersect_key | union_key )
            {
                ANTLR_UINT32 alt100=3;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		alt100=1;
                	}
                    break;
                case SQL92_RESERVED_INTERSECT:
                	{
                		alt100=2;
                	}
                    break;
                case SQL92_RESERVED_UNION:
                	{
                		alt100=3;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 100 );
                    ex->set_state( 0 );


                    goto rulemultiset_opEx;

                }

                switch (alt100)
                {
            	case 1:
            	    // OracleDMLCommons.g:543:12: except_key
            	    {
            	        this->followPush(FOLLOW_except_key_in_multiset_op4848);
            	        except_key321=m_gOracleDML->except_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, except_key321.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:543:25: intersect_key
            	    {
            	        this->followPush(FOLLOW_intersect_key_in_multiset_op4852);
            	        intersect_key322=m_gOracleDML->intersect_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, intersect_key322.tree);


            	    }
            	    break;
            	case 3:
            	    // OracleDMLCommons.g:543:41: union_key
            	    {
            	        this->followPush(FOLLOW_union_key_in_multiset_op4856);
            	        union_key323=m_gOracleDML->union_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, union_key323.tree);


            	    }
            	    break;

                }
            }

            // OracleDMLCommons.g:544:10: ( all_key | distinct_key )?
            {
                ANTLR_UINT32 alt101=3;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ALL:
                    	{
                    		alt101=1;
                    	}
                        break;
                    case SQL92_RESERVED_DISTINCT:
                    	{
                    		alt101=2;
                    	}
                        break;
                }

                switch (alt101)
                {
            	case 1:
            	    // OracleDMLCommons.g:544:12: all_key
            	    {
            	        this->followPush(FOLLOW_all_key_in_multiset_op4871);
            	        all_key324=m_gOracleDML->all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, all_key324.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDMLCommons.g:544:22: distinct_key
            	    {
            	        this->followPush(FOLLOW_distinct_key_in_multiset_op4875);
            	        distinct_key325=m_gOracleDML->distinct_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, distinct_key325.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemultiset_opEx; /* Prevent compiler warnings */
    rulemultiset_opEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end multiset_op */

/**
 * $ANTLR start outer_join_sign
 * OracleDMLCommons.g:547:1: outer_join_sign : LEFT_PAREN PLUS_SIGN RIGHT_PAREN ;
 */
OracleDML_OracleDMLCommons::outer_join_sign_return
OracleDML_OracleDMLCommons::outer_join_sign()
{
    OracleDML_OracleDMLCommons::outer_join_sign_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN326 = NULL;
    ImplTraits::CommonTokenType const* PLUS_SIGN327 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN328 = NULL;

    ImplTraits::TreeTypePtr LEFT_PAREN326_tree;
    ImplTraits::TreeTypePtr PLUS_SIGN327_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN328_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDMLCommons.g:548:5: ( LEFT_PAREN PLUS_SIGN RIGHT_PAREN )
        // OracleDMLCommons.g:548:10: LEFT_PAREN PLUS_SIGN RIGHT_PAREN
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            LEFT_PAREN326 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_outer_join_sign4898);
            if  (this->hasException())
            {
                goto ruleouter_join_signEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            LEFT_PAREN326_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN326));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN326_tree);
            }


            PLUS_SIGN327 =  this->matchToken(PLUS_SIGN, &FOLLOW_PLUS_SIGN_in_outer_join_sign4900);
            if  (this->hasException())
            {
                goto ruleouter_join_signEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            PLUS_SIGN327_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PLUS_SIGN327));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, PLUS_SIGN327_tree);
            }


            RIGHT_PAREN328 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_outer_join_sign4902);
            if  (this->hasException())
            {
                goto ruleouter_join_signEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            RIGHT_PAREN328_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN328));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN328_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleouter_join_signEx; /* Prevent compiler warnings */
    ruleouter_join_signEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end outer_join_sign */

// $ANTLR start synpredRule synpred1_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred1_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:93:10: ( ( as_key )? ( id[T_COLUMN_ALIAS,T_DECL] | alias_quoted_string[T_COLUMN_ALIAS,T_DECL] ) )
    // OracleDMLCommons.g:93:10: ( as_key )? ( id[T_COLUMN_ALIAS,T_DECL] | alias_quoted_string[T_COLUMN_ALIAS,T_DECL] )
    {
        // OracleDMLCommons.g:93:10: ( as_key )?
        {
            ANTLR_UINT32 alt102=2;
            switch ( this->LA(1) )
            {
                case SQL92_RESERVED_AS:
                	{
                		alt102=1;
                	}
                    break;
            }

            switch (alt102)
            {
        	case 1:
        	    // OracleDMLCommons.g:93:10: as_key
        	    {
        	        this->followPush(FOLLOW_as_key_in_synpred1_OracleDMLCommons338);
        	        m_gOracleDML->as_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred1_OracleDMLCommonsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

            }
        }

        // OracleDMLCommons.g:93:18: ( id[T_COLUMN_ALIAS,T_DECL] | alias_quoted_string[T_COLUMN_ALIAS,T_DECL] )
        {
            ANTLR_UINT32 alt103=2;
            switch ( this->LA(1) )
            {
            case DELIMITED_ID:
            case INTRODUCER:
            case REGULAR_ID:
            	{
            		alt103=1;
            	}
                break;
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case NATIONAL_CHAR_STRING_LIT:
            	{
            		alt103=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDML_OracleDMLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 103 );
                ex->set_state( 0 );


                goto rulesynpred1_OracleDMLCommonsEx;

            }

            switch (alt103)
            {
        	case 1:
        	    // OracleDMLCommons.g:93:19: id[T_COLUMN_ALIAS,T_DECL]
        	    {
        	        this->followPush(FOLLOW_id_in_synpred1_OracleDMLCommons342);
        	        id(T_COLUMN_ALIAS, T_DECL);

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred1_OracleDMLCommonsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;
        	case 2:
        	    // OracleDMLCommons.g:93:45: alias_quoted_string[T_COLUMN_ALIAS,T_DECL]
        	    {
        	        this->followPush(FOLLOW_alias_quoted_string_in_synpred1_OracleDMLCommons345);
        	        alias_quoted_string(T_COLUMN_ALIAS, T_DECL);

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred1_OracleDMLCommonsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

            }
        }

    }


goto rulesynpred1_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred1_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred1_OracleDMLCommons

// $ANTLR start synpredRule synpred2_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred2_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:172:31: ( PERIOD id_expression[T_UNKNOWN,T_USE] )
    // OracleDMLCommons.g:172:32: PERIOD id_expression[T_UNKNOWN,T_USE]
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred2_OracleDMLCommons852);
        if  (this->hasException())
        {
            goto rulesynpred2_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred2_OracleDMLCommons854);
        id_expression(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred2_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred2_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred2_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred2_OracleDMLCommons

// $ANTLR start synpredRule synpred3_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred3_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:192:37: ( PERIOD id_expression[T_FUNCTION_NAME,T_USE] )
    // OracleDMLCommons.g:192:38: PERIOD id_expression[T_FUNCTION_NAME,T_USE]
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred3_OracleDMLCommons1019);
        if  (this->hasException())
        {
            goto rulesynpred3_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred3_OracleDMLCommons1021);
        id_expression(T_FUNCTION_NAME, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred3_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred3_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred3_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred3_OracleDMLCommons

// $ANTLR start synpredRule synpred4_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred4_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:202:31: ( PERIOD id_expression[T_UNKNOWN,T_USE] )
    // OracleDMLCommons.g:202:32: PERIOD id_expression[T_UNKNOWN,T_USE]
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred4_OracleDMLCommons1112);
        if  (this->hasException())
        {
            goto rulesynpred4_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred4_OracleDMLCommons1114);
        id_expression(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred4_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred4_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred4_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred4_OracleDMLCommons

// $ANTLR start synpredRule synpred5_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred5_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:212:42: ( PERIOD id_expression[T_UNKNOWN,T_USE] )
    // OracleDMLCommons.g:212:43: PERIOD id_expression[T_UNKNOWN,T_USE]
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred5_OracleDMLCommons1215);
        if  (this->hasException())
        {
            goto rulesynpred5_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred5_OracleDMLCommons1217);
        id_expression(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred5_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred5_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred5_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred5_OracleDMLCommons

// $ANTLR start synpredRule synpred6_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred6_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:217:42: ( PERIOD id_expression[T_UNKNOWN,T_USE] )
    // OracleDMLCommons.g:217:43: PERIOD id_expression[T_UNKNOWN,T_USE]
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred6_OracleDMLCommons1269);
        if  (this->hasException())
        {
            goto rulesynpred6_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred6_OracleDMLCommons1271);
        id_expression(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred6_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred6_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred6_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred6_OracleDMLCommons

// $ANTLR start synpredRule synpred7_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred7_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:222:31: ( PERIOD id_expression[T_UNKNOWN,T_USE] )
    // OracleDMLCommons.g:222:32: PERIOD id_expression[T_UNKNOWN,T_USE]
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred7_OracleDMLCommons1323);
        if  (this->hasException())
        {
            goto rulesynpred7_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred7_OracleDMLCommons1325);
        id_expression(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred7_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred7_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred7_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred7_OracleDMLCommons

// $ANTLR start synpredRule synpred8_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred8_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:227:37: ( PERIOD id_expression[T_FUNCTION_NAME,T_USE] )
    // OracleDMLCommons.g:227:38: PERIOD id_expression[T_FUNCTION_NAME,T_USE]
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred8_OracleDMLCommons1379);
        if  (this->hasException())
        {
            goto rulesynpred8_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred8_OracleDMLCommons1381);
        id_expression(T_FUNCTION_NAME, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred8_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred8_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred8_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred8_OracleDMLCommons

// $ANTLR start synpredRule synpred9_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred9_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:232:31: ( PERIOD id_expression[T_UNKNOWN,T_USE] )
    // OracleDMLCommons.g:232:32: PERIOD id_expression[T_UNKNOWN,T_USE]
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred9_OracleDMLCommons1435);
        if  (this->hasException())
        {
            goto rulesynpred9_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred9_OracleDMLCommons1437);
        id_expression(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred9_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred9_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred9_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred9_OracleDMLCommons

// $ANTLR start synpredRule synpred10_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred10_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:237:31: ( PERIOD id_expression[T_UNKNOWN,T_USE] )
    // OracleDMLCommons.g:237:32: PERIOD id_expression[T_UNKNOWN,T_USE]
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred10_OracleDMLCommons1491);
        if  (this->hasException())
        {
            goto rulesynpred10_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred10_OracleDMLCommons1493);
        id_expression(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred10_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred10_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred10_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred10_OracleDMLCommons

// $ANTLR start synpredRule synpred11_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred11_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:243:45: ( PERIOD id_expression[T_UNKNOWN,T_USE] )
    // OracleDMLCommons.g:243:46: PERIOD id_expression[T_UNKNOWN,T_USE]
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred11_OracleDMLCommons1565);
        if  (this->hasException())
        {
            goto rulesynpred11_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred11_OracleDMLCommons1567);
        id_expression(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred11_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred11_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred11_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred11_OracleDMLCommons

// $ANTLR start synpredRule synpred12_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred12_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:265:31: ( PERIOD id_expression[T_UNKNOWN,T_USE] )
    // OracleDMLCommons.g:265:32: PERIOD id_expression[T_UNKNOWN,T_USE]
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred12_OracleDMLCommons1775);
        if  (this->hasException())
        {
            goto rulesynpred12_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred12_OracleDMLCommons1777);
        id_expression(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred12_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred12_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred12_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred12_OracleDMLCommons

// $ANTLR start synpredRule synpred13_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred13_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:277:15: ( id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] )
    // OracleDMLCommons.g:277:16: id[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE] PERIOD id_expression[T_UNKNOWN,T_USE]
    {
        this->followPush(FOLLOW_id_in_synpred13_OracleDMLCommons1880);
        id(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred13_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred13_OracleDMLCommons1883);
        if  (this->hasException())
        {
            goto rulesynpred13_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred13_OracleDMLCommons1885);
        id_expression(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred13_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred13_OracleDMLCommons1888);
        if  (this->hasException())
        {
            goto rulesynpred13_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred13_OracleDMLCommons1890);
        id_expression(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred13_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred13_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred13_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred13_OracleDMLCommons

// $ANTLR start synpredRule synpred14_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred14_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:279:15: ( id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE] )
    // OracleDMLCommons.g:279:16: id[T_SCHEMA_NAME,T_USE] PERIOD id_expression[T_COLUMN_NAME,T_USE]
    {
        this->followPush(FOLLOW_id_in_synpred14_OracleDMLCommons1947);
        id(T_SCHEMA_NAME, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred14_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred14_OracleDMLCommons1950);
        if  (this->hasException())
        {
            goto rulesynpred14_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred14_OracleDMLCommons1952);
        id_expression(T_COLUMN_NAME, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred14_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred14_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred14_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred14_OracleDMLCommons

// $ANTLR start synpredRule synpred15_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred15_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:281:15: ( id[T_COLUMN_NAME,T_USE] )
    // OracleDMLCommons.g:281:16: id[T_COLUMN_NAME,T_USE]
    {
        this->followPush(FOLLOW_id_in_synpred15_OracleDMLCommons1999);
        id(T_COLUMN_NAME, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred15_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred15_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred15_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred15_OracleDMLCommons

// $ANTLR start synpredRule synpred16_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred16_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:290:13: ( id[T_SCHEMA_NAME,T_USE] PERIOD )
    // OracleDMLCommons.g:290:14: id[T_SCHEMA_NAME,T_USE] PERIOD
    {
        this->followPush(FOLLOW_id_in_synpred16_OracleDMLCommons2091);
        id(T_SCHEMA_NAME, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred16_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred16_OracleDMLCommons2094);
        if  (this->hasException())
        {
            goto rulesynpred16_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred16_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred16_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred16_OracleDMLCommons

// $ANTLR start synpredRule synpred17_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred17_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:300:42: ( PERIOD id_expression[T_UNKNOWN,T_USE] )
    // OracleDMLCommons.g:300:43: PERIOD id_expression[T_UNKNOWN,T_USE]
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred17_OracleDMLCommons2214);
        if  (this->hasException())
        {
            goto rulesynpred17_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred17_OracleDMLCommons2216);
        id_expression(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred17_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred17_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred17_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred17_OracleDMLCommons

// $ANTLR start synpredRule synpred18_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred18_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:338:19: ( tableview_name PERIOD ASTERISK )
    // OracleDMLCommons.g:338:20: tableview_name PERIOD ASTERISK
    {
        this->followPush(FOLLOW_tableview_name_in_synpred18_OracleDMLCommons2613);
        tableview_name();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred18_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred18_OracleDMLCommons2615);
        if  (this->hasException())
        {
            goto rulesynpred18_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_synpred18_OracleDMLCommons2617);
        if  (this->hasException())
        {
            goto rulesynpred18_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred18_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred18_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred18_OracleDMLCommons

// $ANTLR start synpredRule synpred19_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred19_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:353:11: ( id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP )
    // OracleDMLCommons.g:353:12: id[T_UNKNOWN,T_USE] EQUALS_OP GREATER_THAN_OP
    {
        this->followPush(FOLLOW_id_in_synpred19_OracleDMLCommons2797);
        id(T_UNKNOWN, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred19_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_synpred19_OracleDMLCommons2800);
        if  (this->hasException())
        {
            goto rulesynpred19_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



         this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_synpred19_OracleDMLCommons2802);
        if  (this->hasException())
        {
            goto rulesynpred19_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred19_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred19_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred19_OracleDMLCommons

// $ANTLR start synpredRule synpred20_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred20_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:440:11: ( PERIOD general_element_part )
    // OracleDMLCommons.g:440:12: PERIOD general_element_part
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred20_OracleDMLCommons3863);
        if  (this->hasException())
        {
            goto rulesynpred20_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_general_element_part_in_synpred20_OracleDMLCommons3865);
        general_element_part();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred20_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred20_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred20_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred20_OracleDMLCommons

// $ANTLR start synpredRule synpred21_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred21_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:446:32: ( PERIOD general_element_part )
    // OracleDMLCommons.g:446:33: PERIOD general_element_part
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred21_OracleDMLCommons3941);
        if  (this->hasException())
        {
            goto rulesynpred21_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_general_element_part_in_synpred21_OracleDMLCommons3943);
        general_element_part();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred21_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred21_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred21_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred21_OracleDMLCommons

// $ANTLR start synpredRule synpred22_OracleDMLCommons
void OracleDML_OracleDMLCommons::msynpred22_OracleDMLCommons_fragment(  )
{
    // OracleDMLCommons.g:454:14: ( PERIOD id_expression[T_COLUMN_NAME,T_USE] )
    // OracleDMLCommons.g:454:15: PERIOD id_expression[T_COLUMN_NAME,T_USE]
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred22_OracleDMLCommons4035);
        if  (this->hasException())
        {
            goto rulesynpred22_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_id_expression_in_synpred22_OracleDMLCommons4037);
        id_expression(T_COLUMN_NAME, T_USE);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred22_OracleDMLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred22_OracleDMLCommonsEx; /* Prevent compiler warnings */
rulesynpred22_OracleDMLCommonsEx: ;
}
// $ANTLR end synpred22_OracleDMLCommons
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred15_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred15_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred10_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred10_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred18_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred18_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred7_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred7_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred14_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred14_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred19_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred19_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred16_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred16_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred20_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred20_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred17_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred17_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred13_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred13_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred2_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred2_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred21_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred21_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred4_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred4_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred12_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred12_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred3_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred3_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred6_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred6_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred8_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred8_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred5_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred5_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred11_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred11_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred22_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred22_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred1_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred1_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML_OracleDMLCommons::msynpred( antlr3::ClassForwarder< synpred9_OracleDMLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred9_OracleDMLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

}

/* End of code
 * =============================================================================
 */
