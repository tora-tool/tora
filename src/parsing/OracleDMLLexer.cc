/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.3-SNAPSHOT
 *
 *     -  From the grammar source file : OracleDMLLexer.g
 *     -                            On : 2015-09-27 21:38:18
 *     -                 for the lexer : OracleDMLLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/*
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include "antlr3compilerwarning.hpp"
#include "OracleDMLLexer.hpp"

#include <memory>

/* ----------------------------------------- */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


namespace  Antlr3BackendImpl  {
const ANTLR_UINT8* OracleDMLLexerTokens::getTokenName(ANTLR_UINT32 index)
{
       if( EOF_TOKEN == index)
               return (ANTLR_UINT8*) "<EOF>";
       return TokenNames[index];
}

/** \brief Table of all token names in symbolic order, mainly used for debugging.
 */
ANTLR_UINT8* OracleDMLLexerTokens::TokenNames[651+4]
       = {
       (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
       (ANTLR_UINT8*) "<EOR>",
       (ANTLR_UINT8*) "<DOWN>",
       (ANTLR_UINT8*) "<UP>",
       (ANTLR_UINT8*) "ADD_VK",//4
       (ANTLR_UINT8*) "AFTER_VK",//5
       (ANTLR_UINT8*) "AGENT_VK",//6
       (ANTLR_UINT8*) "AGGREGATE_VK",//7
       (ANTLR_UINT8*) "ALIAS",//8
       (ANTLR_UINT8*) "AMPERSAND",//9
       (ANTLR_UINT8*) "ANALYZE_VK",//10
       (ANTLR_UINT8*) "ANY_ELEMENT",//11
       (ANTLR_UINT8*) "ANY_MODE",//12
       (ANTLR_UINT8*) "APPROXIMATE_NUM_LIT",//13
       (ANTLR_UINT8*) "ARGUMENT",//14
       (ANTLR_UINT8*) "ARGUMENTS",//15
       (ANTLR_UINT8*) "ASSIGN",//16
       (ANTLR_UINT8*) "ASSIGN_OP",//17
       (ANTLR_UINT8*) "ASSOCIATE_VK",//18
       (ANTLR_UINT8*) "ASTERISK",//19
       (ANTLR_UINT8*) "ATTRIBUTE_NAME",//20
       (ANTLR_UINT8*) "AT_SIGN",//21
       (ANTLR_UINT8*) "AT_VK",//22
       (ANTLR_UINT8*) "AUDIT_VK",//23
       (ANTLR_UINT8*) "AUTHID_VK",//24
       (ANTLR_UINT8*) "AUTOMATIC_VK",//25
       (ANTLR_UINT8*) "AUTONOMOUS_TRANSACTION_VK",//26
       (ANTLR_UINT8*) "AUTO_VK",//27
       (ANTLR_UINT8*) "BATCH_VK",//28
       (ANTLR_UINT8*) "BEFORE_VK",//29
       (ANTLR_UINT8*) "BFILE_VK",//30
       (ANTLR_UINT8*) "BINARY_DOUBLE_VK",//31
       (ANTLR_UINT8*) "BINARY_FLOAT_VK",//32
       (ANTLR_UINT8*) "BINARY_INTEGER_VK",//33
       (ANTLR_UINT8*) "BINDVAR",//34
       (ANTLR_UINT8*) "BIT_STRING_LIT",//35
       (ANTLR_UINT8*) "BIT_VK",//36
       (ANTLR_UINT8*) "BLOB_VK",//37
       (ANTLR_UINT8*) "BLOCK_VK",//38
       (ANTLR_UINT8*) "BODY_VK",//39
       (ANTLR_UINT8*) "BOOLEAN_VK",//40
       (ANTLR_UINT8*) "BOTH_VK",//41
       (ANTLR_UINT8*) "BREADTH_VK",//42
       (ANTLR_UINT8*) "BULK_VK",//43
       (ANTLR_UINT8*) "BYTE_VK",//44
       (ANTLR_UINT8*) "CACHE_VK",//45
       (ANTLR_UINT8*) "CALL_VK",//46
       (ANTLR_UINT8*) "CANONICAL_VK",//47
       (ANTLR_UINT8*) "CARRET_OPERATOR_PART",//48
       (ANTLR_UINT8*) "CASCADE_VK",//49
       (ANTLR_UINT8*) "CASCATED_ELEMENT",//50
       (ANTLR_UINT8*) "CAST_VK",//51
       (ANTLR_UINT8*) "CHARACTER_VK",//52
       (ANTLR_UINT8*) "CHAR_CS_VK",//53
       (ANTLR_UINT8*) "CHAR_SET_NAME",//54
       (ANTLR_UINT8*) "CHAR_STRING",//55
       (ANTLR_UINT8*) "CHAR_STRING_PERL",//56
       (ANTLR_UINT8*) "CHAR_VK",//57
       (ANTLR_UINT8*) "CHR_VK",//58
       (ANTLR_UINT8*) "CLOB_VK",//59
       (ANTLR_UINT8*) "CLOSE_VK",//60
       (ANTLR_UINT8*) "CLUSTER_VK",//61
       (ANTLR_UINT8*) "COLLECTION_MODE",//62
       (ANTLR_UINT8*) "COLLECTION_NAME",//63
       (ANTLR_UINT8*) "COLLECT_VK",//64
       (ANTLR_UINT8*) "COLON",//65
       (ANTLR_UINT8*) "COLUMNS",//66
       (ANTLR_UINT8*) "COLUMN_NAME",//67
       (ANTLR_UINT8*) "COMMA",//68
       (ANTLR_UINT8*) "COMMENT",//69
       (ANTLR_UINT8*) "COMMENT_VK",//70
       (ANTLR_UINT8*) "COMMITTED_VK",//71
       (ANTLR_UINT8*) "COMMIT_VK",//72
       (ANTLR_UINT8*) "COMPATIBILITY_VK",//73
       (ANTLR_UINT8*) "COMPILE_VK",//74
       (ANTLR_UINT8*) "COMPOUND_VK",//75
       (ANTLR_UINT8*) "CONCATENATION_OP",//76
       (ANTLR_UINT8*) "CONDITIONAL_INSERT",//77
       (ANTLR_UINT8*) "CONSTANT_VK",//78
       (ANTLR_UINT8*) "CONSTRAINT_NAME",//79
       (ANTLR_UINT8*) "CONSTRUCTOR_VK",//80
       (ANTLR_UINT8*) "CONTENT_VK",//81
       (ANTLR_UINT8*) "CONTEXT_VK",//82
       (ANTLR_UINT8*) "CONTINUE_VK",//83
       (ANTLR_UINT8*) "CONVERT_VK",//84
       (ANTLR_UINT8*) "CORRUPT_XID_ALL_VK",//85
       (ANTLR_UINT8*) "CORRUPT_XID_VK",//86
       (ANTLR_UINT8*) "COST_CLASS_NAME",//87
       (ANTLR_UINT8*) "COST_VK",//88
       (ANTLR_UINT8*) "COUNT_VK",//89
       (ANTLR_UINT8*) "CROSS_VK",//90
       (ANTLR_UINT8*) "CUBE_VK",//91
       (ANTLR_UINT8*) "CURRENT_USER_VK",//92
       (ANTLR_UINT8*) "CURRENT_VK",//93
       (ANTLR_UINT8*) "CURSOR_NAME",//94
       (ANTLR_UINT8*) "CUSTOMDATUM_VK",//95
       (ANTLR_UINT8*) "CUSTOM_TYPE",//96
       (ANTLR_UINT8*) "CYCLE_VK",//97
       (ANTLR_UINT8*) "C_VK",//98
       (ANTLR_UINT8*) "DATABASE_VK",//99
       (ANTLR_UINT8*) "DATETIME_OP",//100
       (ANTLR_UINT8*) "DAY_VK",//101
       (ANTLR_UINT8*) "DBTIMEZONE_VK",//102
       (ANTLR_UINT8*) "DB_ROLE_CHANGE_VK",//103
       (ANTLR_UINT8*) "DDL_VK",//104
       (ANTLR_UINT8*) "DEBUG_VK",//105
       (ANTLR_UINT8*) "DECIMAL_VK",//106
       (ANTLR_UINT8*) "DECOMPOSE_VK",//107
       (ANTLR_UINT8*) "DECREMENT_VK",//108
       (ANTLR_UINT8*) "DEC_VK",//109
       (ANTLR_UINT8*) "DEFAULTS_VK",//110
       (ANTLR_UINT8*) "DEFERRED_VK",//111
       (ANTLR_UINT8*) "DEFINER_VK",//112
       (ANTLR_UINT8*) "DELIMITED_ID",//113
       (ANTLR_UINT8*) "DENSE_RANK_VK",//114
       (ANTLR_UINT8*) "DEPTH_VK",//115
       (ANTLR_UINT8*) "DETERMINISTIC_VK",//116
       (ANTLR_UINT8*) "DIMENSION_VK",//117
       (ANTLR_UINT8*) "DIRECT_MODE",//118
       (ANTLR_UINT8*) "DISABLE_VK",//119
       (ANTLR_UINT8*) "DISASSOCIATE_VK",//120
       (ANTLR_UINT8*) "DOCUMENT_VK",//121
       (ANTLR_UINT8*) "DOT_ASTERISK",//122
       (ANTLR_UINT8*) "DOUBLE_ASTERISK",//123
       (ANTLR_UINT8*) "DOUBLE_PERIOD",//124
       (ANTLR_UINT8*) "DOUBLE_VK",//125
       (ANTLR_UINT8*) "DSINTERVAL_UNCONSTRAINED_VK",//126
       (ANTLR_UINT8*) "ELEMENT",//127
       (ANTLR_UINT8*) "ELEMENTS_MODE",//128
       (ANTLR_UINT8*) "ENABLE_VK",//129
       (ANTLR_UINT8*) "ENCODING_VK",//130
       (ANTLR_UINT8*) "ENTITYESCAPING_VK",//131
       (ANTLR_UINT8*) "EQUALS_OP",//132
       (ANTLR_UINT8*) "EVALNAME_VK",//133
       (ANTLR_UINT8*) "EXACT_NUM_LIT",//134
       (ANTLR_UINT8*) "EXCEPTIONS_VK",//135
       (ANTLR_UINT8*) "EXCEPTION_INIT_VK",//136
       (ANTLR_UINT8*) "EXCEPTION_NAME",//137
       (ANTLR_UINT8*) "EXCLAMATION_OPERATOR_PART",//138
       (ANTLR_UINT8*) "EXCLUDE_VK",//139
       (ANTLR_UINT8*) "EXECUTE_VK",//140
       (ANTLR_UINT8*) "EXIT_VK",//141
       (ANTLR_UINT8*) "EXPLAIN_STATEMENT",//142
       (ANTLR_UINT8*) "EXPR",//143
       (ANTLR_UINT8*) "EXPR_LIST",//144
       (ANTLR_UINT8*) "EXTERNAL_VK",//145
       (ANTLR_UINT8*) "EXTRACT_VK",//146
       (ANTLR_UINT8*) "FACTORING",//147
       (ANTLR_UINT8*) "FINAL_VK",//148
       (ANTLR_UINT8*) "FIRST_VALUE_VK",//149
       (ANTLR_UINT8*) "FIRST_VK",//150
       (ANTLR_UINT8*) "FLOAT_VK",//151
       (ANTLR_UINT8*) "FOLLOWING_VK",//152
       (ANTLR_UINT8*) "FOLLOWS_VK",//153
       (ANTLR_UINT8*) "FORALL_VK",//154
       (ANTLR_UINT8*) "FORCE_VK",//155
       (ANTLR_UINT8*) "FOR_MULTI_COLUMN",//156
       (ANTLR_UINT8*) "FOR_NOTATION",//157
       (ANTLR_UINT8*) "FOR_SINGLE_COLUMN",//158
       (ANTLR_UINT8*) "FULL_VK",//159
       (ANTLR_UINT8*) "FUNCTION_ENABLING_OVER",//160
       (ANTLR_UINT8*) "FUNCTION_ENABLING_USING",//161
       (ANTLR_UINT8*) "FUNCTION_ENABLING_WITHIN_OR_OVER",//162
       (ANTLR_UINT8*) "FUNCTION_NAME",//163
       (ANTLR_UINT8*) "GREATER_THAN_OP",//164
       (ANTLR_UINT8*) "GREATER_THAN_OR_EQUALS_OP",//165
       (ANTLR_UINT8*) "GROUPING_VK",//166
       (ANTLR_UINT8*) "GROUPIN_SET",//167
       (ANTLR_UINT8*) "GROUP_BY_CLAUSE",//168
       (ANTLR_UINT8*) "GROUP_BY_ELEMENT",//169
       (ANTLR_UINT8*) "HASH_VK",//170
       (ANTLR_UINT8*) "HEX_STRING_LIT",//171
       (ANTLR_UINT8*) "HIDE_VK",//172
       (ANTLR_UINT8*) "HIERARCHICAL",//173
       (ANTLR_UINT8*) "HOSTED_VARIABLE",//174
       (ANTLR_UINT8*) "HOSTED_VARIABLE_NAME",//175
       (ANTLR_UINT8*) "HOSTED_VARIABLE_ROUTINE_CALL",//176
       (ANTLR_UINT8*) "HOUR_VK",//177
       (ANTLR_UINT8*) "ID",//178
       (ANTLR_UINT8*) "IGNORE_VK",//179
       (ANTLR_UINT8*) "IMMEDIATE_VK",//180
       (ANTLR_UINT8*) "IMPLEMENTATION_TYPE_NAME",//181
       (ANTLR_UINT8*) "INCLUDE_VK",//182
       (ANTLR_UINT8*) "INCLUDING_VK",//183
       (ANTLR_UINT8*) "INCREMENT_VK",//184
       (ANTLR_UINT8*) "INDENT_VK",//185
       (ANTLR_UINT8*) "INDEX_NAME",//186
       (ANTLR_UINT8*) "INLINE_VK",//187
       (ANTLR_UINT8*) "INNER_VK",//188
       (ANTLR_UINT8*) "INOUT_VK",//189
       (ANTLR_UINT8*) "INSTANTIABLE_VK",//190
       (ANTLR_UINT8*) "INSTEAD_VK",//191
       (ANTLR_UINT8*) "INTEGER_VK",//192
       (ANTLR_UINT8*) "INTERVAL_DATATYPE",//193
       (ANTLR_UINT8*) "INTRODUCER",//194
       (ANTLR_UINT8*) "INT_VK",//195
       (ANTLR_UINT8*) "INVALIDATE_VK",//196
       (ANTLR_UINT8*) "ISOLATION_VK",//197
       (ANTLR_UINT8*) "IS_A_SET",//198
       (ANTLR_UINT8*) "IS_EMPTY",//199
       (ANTLR_UINT8*) "IS_INFINITE",//200
       (ANTLR_UINT8*) "IS_NAN",//201
       (ANTLR_UINT8*) "IS_NOT_A_SET",//202
       (ANTLR_UINT8*) "IS_NOT_EMPTY",//203
       (ANTLR_UINT8*) "IS_NOT_INFINITE",//204
       (ANTLR_UINT8*) "IS_NOT_NAN",//205
       (ANTLR_UINT8*) "IS_NOT_NULL",//206
       (ANTLR_UINT8*) "IS_NOT_OF_TYPE",//207
       (ANTLR_UINT8*) "IS_NOT_PRESENT",//208
       (ANTLR_UINT8*) "IS_NULL",//209
       (ANTLR_UINT8*) "IS_OF_TYPE",//210
       (ANTLR_UINT8*) "IS_PRESENT",//211
       (ANTLR_UINT8*) "ITERATE_VK",//212
       (ANTLR_UINT8*) "JAVA_VK",//213
       (ANTLR_UINT8*) "JOIN_DEF",//214
       (ANTLR_UINT8*) "KEEP_VK",//215
       (ANTLR_UINT8*) "LABEL_NAME",//216
       (ANTLR_UINT8*) "LANGUAGE_VK",//217
       (ANTLR_UINT8*) "LAST_VALUE_VK",//218
       (ANTLR_UINT8*) "LAST_VK",//219
       (ANTLR_UINT8*) "LEADING_VK",//220
       (ANTLR_UINT8*) "LEFT_BRACKET",//221
       (ANTLR_UINT8*) "LEFT_PAREN",//222
       (ANTLR_UINT8*) "LEFT_VK",//223
       (ANTLR_UINT8*) "LESS_THAN_OP",//224
       (ANTLR_UINT8*) "LESS_THAN_OR_EQUALS_OP",//225
       (ANTLR_UINT8*) "LIBRARY_VK",//226
       (ANTLR_UINT8*) "LIKE2_VK",//227
       (ANTLR_UINT8*) "LIKE4_VK",//228
       (ANTLR_UINT8*) "LIKEC_VK",//229
       (ANTLR_UINT8*) "LIMIT_VK",//230
       (ANTLR_UINT8*) "LINK_NAME",//231
       (ANTLR_UINT8*) "LOCAL_VK",//232
       (ANTLR_UINT8*) "LOCK_TABLE_ELEMENT",//233
       (ANTLR_UINT8*) "LOGIC_EXPR",//234
       (ANTLR_UINT8*) "LOGOFF_VK",//235
       (ANTLR_UINT8*) "LOGON_VK",//236
       (ANTLR_UINT8*) "LOG_VK",//237
       (ANTLR_UINT8*) "LONG_VK",//238
       (ANTLR_UINT8*) "LOOP_VK",//239
       (ANTLR_UINT8*) "MAIN_MODEL",//240
       (ANTLR_UINT8*) "MAIN_MODEL_NAME",//241
       (ANTLR_UINT8*) "MAP_VK",//242
       (ANTLR_UINT8*) "MAXVALUE_VK",//243
       (ANTLR_UINT8*) "MEASURES_VK",//244
       (ANTLR_UINT8*) "MEMBER_VK",//245
       (ANTLR_UINT8*) "MERGE_INSERT",//246
       (ANTLR_UINT8*) "MERGE_UPDATE",//247
       (ANTLR_UINT8*) "MERGE_VK",//248
       (ANTLR_UINT8*) "MINUS_SIGN",//249
       (ANTLR_UINT8*) "MINUTE_VK",//250
       (ANTLR_UINT8*) "MINVALUE_VK",//251
       (ANTLR_UINT8*) "MLSLABEL_VK",//252
       (ANTLR_UINT8*) "MODEL_COLUMN",//253
       (ANTLR_UINT8*) "MODEL_COLUMNS",//254
       (ANTLR_UINT8*) "MODEL_EXPRESSION",//255
       (ANTLR_UINT8*) "MODEL_RULE",//256
       (ANTLR_UINT8*) "MODEL_RULES",//257
       (ANTLR_UINT8*) "MODIFY_VK",//258
       (ANTLR_UINT8*) "MONTH_VK",//259
       (ANTLR_UINT8*) "MULTI_TABLE_MODE",//260
       (ANTLR_UINT8*) "NAME_VK",//261
       (ANTLR_UINT8*) "NATIONAL_CHAR_STRING_LIT",//262
       (ANTLR_UINT8*) "NATIVE_DATATYPE",//263
       (ANTLR_UINT8*) "NATURALN_VK",//264
       (ANTLR_UINT8*) "NATURAL_VK",//265
       (ANTLR_UINT8*) "NAV_VK",//266
       (ANTLR_UINT8*) "NCHAR_CS_VK",//267
       (ANTLR_UINT8*) "NCHAR_VK",//268
       (ANTLR_UINT8*) "NCLOB_VK",//269
       (ANTLR_UINT8*) "NESTED_VK",//270
       (ANTLR_UINT8*) "NEWLINE",//271
       (ANTLR_UINT8*) "NEW_VK",//272
       (ANTLR_UINT8*) "NOAUDIT_VK",//273
       (ANTLR_UINT8*) "NOCACHE_VK",//274
       (ANTLR_UINT8*) "NOCOPY_VK",//275
       (ANTLR_UINT8*) "NOCYCLE_VK",//276
       (ANTLR_UINT8*) "NOENTITYESCAPING_VK",//277
       (ANTLR_UINT8*) "NOMAXVALUE_VK",//278
       (ANTLR_UINT8*) "NOMINVALUE_VK",//279
       (ANTLR_UINT8*) "NOORDER_VK",//280
       (ANTLR_UINT8*) "NOSCHEMACHECK_VK",//281
       (ANTLR_UINT8*) "NOT_BETWEEN",//282
       (ANTLR_UINT8*) "NOT_EQUAL_OP",//283
       (ANTLR_UINT8*) "NOT_IN",//284
       (ANTLR_UINT8*) "NOT_LIKE",//285
       (ANTLR_UINT8*) "NO_VK",//286
       (ANTLR_UINT8*) "NULLS_VK",//287
       (ANTLR_UINT8*) "NUMBER_VK",//288
       (ANTLR_UINT8*) "NUMERIC_VK",//289
       (ANTLR_UINT8*) "NVARCHAR2_VK",//290
       (ANTLR_UINT8*) "OBJECT_VK",//291
       (ANTLR_UINT8*) "OFF_VK",//292
       (ANTLR_UINT8*) "OLD_VK",//293
       (ANTLR_UINT8*) "ONLY_VK",//294
       (ANTLR_UINT8*) "OPEN_VK",//295
       (ANTLR_UINT8*) "ORADATA_VK",//296
       (ANTLR_UINT8*) "ORDER_BY_ELEMENT",//297
       (ANTLR_UINT8*) "ORDER_BY_ELEMENTS",//298
       (ANTLR_UINT8*) "ORDINALITY_VK",//299
       (ANTLR_UINT8*) "OUT_VK",//300
       (ANTLR_UINT8*) "OVERRIDING_VK",//301
       (ANTLR_UINT8*) "OVER_VK",//302
       (ANTLR_UINT8*) "PACKAGE_NAME",//303
       (ANTLR_UINT8*) "PACKAGE_VK",//304
       (ANTLR_UINT8*) "PARALLEL_ENABLE_VK",//305
       (ANTLR_UINT8*) "PARAMETERS_VK",//306
       (ANTLR_UINT8*) "PARAMETER_NAME",//307
       (ANTLR_UINT8*) "PARENT_VK",//308
       (ANTLR_UINT8*) "PARTITION_VK",//309
       (ANTLR_UINT8*) "PASSING_VK",//310
       (ANTLR_UINT8*) "PERCENT",//311
       (ANTLR_UINT8*) "PERCENT_FOUND_VK",//312
       (ANTLR_UINT8*) "PERCENT_ISOPEN_VK",//313
       (ANTLR_UINT8*) "PERCENT_NOTFOUND_VK",//314
       (ANTLR_UINT8*) "PERCENT_ROWCOUNT_VK",//315
       (ANTLR_UINT8*) "PERCENT_ROWTYPE_VK",//316
       (ANTLR_UINT8*) "PERCENT_TYPE_VK",//317
       (ANTLR_UINT8*) "PERIOD",//318
       (ANTLR_UINT8*) "PIPELINED_VK",//319
       (ANTLR_UINT8*) "PIVOT_ALIAS",//320
       (ANTLR_UINT8*) "PIVOT_ELEMENT",//321
       (ANTLR_UINT8*) "PIVOT_IN_ELEMENT",//322
       (ANTLR_UINT8*) "PIVOT_VK",//323
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_CAST",//324
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_CONNECT_BY_ROOT",//325
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_ELSIF",//326
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_MODEL",//327
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_MULTISET",//328
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_PIVOT",//329
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_UNPIVOT",//330
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_USING",//331
       (ANTLR_UINT8*) "PLSQL_RESERVED_CLUSTERS",//332
       (ANTLR_UINT8*) "PLSQL_RESERVED_COLAUTH",//333
       (ANTLR_UINT8*) "PLSQL_RESERVED_COMPRESS",//334
       (ANTLR_UINT8*) "PLSQL_RESERVED_CRASH",//335
       (ANTLR_UINT8*) "PLSQL_RESERVED_EXCLUSIVE",//336
       (ANTLR_UINT8*) "PLSQL_RESERVED_IDENTIFIED",//337
       (ANTLR_UINT8*) "PLSQL_RESERVED_IF",//338
       (ANTLR_UINT8*) "PLSQL_RESERVED_INDEX",//339
       (ANTLR_UINT8*) "PLSQL_RESERVED_INDEXES",//340
       (ANTLR_UINT8*) "PLSQL_RESERVED_LOCK",//341
       (ANTLR_UINT8*) "PLSQL_RESERVED_MINUS",//342
       (ANTLR_UINT8*) "PLSQL_RESERVED_MODE",//343
       (ANTLR_UINT8*) "PLSQL_RESERVED_NOCOMPRESS",//344
       (ANTLR_UINT8*) "PLSQL_RESERVED_NOWAIT",//345
       (ANTLR_UINT8*) "PLSQL_RESERVED_RESOURCE",//346
       (ANTLR_UINT8*) "PLSQL_RESERVED_SHARE",//347
       (ANTLR_UINT8*) "PLSQL_RESERVED_START",//348
       (ANTLR_UINT8*) "PLSQL_RESERVED_TABAUTH",//349
       (ANTLR_UINT8*) "PLSQL_RESERVED_VIEWS",//350
       (ANTLR_UINT8*) "PLS_INTEGER_VK",//351
       (ANTLR_UINT8*) "PLUS_SIGN",//352
       (ANTLR_UINT8*) "POSITIVEN_VK",//353
       (ANTLR_UINT8*) "POSITIVE_VK",//354
       (ANTLR_UINT8*) "PRAGMA_VK",//355
       (ANTLR_UINT8*) "PRECEDING_VK",//356
       (ANTLR_UINT8*) "PRECISION",//357
       (ANTLR_UINT8*) "PRECISION_VK",//358
       (ANTLR_UINT8*) "PREDICTION_FUNCTION",//359
       (ANTLR_UINT8*) "PROCEDURE_NAME",//360
       (ANTLR_UINT8*) "PROMPT",//361
       (ANTLR_UINT8*) "QS_ANGLE",//362
       (ANTLR_UINT8*) "QS_BRACE",//363
       (ANTLR_UINT8*) "QS_BRACK",//364
       (ANTLR_UINT8*) "QS_OTHER",//365
       (ANTLR_UINT8*) "QS_OTHER_CH",//366
       (ANTLR_UINT8*) "QS_PAREN",//367
       (ANTLR_UINT8*) "QUERY_NAME",//368
       (ANTLR_UINT8*) "QUESTION_MARK",//369
       (ANTLR_UINT8*) "QUOTE",//370
       (ANTLR_UINT8*) "RAISE_VK",//371
       (ANTLR_UINT8*) "RANGE_VK",//372
       (ANTLR_UINT8*) "RAW_VK",//373
       (ANTLR_UINT8*) "READ_VK",//374
       (ANTLR_UINT8*) "REAL_VK",//375
       (ANTLR_UINT8*) "RECORD_NAME",//376
       (ANTLR_UINT8*) "REFERENCE_MODEL_NAME",//377
       (ANTLR_UINT8*) "REFERENCE_VK",//378
       (ANTLR_UINT8*) "REFERENCING_VK",//379
       (ANTLR_UINT8*) "REF_VK",//380
       (ANTLR_UINT8*) "REGULAR_ID",//381
       (ANTLR_UINT8*) "REJECT_VK",//382
       (ANTLR_UINT8*) "RELIES_ON_VK",//383
       (ANTLR_UINT8*) "RENAME_VK",//384
       (ANTLR_UINT8*) "REPLACE_VK",//385
       (ANTLR_UINT8*) "RESPECT_VK",//386
       (ANTLR_UINT8*) "RESTRICT_REFERENCES_VK",//387
       (ANTLR_UINT8*) "RESULT_CACHE_VK",//388
       (ANTLR_UINT8*) "RETURN_VK",//389
       (ANTLR_UINT8*) "REUSE_VK",//390
       (ANTLR_UINT8*) "REVERSE_VK",//391
       (ANTLR_UINT8*) "RIGHT_BRACKET",//392
       (ANTLR_UINT8*) "RIGHT_PAREN",//393
       (ANTLR_UINT8*) "RIGHT_VK",//394
       (ANTLR_UINT8*) "ROLLBACK_SEGMENT_NAME",//395
       (ANTLR_UINT8*) "ROLLBACK_VK",//396
       (ANTLR_UINT8*) "ROLLUP_VK",//397
       (ANTLR_UINT8*) "ROUTINE_CALL",//398
       (ANTLR_UINT8*) "ROUTINE_NAME",//399
       (ANTLR_UINT8*) "ROWID_VK",//400
       (ANTLR_UINT8*) "ROWS_VK",//401
       (ANTLR_UINT8*) "ROW_VK",//402
       (ANTLR_UINT8*) "RULES_VK",//403
       (ANTLR_UINT8*) "SAMPLE_VK",//404
       (ANTLR_UINT8*) "SAVEPOINT_NAME",//405
       (ANTLR_UINT8*) "SAVEPOINT_VK",//406
       (ANTLR_UINT8*) "SCHEMACHECK_VK",//407
       (ANTLR_UINT8*) "SCHEMA_NAME",//408
       (ANTLR_UINT8*) "SCHEMA_VK",//409
       (ANTLR_UINT8*) "SCN_VK",//410
       (ANTLR_UINT8*) "SEARCHED_CASE",//411
       (ANTLR_UINT8*) "SEARCH_VK",//412
       (ANTLR_UINT8*) "SECOND_VK",//413
       (ANTLR_UINT8*) "SEED_VK",//414
       (ANTLR_UINT8*) "SELECTED_TABLEVIEW",//415
       (ANTLR_UINT8*) "SELECT_ITEM",//416
       (ANTLR_UINT8*) "SELECT_LIST",//417
       (ANTLR_UINT8*) "SELECT_MODE",//418
       (ANTLR_UINT8*) "SELECT_STATEMENT",//419
       (ANTLR_UINT8*) "SELF_VK",//420
       (ANTLR_UINT8*) "SEMICOLON",//421
       (ANTLR_UINT8*) "SEPARATOR",//422
       (ANTLR_UINT8*) "SEQUENCE_NAME",//423
       (ANTLR_UINT8*) "SEQUENCE_VK",//424
       (ANTLR_UINT8*) "SEQUENTIAL_VK",//425
       (ANTLR_UINT8*) "SERIALIZABLE_VK",//426
       (ANTLR_UINT8*) "SERIALLY_REUSABLE_VK",//427
       (ANTLR_UINT8*) "SERVERERROR_VK",//428
       (ANTLR_UINT8*) "SESSIONTIMEZONE_VK",//429
       (ANTLR_UINT8*) "SET_VK",//430
       (ANTLR_UINT8*) "SHOW_VK",//431
       (ANTLR_UINT8*) "SHUTDOWN_VK",//432
       (ANTLR_UINT8*) "SIBLINGS_VK",//433
       (ANTLR_UINT8*) "SIGNTYPE_VK",//434
       (ANTLR_UINT8*) "SIMPLE_CASE",//435
       (ANTLR_UINT8*) "SIMPLE_INTEGER_VK",//436
       (ANTLR_UINT8*) "SIMPLE_LETTER",//437
       (ANTLR_UINT8*) "SINGLE_TABLE_MODE",//438
       (ANTLR_UINT8*) "SINGLE_VK",//439
       (ANTLR_UINT8*) "SKIP_VK",//440
       (ANTLR_UINT8*) "SMALLINT_VK",//441
       (ANTLR_UINT8*) "SOLIDUS",//442
       (ANTLR_UINT8*) "SOME_VK",//443
       (ANTLR_UINT8*) "SPACE",//444
       (ANTLR_UINT8*) "SPECIFICATION_VK",//445
       (ANTLR_UINT8*) "SQL92_RESERVED_ALL",//446
       (ANTLR_UINT8*) "SQL92_RESERVED_ALTER",//447
       (ANTLR_UINT8*) "SQL92_RESERVED_AND",//448
       (ANTLR_UINT8*) "SQL92_RESERVED_ANY",//449
       (ANTLR_UINT8*) "SQL92_RESERVED_AS",//450
       (ANTLR_UINT8*) "SQL92_RESERVED_ASC",//451
       (ANTLR_UINT8*) "SQL92_RESERVED_BEGIN",//452
       (ANTLR_UINT8*) "SQL92_RESERVED_BETWEEN",//453
       (ANTLR_UINT8*) "SQL92_RESERVED_BY",//454
       (ANTLR_UINT8*) "SQL92_RESERVED_CASE",//455
       (ANTLR_UINT8*) "SQL92_RESERVED_CHECK",//456
       (ANTLR_UINT8*) "SQL92_RESERVED_CONNECT",//457
       (ANTLR_UINT8*) "SQL92_RESERVED_CREATE",//458
       (ANTLR_UINT8*) "SQL92_RESERVED_CURRENT",//459
       (ANTLR_UINT8*) "SQL92_RESERVED_CURSOR",//460
       (ANTLR_UINT8*) "SQL92_RESERVED_DATE",//461
       (ANTLR_UINT8*) "SQL92_RESERVED_DECLARE",//462
       (ANTLR_UINT8*) "SQL92_RESERVED_DEFAULT",//463
       (ANTLR_UINT8*) "SQL92_RESERVED_DELETE",//464
       (ANTLR_UINT8*) "SQL92_RESERVED_DESC",//465
       (ANTLR_UINT8*) "SQL92_RESERVED_DISTINCT",//466
       (ANTLR_UINT8*) "SQL92_RESERVED_DROP",//467
       (ANTLR_UINT8*) "SQL92_RESERVED_ELSE",//468
       (ANTLR_UINT8*) "SQL92_RESERVED_END",//469
       (ANTLR_UINT8*) "SQL92_RESERVED_EXCEPTION",//470
       (ANTLR_UINT8*) "SQL92_RESERVED_EXISTS",//471
       (ANTLR_UINT8*) "SQL92_RESERVED_FALSE",//472
       (ANTLR_UINT8*) "SQL92_RESERVED_FETCH",//473
       (ANTLR_UINT8*) "SQL92_RESERVED_FOR",//474
       (ANTLR_UINT8*) "SQL92_RESERVED_FROM",//475
       (ANTLR_UINT8*) "SQL92_RESERVED_GOTO",//476
       (ANTLR_UINT8*) "SQL92_RESERVED_GRANT",//477
       (ANTLR_UINT8*) "SQL92_RESERVED_GROUP",//478
       (ANTLR_UINT8*) "SQL92_RESERVED_HAVING",//479
       (ANTLR_UINT8*) "SQL92_RESERVED_IN",//480
       (ANTLR_UINT8*) "SQL92_RESERVED_INSERT",//481
       (ANTLR_UINT8*) "SQL92_RESERVED_INTERSECT",//482
       (ANTLR_UINT8*) "SQL92_RESERVED_INTO",//483
       (ANTLR_UINT8*) "SQL92_RESERVED_IS",//484
       (ANTLR_UINT8*) "SQL92_RESERVED_LIKE",//485
       (ANTLR_UINT8*) "SQL92_RESERVED_NOT",//486
       (ANTLR_UINT8*) "SQL92_RESERVED_NULL",//487
       (ANTLR_UINT8*) "SQL92_RESERVED_OF",//488
       (ANTLR_UINT8*) "SQL92_RESERVED_ON",//489
       (ANTLR_UINT8*) "SQL92_RESERVED_OPTION",//490
       (ANTLR_UINT8*) "SQL92_RESERVED_OR",//491
       (ANTLR_UINT8*) "SQL92_RESERVED_ORDER",//492
       (ANTLR_UINT8*) "SQL92_RESERVED_OVERLAPS",//493
       (ANTLR_UINT8*) "SQL92_RESERVED_PRIOR",//494
       (ANTLR_UINT8*) "SQL92_RESERVED_PROCEDURE",//495
       (ANTLR_UINT8*) "SQL92_RESERVED_PUBLIC",//496
       (ANTLR_UINT8*) "SQL92_RESERVED_REVOKE",//497
       (ANTLR_UINT8*) "SQL92_RESERVED_SELECT",//498
       (ANTLR_UINT8*) "SQL92_RESERVED_SIZE",//499
       (ANTLR_UINT8*) "SQL92_RESERVED_TABLE",//500
       (ANTLR_UINT8*) "SQL92_RESERVED_THE",//501
       (ANTLR_UINT8*) "SQL92_RESERVED_THEN",//502
       (ANTLR_UINT8*) "SQL92_RESERVED_TO",//503
       (ANTLR_UINT8*) "SQL92_RESERVED_TRUE",//504
       (ANTLR_UINT8*) "SQL92_RESERVED_UNION",//505
       (ANTLR_UINT8*) "SQL92_RESERVED_UNIQUE",//506
       (ANTLR_UINT8*) "SQL92_RESERVED_UPDATE",//507
       (ANTLR_UINT8*) "SQL92_RESERVED_VALUES",//508
       (ANTLR_UINT8*) "SQL92_RESERVED_VIEW",//509
       (ANTLR_UINT8*) "SQL92_RESERVED_WHEN",//510
       (ANTLR_UINT8*) "SQL92_RESERVED_WHERE",//511
       (ANTLR_UINT8*) "SQL92_RESERVED_WITH",//512
       (ANTLR_UINT8*) "SQLDATA_VK",//513
       (ANTLR_UINT8*) "STANDALONE_VK",//514
       (ANTLR_UINT8*) "STANDARD_FUNCTION",//515
       (ANTLR_UINT8*) "STARTUP_VK",//516
       (ANTLR_UINT8*) "STATIC_RETURNING",//517
       (ANTLR_UINT8*) "STATIC_VK",//518
       (ANTLR_UINT8*) "STATISTICS_VK",//519
       (ANTLR_UINT8*) "STRING_VK",//520
       (ANTLR_UINT8*) "SUBMULTISET_VK",//521
       (ANTLR_UINT8*) "SUBPARTITION_VK",//522
       (ANTLR_UINT8*) "SUBQUERY",//523
       (ANTLR_UINT8*) "SUSPEND_VK",//524
       (ANTLR_UINT8*) "TABLEVIEW_NAME",//525
       (ANTLR_UINT8*) "TABLE_ELEMENT",//526
       (ANTLR_UINT8*) "TABLE_EXPRESSION",//527
       (ANTLR_UINT8*) "TABLE_REF",//528
       (ANTLR_UINT8*) "TABLE_REF_ELEMENT",//529
       (ANTLR_UINT8*) "TABLE_VAR_NAME",//530
       (ANTLR_UINT8*) "TILDE_OPERATOR_PART",//531
       (ANTLR_UINT8*) "TIMESTAMP_LTZ_UNCONSTRAINED_VK",//532
       (ANTLR_UINT8*) "TIMESTAMP_TZ_UNCONSTRAINED_VK",//533
       (ANTLR_UINT8*) "TIMESTAMP_UNCONSTRAINED_VK",//534
       (ANTLR_UINT8*) "TIMESTAMP_VK",//535
       (ANTLR_UINT8*) "TIMEZONE_ABBR_VK",//536
       (ANTLR_UINT8*) "TIMEZONE_HOUR_VK",//537
       (ANTLR_UINT8*) "TIMEZONE_MINUTE_VK",//538
       (ANTLR_UINT8*) "TIMEZONE_REGION_VK",//539
       (ANTLR_UINT8*) "TIME_VK",//540
       (ANTLR_UINT8*) "TRAILING_VK",//541
       (ANTLR_UINT8*) "TRANSLATE_VK",//542
       (ANTLR_UINT8*) "TREAT_VK",//543
       (ANTLR_UINT8*) "TRIGGER_NAME",//544
       (ANTLR_UINT8*) "TRIM_VK",//545
       (ANTLR_UINT8*) "TRUNCATE_VK",//546
       (ANTLR_UINT8*) "TYPE_NAME",//547
       (ANTLR_UINT8*) "TYPE_VK",//548
       (ANTLR_UINT8*) "T_BINDVAR_NAME",//549
       (ANTLR_UINT8*) "T_COLUMN_ALIAS",//550
       (ANTLR_UINT8*) "T_COLUMN_LIST",//551
       (ANTLR_UINT8*) "T_COLUMN_NAME",//552
       (ANTLR_UINT8*) "T_COND_AND",//553
       (ANTLR_UINT8*) "T_COND_AND_SEQ",//554
       (ANTLR_UINT8*) "T_COND_BETWEEN",//555
       (ANTLR_UINT8*) "T_COND_COMPARISON",//556
       (ANTLR_UINT8*) "T_COND_EQUALS_PATH",//557
       (ANTLR_UINT8*) "T_COND_EXISTS",//558
       (ANTLR_UINT8*) "T_COND_GROUP_COMPARISON",//559
       (ANTLR_UINT8*) "T_COND_IN",//560
       (ANTLR_UINT8*) "T_COND_IS",//561
       (ANTLR_UINT8*) "T_COND_IS_ANY",//562
       (ANTLR_UINT8*) "T_COND_IS_A_SET",//563
       (ANTLR_UINT8*) "T_COND_IS_EMPTY",//564
       (ANTLR_UINT8*) "T_COND_IS_OF_TYPE",//565
       (ANTLR_UINT8*) "T_COND_IS_PRESENT",//566
       (ANTLR_UINT8*) "T_COND_LIKE",//567
       (ANTLR_UINT8*) "T_COND_MEMEBER",//568
       (ANTLR_UINT8*) "T_COND_NOT",//569
       (ANTLR_UINT8*) "T_COND_OR",//570
       (ANTLR_UINT8*) "T_COND_OR_SEQ",//571
       (ANTLR_UINT8*) "T_COND_PAREN",//572
       (ANTLR_UINT8*) "T_COND_REGEXP_LIKE",//573
       (ANTLR_UINT8*) "T_COND_SUBMULTISET",//574
       (ANTLR_UINT8*) "T_COND_UNDER_PATH",//575
       (ANTLR_UINT8*) "T_DBLINK_NAME",//576
       (ANTLR_UINT8*) "T_DECL",//577
       (ANTLR_UINT8*) "T_FOR_UPDATE_CLAUSE",//578
       (ANTLR_UINT8*) "T_FROM",//579
       (ANTLR_UINT8*) "T_FUNCTION_NAME",//580
       (ANTLR_UINT8*) "T_GROUP_BY",//581
       (ANTLR_UINT8*) "T_HIERARCHICAL",//582
       (ANTLR_UINT8*) "T_IDENTIFIER",//583
       (ANTLR_UINT8*) "T_JOINING_CLAUSE",//584
       (ANTLR_UINT8*) "T_MODEL",//585
       (ANTLR_UINT8*) "T_OPERATOR_BINARY",//586
       (ANTLR_UINT8*) "T_OPERATOR_PART",//587
       (ANTLR_UINT8*) "T_OPERATOR_UNARY",//588
       (ANTLR_UINT8*) "T_ORDER_BY_CLAUSE",//589
       (ANTLR_UINT8*) "T_PACKAGE_NAME",//590
       (ANTLR_UINT8*) "T_RESERVED",//591
       (ANTLR_UINT8*) "T_SCHEMA_NAME",//592
       (ANTLR_UINT8*) "T_SELECT",//593
       (ANTLR_UINT8*) "T_SELECT_COLUMN",//594
       (ANTLR_UINT8*) "T_SUBQUERY",//595
       (ANTLR_UINT8*) "T_TABLE_ALIAS",//596
       (ANTLR_UINT8*) "T_TABLE_CAST",//597
       (ANTLR_UINT8*) "T_TABLE_NAME",//598
       (ANTLR_UINT8*) "T_TABLE_REF",//599
       (ANTLR_UINT8*) "T_UNION",//600
       (ANTLR_UINT8*) "T_UNKNOWN",//601
       (ANTLR_UINT8*) "T_USE",//602
       (ANTLR_UINT8*) "T_WHERE",//603
       (ANTLR_UINT8*) "T_WITH",//604
       (ANTLR_UINT8*) "UNARY_OPERATOR",//605
       (ANTLR_UINT8*) "UNBOUNDED_VK",//606
       (ANTLR_UINT8*) "UNDERSCORE",//607
       (ANTLR_UINT8*) "UNDER_VK",//608
       (ANTLR_UINT8*) "UNLIMITED_VK",//609
       (ANTLR_UINT8*) "UNPIVOT_IN_ELEMENT",//610
       (ANTLR_UINT8*) "UNPIVOT_VK",//611
       (ANTLR_UINT8*) "UNSIGNED_INTEGER",//612
       (ANTLR_UINT8*) "UNTIL_VK",//613
       (ANTLR_UINT8*) "UPDATED_VK",//614
       (ANTLR_UINT8*) "UPSERT_VK",//615
       (ANTLR_UINT8*) "UROWID_VK",//616
       (ANTLR_UINT8*) "VALIDATE_VK",//617
       (ANTLR_UINT8*) "VALUE_VK",//618
       (ANTLR_UINT8*) "VARCHAR2_VK",//619
       (ANTLR_UINT8*) "VARCHAR_VK",//620
       (ANTLR_UINT8*) "VARIABLE_NAME",//621
       (ANTLR_UINT8*) "VECTOR_EXPR",//622
       (ANTLR_UINT8*) "VERSIONS_VK",//623
       (ANTLR_UINT8*) "VERSION_VK",//624
       (ANTLR_UINT8*) "VERTICAL_BAR",//625
       (ANTLR_UINT8*) "WAIT_VK",//626
       (ANTLR_UINT8*) "WELLFORMED_VK",//627
       (ANTLR_UINT8*) "WITHIN_VK",//628
       (ANTLR_UINT8*) "WORK_VK",//629
       (ANTLR_UINT8*) "WRITE_VK",//630
       (ANTLR_UINT8*) "XMLAGG_VK",//631
       (ANTLR_UINT8*) "XMLATTRIBUTES_VK",//632
       (ANTLR_UINT8*) "XMLCAST_VK",//633
       (ANTLR_UINT8*) "XMLCOLATTVAL_VK",//634
       (ANTLR_UINT8*) "XMLELEMENT_VK",//635
       (ANTLR_UINT8*) "XMLEXISTS_VK",//636
       (ANTLR_UINT8*) "XMLFOREST_VK",//637
       (ANTLR_UINT8*) "XMLNAMESPACES_VK",//638
       (ANTLR_UINT8*) "XMLPARSE_VK",//639
       (ANTLR_UINT8*) "XMLPI_VK",//640
       (ANTLR_UINT8*) "XMLQUERY_VK",//641
       (ANTLR_UINT8*) "XMLROOT_VK",//642
       (ANTLR_UINT8*) "XMLSERIALIZE_VK",//643
       (ANTLR_UINT8*) "XMLTABLE_VK",//644
       (ANTLR_UINT8*) "XML_ALIAS",//645
       (ANTLR_UINT8*) "XML_COLUMN",//646
       (ANTLR_UINT8*) "XML_COLUMN_NAME",//647
       (ANTLR_UINT8*) "XML_ELEMENT",//648
       (ANTLR_UINT8*) "XML_VK",//649
       (ANTLR_UINT8*) "YEAR_VK",//650
       (ANTLR_UINT8*) "YES_VK",//651
       (ANTLR_UINT8*) "YMINTERVAL_UNCONSTRAINED_VK",//652
       (ANTLR_UINT8*) "ZV",//653
       };

/** String literals used by OracleDMLLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR_UCHAR	lit_1[]  = { 0x2E, 0x2E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_2[]  = { 0x2A, 0x2A,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_3[]  = { 0x3A, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_4[]  = { 0x3C, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_5[]  = { 0x3E, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_6[]  = { 0x21, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_7[]  = { 0x3C, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_8[]  = { 0x5E, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_9[]  = { 0x7E, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_10[]  = { 0x7C, 0x7C,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_11[]  = { 0x2D, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_12[]  = { 0x2F, 0x2A,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_13[]  = { 0x2A, 0x2F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_14[]  = { 0x50, 0x52, 0x4F, 0x4D, 0x50, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_15[]  = { 0x41, 0x4C, 0x4C,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_16[]  = { 0x41, 0x4C, 0x54, 0x45, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_17[]  = { 0x41, 0x4E, 0x44,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_18[]  = { 0x41, 0x4E, 0x59,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_19[]  = { 0x41, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_20[]  = { 0x41, 0x53, 0x43,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_21[]  = { 0x42, 0x45, 0x47, 0x49, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_22[]  = { 0x42, 0x45, 0x54, 0x57, 0x45, 0x45, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_23[]  = { 0x42, 0x59,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_24[]  = { 0x43, 0x41, 0x53, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_25[]  = { 0x43, 0x48, 0x45, 0x43, 0x4B,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_26[]  = { 0x43, 0x4C, 0x55, 0x53, 0x54, 0x45, 0x52, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_27[]  = { 0x43, 0x4F, 0x4C, 0x41, 0x55, 0x54, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_28[]  = { 0x43, 0x4F, 0x4D, 0x50, 0x52, 0x45, 0x53, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_29[]  = { 0x43, 0x4F, 0x4E, 0x4E, 0x45, 0x43, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_30[]  = { 0x43, 0x4F, 0x4E, 0x4E, 0x45, 0x43, 0x54, 0x5F, 0x42, 0x59, 0x5F, 0x52, 0x4F, 0x4F, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_31[]  = { 0x43, 0x52, 0x41, 0x53, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_32[]  = { 0x43, 0x52, 0x45, 0x41, 0x54, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_33[]  = { 0x43, 0x55, 0x52, 0x52, 0x45, 0x4E, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_34[]  = { 0x43, 0x55, 0x52, 0x53, 0x4F, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_35[]  = { 0x44, 0x41, 0x54, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_36[]  = { 0x44, 0x45, 0x43, 0x4C, 0x41, 0x52, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_37[]  = { 0x44, 0x45, 0x46, 0x41, 0x55, 0x4C, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_38[]  = { 0x44, 0x45, 0x4C, 0x45, 0x54, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_39[]  = { 0x44, 0x45, 0x53, 0x43,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_40[]  = { 0x44, 0x49, 0x53, 0x54, 0x49, 0x4E, 0x43, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_41[]  = { 0x44, 0x52, 0x4F, 0x50,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_42[]  = { 0x45, 0x4C, 0x53, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_43[]  = { 0x45, 0x4E, 0x44,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_44[]  = { 0x45, 0x58, 0x43, 0x45, 0x50, 0x54, 0x49, 0x4F, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_45[]  = { 0x45, 0x58, 0x43, 0x4C, 0x55, 0x53, 0x49, 0x56, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_46[]  = { 0x45, 0x58, 0x49, 0x53, 0x54, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_47[]  = { 0x46, 0x41, 0x4C, 0x53, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_48[]  = { 0x46, 0x45, 0x54, 0x43, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_49[]  = { 0x46, 0x4F, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_50[]  = { 0x46, 0x52, 0x4F, 0x4D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_51[]  = { 0x47, 0x4F, 0x54, 0x4F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_52[]  = { 0x47, 0x52, 0x41, 0x4E, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_53[]  = { 0x47, 0x52, 0x4F, 0x55, 0x50,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_54[]  = { 0x48, 0x41, 0x56, 0x49, 0x4E, 0x47,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_55[]  = { 0x49, 0x44, 0x45, 0x4E, 0x54, 0x49, 0x46, 0x49, 0x45, 0x44,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_56[]  = { 0x49, 0x46,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_57[]  = { 0x49, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_58[]  = { 0x49, 0x4E, 0x44, 0x45, 0x58,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_59[]  = { 0x49, 0x4E, 0x44, 0x45, 0x58, 0x45, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_60[]  = { 0x49, 0x4E, 0x53, 0x45, 0x52, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_61[]  = { 0x49, 0x4E, 0x54, 0x45, 0x52, 0x53, 0x45, 0x43, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_62[]  = { 0x49, 0x4E, 0x54, 0x4F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_63[]  = { 0x49, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_64[]  = { 0x4C, 0x49, 0x4B, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_65[]  = { 0x4C, 0x4F, 0x43, 0x4B,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_66[]  = { 0x4D, 0x49, 0x4E, 0x55, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_67[]  = { 0x4D, 0x4F, 0x44, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_68[]  = { 0x4E, 0x4F, 0x43, 0x4F, 0x4D, 0x50, 0x52, 0x45, 0x53, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_69[]  = { 0x4E, 0x4F, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_70[]  = { 0x4E, 0x4F, 0x57, 0x41, 0x49, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_71[]  = { 0x4E, 0x55, 0x4C, 0x4C,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_72[]  = { 0x4F, 0x46,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_73[]  = { 0x4F, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_74[]  = { 0x4F, 0x50, 0x54, 0x49, 0x4F, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_75[]  = { 0x4F, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_76[]  = { 0x4F, 0x52, 0x44, 0x45, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_77[]  = { 0x4F, 0x56, 0x45, 0x52, 0x4C, 0x41, 0x50, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_78[]  = { 0x50, 0x52, 0x49, 0x4F, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_79[]  = { 0x50, 0x52, 0x4F, 0x43, 0x45, 0x44, 0x55, 0x52, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_80[]  = { 0x50, 0x55, 0x42, 0x4C, 0x49, 0x43,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_81[]  = { 0x52, 0x45, 0x53, 0x4F, 0x55, 0x52, 0x43, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_82[]  = { 0x52, 0x45, 0x56, 0x4F, 0x4B, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_83[]  = { 0x53, 0x45, 0x4C, 0x45, 0x43, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_84[]  = { 0x53, 0x48, 0x41, 0x52, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_85[]  = { 0x53, 0x49, 0x5A, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_86[]  = { 0x53, 0x54, 0x41, 0x52, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_87[]  = { 0x54, 0x41, 0x42, 0x41, 0x55, 0x54, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_88[]  = { 0x54, 0x41, 0x42, 0x4C, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_89[]  = { 0x54, 0x48, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_90[]  = { 0x54, 0x48, 0x45, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_91[]  = { 0x54, 0x4F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_92[]  = { 0x54, 0x52, 0x55, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_93[]  = { 0x55, 0x4E, 0x49, 0x4F, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_94[]  = { 0x55, 0x4E, 0x49, 0x51, 0x55, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_95[]  = { 0x55, 0x50, 0x44, 0x41, 0x54, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_96[]  = { 0x56, 0x41, 0x4C, 0x55, 0x45, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_97[]  = { 0x56, 0x49, 0x45, 0x57,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_98[]  = { 0x56, 0x49, 0x45, 0x57, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_99[]  = { 0x57, 0x48, 0x45, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_100[]  = { 0x57, 0x48, 0x45, 0x52, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_101[]  = { 0x57, 0x49, 0x54, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_102[]  = { 0x43, 0x41, 0x53, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_103[]  = { 0x4D, 0x55, 0x4C, 0x54, 0x49, 0x53, 0x45, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_104[]  = { 0x55, 0x53, 0x49, 0x4E, 0x47,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_105[]  = { 0x4D, 0x4F, 0x44, 0x45, 0x4C,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_106[]  = { 0x45, 0x4C, 0x53, 0x49, 0x46,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_107[]  = { 0x50, 0x49, 0x56, 0x4F, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_108[]  = { 0x55, 0x4E, 0x50, 0x49, 0x56, 0x4F, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_109[]  = { 0x40, 0x21,  antlr3::ANTLR_STRING_TERMINATOR};

}


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;

namespace  Antlr3BackendImpl  {

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



//     // buffer (queue) to hold the emit()'d tokens
//     // private LinkedList<Token> tokenBuffer = new LinkedList<Token>();

//     // public void emit(Token t) {
//     //     tokenBuffer.add(t);
//     // }

//     // private void advanceInput(){
//     //     state.tokenStartCharIndex = input.index();
//     //     state.tokenStartCharPositionInLine = input.getCharPositionInLine();
//     //     state.tokenStartLine = input.getLine();
//     // }


    /**
     * Return a token from this source; i.e., match a token on the char stream.
     */
    // public Token nextToken() {
    //     while (true) {
    //         if (tokenBuffer.size() == 0) {
    //             state.token = null;
    //             state.channel = Token.DEFAULT_CHANNEL;
    //             state.tokenStartCharIndex = input.index();
    //             state.tokenStartCharPositionInLine = input.getCharPositionInLine();
    //             state.tokenStartLine = input.getLine();
    //             state.text = null;
    //             if (input.LA(1) == CharStream.EOF) {
    //                 return Token.EOF_TOKEN;
    //             }
    //             try {
    //                 int m = input.mark();
    //                 state.backtracking = 1;
    //                 state.failed = false;
    //                 mTokens();
    //                 state.backtracking = 0;

    //                 if (state.failed) {
    //                     input.rewind(m);
    //                     input.consume();
    //                 } else {
    //                     emit();
    //                 }
    //             } catch (RecognitionException re) {
    //                 // shouldn't happen in backtracking mode, but...
    //                 reportError(re);
    //                 recover(re);
    //             }
    //         } else {
    //             Token result = tokenBuffer.poll();
    //             if (result == Token.SKIP_TOKEN || result.getType() == Token.INVALID_TOKEN_TYPE || result == null)
    //             {
    //                 // discard
    //                 // SKIP & INVALID
    //                 // tokens
    //                 continue;
    //             }
    //             return result;
    //         }
    //     }
    // }


OracleDMLLexer::~OracleDMLLexer()
{
}

void
OracleDMLLexer::reset()
{
    this->get_rec()->reset();
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "OracleDMLLexer.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* OracleDMLLexer::getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called OracleDMLLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pOracleDMLLexer initialized for the lex start
 *     - Fail NULL
 */
OracleDMLLexer::OracleDMLLexer(StreamType* instream)
    :OracleDMLLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, NULL)
{
	// See if we can create a new lexer with the standard constructor
	//
	this->init(instream );
}

/** \brief Create a new lexer called OracleDMLLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pOracleDMLLexer initialized for the lex start
 *     - Fail NULL
 */
OracleDMLLexer::OracleDMLLexer(StreamType* instream, RecognizerSharedStateType* state)
    :OracleDMLLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, state)
{
	this->init(instream );
}

void OracleDMLLexer::init(StreamType* instream)
{
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in OracleDMLLexer.h here so you can get a sense
     * of what goes where.
     */

}


/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( FOR_NOTATION | NATIONAL_CHAR_STRING_LIT | BIT_STRING_LIT | HEX_STRING_LIT | PERIOD | EXACT_NUM_LIT | CHAR_STRING | CHAR_STRING_PERL | DELIMITED_ID | PERCENT | AMPERSAND | LEFT_PAREN | RIGHT_PAREN | DOUBLE_ASTERISK | ASTERISK | PLUS_SIGN | COMMA | SOLIDUS | AT_SIGN | ASSIGN_OP | BINDVAR | COLON | SEMICOLON | LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP | GREATER_THAN_OR_EQUALS_OP | NOT_EQUAL_OP | CARRET_OPERATOR_PART | TILDE_OPERATOR_PART | EXCLAMATION_OPERATOR_PART | GREATER_THAN_OP | CONCATENATION_OP | VERTICAL_BAR | EQUALS_OP | LEFT_BRACKET | RIGHT_BRACKET | INTRODUCER | SEPARATOR | PROMPT | SQL92_RESERVED_ALL | SQL92_RESERVED_ALTER | SQL92_RESERVED_AND | SQL92_RESERVED_ANY | SQL92_RESERVED_AS | SQL92_RESERVED_ASC | SQL92_RESERVED_BEGIN | SQL92_RESERVED_BETWEEN | SQL92_RESERVED_BY | SQL92_RESERVED_CASE | SQL92_RESERVED_CHECK | PLSQL_RESERVED_CLUSTERS | PLSQL_RESERVED_COLAUTH | PLSQL_RESERVED_COMPRESS | SQL92_RESERVED_CONNECT | PLSQL_NON_RESERVED_CONNECT_BY_ROOT | PLSQL_RESERVED_CRASH | SQL92_RESERVED_CREATE | SQL92_RESERVED_CURRENT | SQL92_RESERVED_CURSOR | SQL92_RESERVED_DATE | SQL92_RESERVED_DECLARE | SQL92_RESERVED_DEFAULT | SQL92_RESERVED_DELETE | SQL92_RESERVED_DESC | SQL92_RESERVED_DISTINCT | SQL92_RESERVED_DROP | SQL92_RESERVED_ELSE | SQL92_RESERVED_END | SQL92_RESERVED_EXCEPTION | PLSQL_RESERVED_EXCLUSIVE | SQL92_RESERVED_EXISTS | SQL92_RESERVED_FALSE | SQL92_RESERVED_FETCH | SQL92_RESERVED_FOR | SQL92_RESERVED_FROM | SQL92_RESERVED_GOTO | SQL92_RESERVED_GRANT | SQL92_RESERVED_GROUP | SQL92_RESERVED_HAVING | PLSQL_RESERVED_IDENTIFIED | PLSQL_RESERVED_IF | SQL92_RESERVED_IN | PLSQL_RESERVED_INDEX | PLSQL_RESERVED_INDEXES | SQL92_RESERVED_INSERT | SQL92_RESERVED_INTERSECT | SQL92_RESERVED_INTO | SQL92_RESERVED_IS | SQL92_RESERVED_LIKE | PLSQL_RESERVED_LOCK | PLSQL_RESERVED_MINUS | PLSQL_RESERVED_MODE | PLSQL_RESERVED_NOCOMPRESS | SQL92_RESERVED_NOT | PLSQL_RESERVED_NOWAIT | SQL92_RESERVED_NULL | SQL92_RESERVED_OF | SQL92_RESERVED_ON | SQL92_RESERVED_OPTION | SQL92_RESERVED_OR | SQL92_RESERVED_ORDER | SQL92_RESERVED_OVERLAPS | SQL92_RESERVED_PRIOR | SQL92_RESERVED_PROCEDURE | SQL92_RESERVED_PUBLIC | PLSQL_RESERVED_RESOURCE | SQL92_RESERVED_REVOKE | SQL92_RESERVED_SELECT | PLSQL_RESERVED_SHARE | SQL92_RESERVED_SIZE | PLSQL_RESERVED_START | PLSQL_RESERVED_TABAUTH | SQL92_RESERVED_TABLE | SQL92_RESERVED_THE | SQL92_RESERVED_THEN | SQL92_RESERVED_TO | SQL92_RESERVED_TRUE | SQL92_RESERVED_UNION | SQL92_RESERVED_UNIQUE | SQL92_RESERVED_UPDATE | SQL92_RESERVED_VALUES | SQL92_RESERVED_VIEW | PLSQL_RESERVED_VIEWS | SQL92_RESERVED_WHEN | SQL92_RESERVED_WHERE | SQL92_RESERVED_WITH | PLSQL_NON_RESERVED_CAST | PLSQL_NON_RESERVED_MULTISET | PLSQL_NON_RESERVED_USING | PLSQL_NON_RESERVED_MODEL | PLSQL_NON_RESERVED_ELSIF | PLSQL_NON_RESERVED_PIVOT | PLSQL_NON_RESERVED_UNPIVOT | REGULAR_ID | ZV );
 */
static const ANTLR_INT32 dfa40_eot[521] =
    {
	-1, 53, 52, 52, 52, 62, -1, 52, -1, -1, -1, -1, -1, 65, -1, -1, 66, 68, 
	70, -1, -1, 73, 75, 76, 77, 78, 80, -1, -1, -1, -1, -1, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, -1, -1, 
	53, -1, 52, 52, 52, 144, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 154, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	184, 188, 189, 52, 52, 52, 52, 52, 195, 196, 52, 199, 52, 52, 52, 52, 52, 
	52, 52, 52, 209, 52, 52, 52, 52, 52, 52, 52, 52, -1, 52, 220, 52, 52, 52, 
	52, -1, 52, 52, 52, 52, 230, 52, 232, 233, 234, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 255, 52, 52, 52, 52, 261, 
	52, 52, 52, 52, 52, 52, -1, 52, 52, 52, -1, -1, 52, 52, 52, 52, 52, -1, 
	-1, 52, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 289, -1, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, -1, 52, 303, 52, 52, 52, 52, 52, 52, 52, -1, 52, 
	-1, -1, -1, 312, 313, 52, 52, 52, 52, 52, 52, 52, 52, 52, 323, 52, 52, 
	52, 327, 52, 329, 330, 52, -1, 52, 52, 52, 52, 52, -1, 337, 338, 52, 52, 
	52, 52, 52, 52, 52, 346, 347, 348, 52, 351, 52, 52, 52, 52, 52, 52, 52, 
	52, 360, 52, 52, 52, 364, -1, 365, 52, 52, 52, 52, 52, 52, 373, 374, 52, 
	376, 52, 52, -1, 379, 52, 52, 52, 383, 52, 385, 386, -1, -1, 387, 52, 52, 
	52, 52, 392, 52, 52, 52, -1, 52, 52, 52, -1, 52, -1, -1, 400, 52, 52, 52, 
	404, 405, -1, -1, 406, 407, 52, 52, 411, 52, 52, -1, -1, -1, 414, 415, 
	-1, 52, 52, 418, 52, 52, 52, 52, 423, -1, 424, 52, 426, -1, -1, 427, 52, 
	52, 52, 431, 52, 433, -1, -1, 434, -1, 52, 436, -1, 52, 52, 52, -1, 440, 
	-1, -1, -1, 52, 52, 52, 52, -1, 445, 52, 447, 52, 52, 450, 52, -1, 52, 
	52, 454, -1, -1, -1, -1, 455, 52, 52, -1, 458, 52, -1, -1, 52, 461, -1, 
	52, 52, 464, 465, -1, -1, 52, -1, -1, 467, 52, 469, -1, 470, -1, -1, 52, 
	-1, 472, -1, 52, -1, 52, 475, 52, 478, -1, 479, -1, 480, 481, -1, 52, 52, 
	52, -1, -1, 52, 486, -1, 52, 52, -1, 52, 52, -1, -1, 491, -1, 492, -1, 
	-1, 52, -1, 52, 495, -1, 496, 52, -1, -1, -1, -1, 498, 52, 52, 52, -1, 
	52, 503, 504, 505, -1, -1, 52, 507, -1, -1, 52, -1, 509, 510, 52, 512, 
	-1, -1, -1, 513, -1, 52, -1, -1, 515, -1, -1, 52, -1, 52, 52, 52, 520, 
	-1
    };
static const ANTLR_INT32 dfa40_eof[521] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa40_min[521] =
    {
	9, 46, 39, 39, 39, 48, -1, 39, -1, -1, -1, -1, -1, 42, -1, -1, 42, 33, 
	34, -1, -1, 61, 61, 61, 61, 61, 124, -1, -1, -1, -1, -1, 73, 76, 39, 65, 
	65, 76, 65, 79, 65, 68, 73, 73, 39, 70, 69, 69, 65, 78, 65, 72, -1, -1, 
	46, -1, 67, 76, 71, 35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 73, 66, 86, 76, 68, 35, 83, 69, 85, 
	76, 65, 82, 84, 67, 83, 79, 83, 68, 67, 76, 84, 82, 79, 84, 65, 86, 69, 
	35, 35, 35, 75, 67, 78, 68, 76, 35, 35, 84, 35, 69, 83, 76, 65, 90, 65, 
	66, 69, 35, 85, 73, 68, 73, 76, 69, 69, 84, -1, 79, 35, 65, 76, 73, 87, 
	-1, 67, 79, 76, 79, 35, 69, 35, 35, 35, -1, 69, 67, 83, 65, 80, 78, 83, 
	65, 82, 69, 76, 65, 69, 67, 84, 80, 69, 35, 69, 83, 83, 67, 35, 77, 79, 
	78, 85, 73, 78, -1, 69, 69, 69, -1, -1, 69, 75, 85, 69, 84, -1, -1, 73, 
	69, -1, 82, 79, 79, 69, 82, 69, 82, 65, 35, -1, 69, 79, 73, 65, 78, 85, 
	87, 78, 72, 77, -1, 73, 35, 78, 69, 80, 69, 82, 73, 84, -1, 82, -1, -1, 
	-1, 35, 35, 75, 84, 85, 82, 69, 72, 84, 69, 79, 35, 65, 85, 84, 35, 73, 
	35, 35, 70, -1, 80, 85, 84, 69, 72, -1, 35, 35, 84, 80, 78, 84, 88, 82, 
	82, 35, 35, 35, 83, 35, 73, 79, 82, 76, 85, 75, 67, 69, 35, 84, 85, 69, 
	35, -1, 35, 78, 85, 86, 84, 71, 69, 35, 35, 69, 35, 80, 84, -1, 35, 69, 
	84, 68, 35, 67, 35, 35, -1, -1, 35, 69, 84, 69, 67, 35, 69, 78, 82, -1, 
	82, 76, 69, -1, 78, -1, -1, 35, 84, 83, 83, 35, 35, -1, -1, 35, 35, 71, 
	73, 35, 84, 83, -1, -1, -1, 35, 35, -1, 83, 78, 35, 65, 82, 69, 84, 35, 
	-1, 35, 84, 35, -1, -1, 35, 69, 79, 69, 35, 83, 35, -1, -1, 35, -1, 82, 
	35, -1, 78, 9, 85, -1, 35, -1, -1, -1, 82, 72, 83, 84, -1, 35, 84, 35, 
	69, 84, 35, 67, -1, 73, 73, 35, -1, -1, -1, -1, 35, 70, 83, -1, 35, 69, 
	-1, -1, 69, 35, -1, 80, 67, 35, 35, -1, -1, 72, -1, -1, 35, 84, 35, -1, 
	35, -1, -1, 69, -1, 35, -1, 82, -1, 83, 35, 83, 35, -1, 35, -1, 35, 35, 
	-1, 84, 79, 86, -1, -1, 73, 35, -1, 67, 84, -1, 83, 69, -1, -1, 35, -1, 
	35, -1, -1, 83, -1, 69, 35, -1, 35, 66, -1, -1, -1, -1, 35, 78, 69, 69, 
	-1, 84, 35, 35, 35, -1, -1, 83, 35, -1, -1, 89, -1, 35, 35, 68, 35, -1, 
	-1, -1, 35, -1, 95, -1, -1, 35, -1, -1, 82, -1, 79, 79, 84, 35, -1
    };
static const ANTLR_INT32 dfa40_max[521] =
    {
	126, 57, 85, 89, 39, 57, -1, 39, -1, -1, -1, -1, -1, 42, -1, -1, 42, 33, 
	122, -1, -1, 62, 61, 61, 61, 61, 124, -1, -1, -1, -1, -1, 85, 83, 39, 85, 
	82, 88, 82, 82, 65, 83, 79, 85, 39, 86, 69, 84, 82, 83, 73, 73, -1, -1, 
	46, -1, 87, 76, 84, 122, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 79, 66, 86, 84, 89, 122, 83, 69, 85, 
	78, 69, 82, 84, 83, 83, 79, 83, 68, 73, 76, 84, 82, 79, 84, 79, 86, 69, 
	122, 122, 122, 75, 67, 78, 68, 76, 122, 122, 84, 122, 69, 86, 76, 65, 90, 
	65, 66, 69, 122, 85, 80, 68, 73, 76, 69, 69, 84, -1, 79, 122, 65, 76, 73, 
	87, -1, 77, 79, 76, 79, 122, 69, 122, 122, 122, -1, 84, 67, 83, 65, 80, 
	78, 83, 65, 83, 69, 76, 65, 69, 67, 84, 80, 73, 122, 76, 83, 83, 67, 122, 
	77, 79, 78, 85, 73, 78, -1, 69, 69, 79, -1, -1, 69, 75, 85, 69, 84, -1, 
	-1, 73, 69, -1, 82, 79, 79, 69, 82, 69, 82, 76, 122, -1, 69, 81, 73, 65, 
	78, 85, 87, 82, 72, 77, -1, 73, 122, 78, 69, 80, 69, 82, 73, 84, -1, 82, 
	-1, -1, -1, 122, 122, 75, 84, 85, 82, 69, 72, 84, 69, 79, 122, 65, 85, 
	84, 122, 73, 122, 122, 70, -1, 80, 85, 84, 69, 72, -1, 122, 122, 84, 80, 
	78, 84, 88, 82, 82, 122, 122, 122, 83, 122, 73, 79, 82, 76, 85, 75, 67, 
	69, 122, 84, 85, 69, 122, -1, 122, 78, 85, 86, 84, 71, 69, 122, 122, 69, 
	122, 80, 84, -1, 122, 69, 84, 68, 122, 67, 122, 122, -1, -1, 122, 69, 84, 
	69, 67, 122, 69, 78, 82, -1, 82, 76, 69, -1, 78, -1, -1, 122, 84, 83, 83, 
	122, 122, -1, -1, 122, 122, 71, 73, 122, 84, 83, -1, -1, -1, 122, 122, 
	-1, 83, 78, 122, 65, 82, 69, 84, 122, -1, 122, 84, 122, -1, -1, 122, 69, 
	79, 69, 122, 83, 122, -1, -1, 122, -1, 82, 122, -1, 78, 32, 85, -1, 122, 
	-1, -1, -1, 82, 72, 83, 84, -1, 122, 84, 122, 69, 84, 122, 67, -1, 73, 
	73, 122, -1, -1, -1, -1, 122, 70, 83, -1, 122, 69, -1, -1, 69, 122, -1, 
	80, 67, 122, 122, -1, -1, 72, -1, -1, 122, 84, 122, -1, 122, -1, -1, 69, 
	-1, 122, -1, 82, -1, 83, 122, 83, 122, -1, 122, -1, 122, 122, -1, 84, 79, 
	86, -1, -1, 73, 122, -1, 67, 84, -1, 83, 69, -1, -1, 122, -1, 122, -1, 
	-1, 83, -1, 69, 122, -1, 122, 66, -1, -1, -1, -1, 122, 78, 69, 69, -1, 
	84, 122, 122, 122, -1, -1, 83, 122, -1, -1, 89, -1, 122, 122, 68, 122, 
	-1, -1, -1, 122, -1, 95, -1, -1, 122, -1, -1, 82, -1, 79, 79, 84, 122, 
	-1
    };
static const ANTLR_INT32 dfa40_accept[521] =
    {
	-1, -1, -1, -1, -1, -1, 7, -1, 9, 10, 11, 12, 13, -1, 16, 17, -1, -1, -1, 
	21, 23, -1, -1, -1, -1, -1, -1, 34, 35, 36, 37, 38, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, 6, -1, 
	2, -1, -1, -1, -1, 3, 4, 5, 8, 14, 15, 18, 135, 19, 20, 22, 24, 27, 25, 
	26, 31, 30, 28, 29, 32, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 48, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 44, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 81, -1, -1, -1, 82, 88, -1, -1, -1, -1, -1, 97, 98, -1, -1, 100, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 116, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 94, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, 42, 43, 45, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 68, -1, -1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 96, -1, -1, -1, -1, 
	-1, -1, -1, -1, 49, 127, -1, -1, -1, -1, -1, -1, -1, -1, -1, 60, -1, -1, 
	-1, 64, -1, 66, 67, -1, -1, -1, -1, -1, -1, 75, 76, -1, -1, -1, -1, -1, 
	-1, -1, 87, 89, 90, -1, -1, 92, -1, -1, -1, -1, -1, -1, -1, -1, 110, -1, 
	-1, -1, 115, 117, -1, -1, -1, -1, -1, -1, -1, 122, 124, -1, 126, -1, -1, 
	46, -1, -1, -1, 103, -1, 132, 41, 50, -1, -1, -1, -1, 56, -1, -1, -1, -1, 
	-1, -1, -1, 131, -1, -1, -1, 72, 73, 77, 78, -1, -1, -1, 83, -1, -1, 91, 
	130, -1, -1, 101, -1, -1, -1, -1, 109, 111, -1, 113, 118, -1, -1, -1, 129, 
	-1, 123, 125, -1, 95, -1, 39, -1, 105, -1, -1, -1, -1, 57, -1, 59, -1, 
	-1, 63, -1, -1, -1, 71, 79, -1, -1, 85, -1, -1, 99, -1, -1, 107, 108, -1, 
	119, -1, 120, 121, -1, 47, -1, -1, 52, -1, -1, 54, 58, 61, 62, -1, -1, 
	-1, -1, 84, -1, -1, -1, -1, 112, 133, -1, -1, 51, 53, -1, 65, -1, -1, -1, 
	-1, 128, 102, 106, -1, 104, -1, 69, 70, -1, 86, 93, -1, 80, -1, -1, -1, 
	-1, 55
    };
static const ANTLR_INT32 dfa40_special[521] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa40_T_empty	 =   NULL;

static const ANTLR_INT32 dfa40_T0[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T1[] =
    {
	63
    };

static const ANTLR_INT32 dfa40_T2[] =
    {
	121
    };

static const ANTLR_INT32 dfa40_T3[] =
    {
	438, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 438
    };

static const ANTLR_INT32 dfa40_T4[] =
    {
	293
    };

static const ANTLR_INT32 dfa40_T5[] =
    {
	368
    };

static const ANTLR_INT32 dfa40_T6[] =
    {
	429
    };

static const ANTLR_INT32 dfa40_T7[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 477, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T8[] =
    {
	468
    };

static const ANTLR_INT32 dfa40_T9[] =
    {
	331
    };

static const ANTLR_INT32 dfa40_T10[] =
    {
	229
    };

static const ANTLR_INT32 dfa40_T11[] =
    {
	79
    };

static const ANTLR_INT32 dfa40_T12[] =
    {
	148
    };

static const ANTLR_INT32 dfa40_T13[] =
    {
	310
    };

static const ANTLR_INT32 dfa40_T14[] =
    {
	135, 136
    };

static const ANTLR_INT32 dfa40_T15[] =
    {
	253, -1, -1, -1, 254
    };

static const ANTLR_INT32 dfa40_T16[] =
    {
	171
    };

static const ANTLR_INT32 dfa40_T17[] =
    {
	142, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 143
    };

static const ANTLR_INT32 dfa40_T18[] =
    {
	211, -1, -1, -1, -1, -1, -1, 212
    };

static const ANTLR_INT32 dfa40_T19[] =
    {
	60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 59
    };

static const ANTLR_INT32 dfa40_T20[] =
    {
	116, -1, -1, -1, -1, -1, -1, -1, 117, -1, 118, -1, 119, -1, -1, -1, 120
    };

static const ANTLR_INT32 dfa40_T21[] =
    {
	201, -1, -1, 202
    };

static const ANTLR_INT32 dfa40_T22[] =
    {
	149, -1, -1, -1, -1, -1, -1, -1, 150
    };

static const ANTLR_INT32 dfa40_T23[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 198, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T24[] =
    {
	87, -1, -1, -1, -1, -1, -1, 88, -1, -1, -1, 89, -1, -1, 90, -1, -1, 91, 
	-1, -1, 92
    };

static const ANTLR_INT32 dfa40_T25[] =
    {
	151, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 152
    };

static const ANTLR_INT32 dfa40_T26[] =
    {
	55
    };

static const ANTLR_INT32 dfa40_T27[] =
    {
	421
    };

static const ANTLR_INT32 dfa40_T28[] =
    {
	357
    };

static const ANTLR_INT32 dfa40_T29[] =
    {
	281
    };

static const ANTLR_INT32 dfa40_T30[] =
    {
	180, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 181
    };

static const ANTLR_INT32 dfa40_T31[] =
    {
	358
    };

static const ANTLR_INT32 dfa40_T32[] =
    {
	282
    };

static const ANTLR_INT32 dfa40_T33[] =
    {
	203
    };

static const ANTLR_INT32 dfa40_T34[] =
    {
	422
    };

static const ANTLR_INT32 dfa40_T35[] =
    {
	204
    };

static const ANTLR_INT32 dfa40_T36[] =
    {
	283
    };

static const ANTLR_INT32 dfa40_T37[] =
    {
	359
    };

static const ANTLR_INT32 dfa40_T38[] =
    {
	205
    };

static const ANTLR_INT32 dfa40_T39[] =
    {
	284
    };

static const ANTLR_INT32 dfa40_T40[] =
    {
	206
    };

static const ANTLR_INT32 dfa40_T41[] =
    {
	122, -1, -1, 123, 124, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 125
    };

static const ANTLR_INT32 dfa40_T42[] =
    {
	113, -1, -1, -1, -1, -1, 114, -1, -1, -1, -1, -1, 115
    };

static const ANTLR_INT32 dfa40_T43[] =
    {
	361
    };

static const ANTLR_INT32 dfa40_T44[] =
    {
	285
    };

static const ANTLR_INT32 dfa40_T45[] =
    {
	362
    };

static const ANTLR_INT32 dfa40_T46[] =
    {
	425
    };

static const ANTLR_INT32 dfa40_T47[] =
    {
	466
    };

static const ANTLR_INT32 dfa40_T48[] =
    {
	146, -1, -1, -1, -1, -1, 145
    };

static const ANTLR_INT32 dfa40_T49[] =
    {
	363
    };

static const ANTLR_INT32 dfa40_T50[] =
    {
	381
    };

static const ANTLR_INT32 dfa40_T51[] =
    {
	306
    };

static const ANTLR_INT32 dfa40_T52[] =
    {
	354
    };

static const ANTLR_INT32 dfa40_T53[] =
    {
	278
    };

static const ANTLR_INT32 dfa40_T54[] =
    {
	489
    };

static const ANTLR_INT32 dfa40_T55[] =
    {
	419
    };

static const ANTLR_INT32 dfa40_T56[] =
    {
	462
    };

static const ANTLR_INT32 dfa40_T57[] =
    {
	279
    };

static const ANTLR_INT32 dfa40_T58[] =
    {
	355
    };

static const ANTLR_INT32 dfa40_T59[] =
    {
	200
    };

static const ANTLR_INT32 dfa40_T60[] =
    {
	308
    };

static const ANTLR_INT32 dfa40_T61[] =
    {
	130, -1, 131, -1, -1, 132
    };

static const ANTLR_INT32 dfa40_T62[] =
    {
	227
    };

static const ANTLR_INT32 dfa40_T63[] =
    {
	343
    };

static const ANTLR_INT32 dfa40_T64[] =
    {
	382
    };

static const ANTLR_INT32 dfa40_T65[] =
    {
	307
    };

static const ANTLR_INT32 dfa40_T66[] =
    {
	473
    };

static const ANTLR_INT32 dfa40_T67[] =
    {
	439
    };

static const ANTLR_INT32 dfa40_T68[] =
    {
	268
    };

static const ANTLR_INT32 dfa40_T69[] =
    {
	494
    };

static const ANTLR_INT32 dfa40_T70[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 350, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T71[] =
    {
	147
    };

static const ANTLR_INT32 dfa40_T72[] =
    {
	228
    };

static const ANTLR_INT32 dfa40_T73[] =
    {
	309
    };

static const ANTLR_INT32 dfa40_T74[] =
    {
	384
    };

static const ANTLR_INT32 dfa40_T75[] =
    {
	420
    };

static const ANTLR_INT32 dfa40_T76[] =
    {
	463
    };

static const ANTLR_INT32 dfa40_T77[] =
    {
	490
    };

static const ANTLR_INT32 dfa40_T78[] =
    {
	280
    };

static const ANTLR_INT32 dfa40_T79[] =
    {
	356
    };

static const ANTLR_INT32 dfa40_T80[] =
    {
	300
    };

static const ANTLR_INT32 dfa40_T81[] =
    {
	218
    };

static const ANTLR_INT32 dfa40_T82[] =
    {
	235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 236
    };

static const ANTLR_INT32 dfa40_T83[] =
    {
	126, -1, -1, -1, -1, -1, -1, 127, -1, -1, -1, -1, -1, -1, 128, -1, -1, 
	129
    };

static const ANTLR_INT32 dfa40_T84[] =
    {
	155
    };

static const ANTLR_INT32 dfa40_T85[] =
    {
	375
    };

static const ANTLR_INT32 dfa40_T86[] =
    {
	276
    };

static const ANTLR_INT32 dfa40_T87[] =
    {
	352
    };

static const ANTLR_INT32 dfa40_T88[] =
    {
	416
    };

static const ANTLR_INT32 dfa40_T89[] =
    {
	460
    };

static const ANTLR_INT32 dfa40_T90[] =
    {
	488
    };

static const ANTLR_INT32 dfa40_T91[] =
    {
	270, -1, -1, -1, -1, -1, -1, -1, -1, -1, 271
    };

static const ANTLR_INT32 dfa40_T92[] =
    {
	72
    };

static const ANTLR_INT32 dfa40_T93[] =
    {
	194
    };

static const ANTLR_INT32 dfa40_T94[] =
    {
	295
    };

static const ANTLR_INT32 dfa40_T95[] =
    {
	214
    };

static const ANTLR_INT32 dfa40_T96[] =
    {
	74
    };

static const ANTLR_INT32 dfa40_T97[] =
    {
	370
    };

static const ANTLR_INT32 dfa40_T98[] =
    {
	366
    };

static const ANTLR_INT32 dfa40_T99[] =
    {
	173, -1, -1, -1, -1, -1, 174
    };

static const ANTLR_INT32 dfa40_T100[] =
    {
	290
    };

static const ANTLR_INT32 dfa40_T101[] =
    {
	210
    };

static const ANTLR_INT32 dfa40_T102[] =
    {
	430
    };

static const ANTLR_INT32 dfa40_T103[] =
    {
	213
    };

static const ANTLR_INT32 dfa40_T104[] =
    {
	294
    };

static const ANTLR_INT32 dfa40_T105[] =
    {
	369
    };

static const ANTLR_INT32 dfa40_T106[] =
    {
	31, 31, -1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 31, 23, 8, -1, -1, 9, 10, 6, 11, 12, 13, 14, 15, 31, 
	5, 16, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 20, 21, 27, 22, 19, 17, 33, 3, 
	35, 36, 37, 38, 39, 40, 41, 52, 52, 42, 43, 2, 45, 32, 7, 46, 47, 48, 49, 
	50, 51, 4, 52, 52, 28, -1, 29, 24, 30, -1, 52, 34, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 44, 52, 52, 7, 52, 52, 52, 52, 52, 52, 4, 52, 52, 
	-1, 26, -1, 25
    };

static const ANTLR_INT32 dfa40_T107[] =
    {
	367
    };

static const ANTLR_INT32 dfa40_T108[] =
    {
	428
    };

static const ANTLR_INT32 dfa40_T109[] =
    {
	31
    };

static const ANTLR_INT32 dfa40_T110[] =
    {
	432
    };

static const ANTLR_INT32 dfa40_T111[] =
    {
	106
    };

static const ANTLR_INT32 dfa40_T112[] =
    {
	371
    };

static const ANTLR_INT32 dfa40_T113[] =
    {
	296
    };

static const ANTLR_INT32 dfa40_T114[] =
    {
	215
    };

static const ANTLR_INT32 dfa40_T115[] =
    {
	183
    };

static const ANTLR_INT32 dfa40_T116[] =
    {
	60
    };

static const ANTLR_INT32 dfa40_T117[] =
    {
	408
    };

static const ANTLR_INT32 dfa40_T118[] =
    {
	341
    };

static const ANTLR_INT32 dfa40_T119[] =
    {
	511
    };

static const ANTLR_INT32 dfa40_T120[] =
    {
	501
    };

static const ANTLR_INT32 dfa40_T121[] =
    {
	485
    };

static const ANTLR_INT32 dfa40_T122[] =
    {
	456
    };

static const ANTLR_INT32 dfa40_T123[] =
    {
	409
    };

static const ANTLR_INT32 dfa40_T124[] =
    {
	342
    };

static const ANTLR_INT32 dfa40_T125[] =
    {
	267
    };

static const ANTLR_INT32 dfa40_T126[] =
    {
	265
    };

static const ANTLR_INT32 dfa40_T127[] =
    {
	339
    };

static const ANTLR_INT32 dfa40_T128[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 185, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 186, 187, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T129[] =
    {
	182
    };

static const ANTLR_INT32 dfa40_T130[] =
    {
	266
    };

static const ANTLR_INT32 dfa40_T131[] =
    {
	340
    };

static const ANTLR_INT32 dfa40_T132[] =
    {
	179
    };

static const ANTLR_INT32 dfa40_T133[] =
    {
	262
    };

static const ANTLR_INT32 dfa40_T134[] =
    {
	178
    };

static const ANTLR_INT32 dfa40_T135[] =
    {
	264
    };

static const ANTLR_INT32 dfa40_T136[] =
    {
	263
    };

static const ANTLR_INT32 dfa40_T137[] =
    {
	176
    };

static const ANTLR_INT32 dfa40_T138[] =
    {
	260
    };

static const ANTLR_INT32 dfa40_T139[] =
    {
	83, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, 82
    };

static const ANTLR_INT32 dfa40_T140[] =
    {
	336
    };

static const ANTLR_INT32 dfa40_T141[] =
    {
	177
    };

static const ANTLR_INT32 dfa40_T142[] =
    {
	334
    };

static const ANTLR_INT32 dfa40_T143[] =
    {
	258
    };

static const ANTLR_INT32 dfa40_T144[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 288, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T145[] =
    {
	403
    };

static const ANTLR_INT32 dfa40_T146[] =
    {
	259
    };

static const ANTLR_INT32 dfa40_T147[] =
    {
	226, -1, -1, -1, -1, -1, -1, -1, -1, -1, 225
    };

static const ANTLR_INT32 dfa40_T148[] =
    {
	175
    };

static const ANTLR_INT32 dfa40_T149[] =
    {
	61
    };

static const ANTLR_INT32 dfa40_T150[] =
    {
	335
    };

static const ANTLR_INT32 dfa40_T151[] =
    {
	333
    };

static const ANTLR_INT32 dfa40_T152[] =
    {
	402
    };

static const ANTLR_INT32 dfa40_T153[] =
    {
	453
    };

static const ANTLR_INT32 dfa40_T154[] =
    {
	484
    };

static const ANTLR_INT32 dfa40_T155[] =
    {
	500
    };

static const ANTLR_INT32 dfa40_T156[] =
    {
	71, 72
    };

static const ANTLR_INT32 dfa40_T157[] =
    {
	172
    };

static const ANTLR_INT32 dfa40_T158[] =
    {
	332
    };

static const ANTLR_INT32 dfa40_T159[] =
    {
	452
    };

static const ANTLR_INT32 dfa40_T160[] =
    {
	401
    };

static const ANTLR_INT32 dfa40_T161[] =
    {
	499
    };

static const ANTLR_INT32 dfa40_T162[] =
    {
	483
    };

static const ANTLR_INT32 dfa40_T163[] =
    {
	417
    };

static const ANTLR_INT32 dfa40_T164[] =
    {
	353
    };

static const ANTLR_INT32 dfa40_T165[] =
    {
	277
    };

static const ANTLR_INT32 dfa40_T166[] =
    {
	197
    };

static const ANTLR_INT32 dfa40_T167[] =
    {
	141
    };

static const ANTLR_INT32 dfa40_T168[] =
    {
	222
    };

static const ANTLR_INT32 dfa40_T169[] =
    {
	378
    };

static const ANTLR_INT32 dfa40_T170[] =
    {
	221
    };

static const ANTLR_INT32 dfa40_T171[] =
    {
	302
    };

static const ANTLR_INT32 dfa40_T172[] =
    {
	54, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };

static const ANTLR_INT32 dfa40_T173[] =
    {
	67
    };

static const ANTLR_INT32 dfa40_T174[] =
    {
	506
    };

static const ANTLR_INT32 dfa40_T175[] =
    {
	493
    };

static const ANTLR_INT32 dfa40_T176[] =
    {
	377
    };

static const ANTLR_INT32 dfa40_T177[] =
    {
	301
    };

static const ANTLR_INT32 dfa40_T178[] =
    {
	471
    };

static const ANTLR_INT32 dfa40_T179[] =
    {
	53, 53, 53, 53, 53, 53, 53, 53, 53, 53
    };

static const ANTLR_INT32 dfa40_T180[] =
    {
	435
    };

static const ANTLR_INT32 dfa40_T181[] =
    {
	256, -1, -1, -1, -1, -1, -1, 257
    };

static const ANTLR_INT32 dfa40_T182[] =
    {
	219
    };

static const ANTLR_INT32 dfa40_T183[] =
    {
	64
    };

static const ANTLR_INT32 dfa40_T184[] =
    {
	274
    };

static const ANTLR_INT32 dfa40_T185[] =
    {
	349
    };

static const ANTLR_INT32 dfa40_T186[] =
    {
	273
    };

static const ANTLR_INT32 dfa40_T187[] =
    {
	191
    };

static const ANTLR_INT32 dfa40_T188[] =
    {
	192
    };

static const ANTLR_INT32 dfa40_T189[] =
    {
	272
    };

static const ANTLR_INT32 dfa40_T190[] =
    {
	84, -1, 85, -1, -1, -1, -1, 86
    };

static const ANTLR_INT32 dfa40_T191[] =
    {
	190
    };

static const ANTLR_INT32 dfa40_T192[] =
    {
	165, -1, -1, 166, -1, -1, -1, -1, -1, 167, -1, -1, -1, -1, -1, -1, 168
    };

static const ANTLR_INT32 dfa40_T193[] =
    {
	345
    };

static const ANTLR_INT32 dfa40_T194[] =
    {
	459
    };

static const ANTLR_INT32 dfa40_T195[] =
    {
	413
    };

static const ANTLR_INT32 dfa40_T196[] =
    {
	502
    };

static const ANTLR_INT32 dfa40_T197[] =
    {
	487
    };

static const ANTLR_INT32 dfa40_T198[] =
    {
	269
    };

static const ANTLR_INT32 dfa40_T199[] =
    {
	412
    };

static const ANTLR_INT32 dfa40_T200[] =
    {
	93, -1, -1, -1, 94, -1, -1, -1, 95, -1, -1, -1, -1, -1, -1, -1, -1, 96
    };

static const ANTLR_INT32 dfa40_T201[] =
    {
	344
    };

static const ANTLR_INT32 dfa40_T202[] =
    {
	457
    };

static const ANTLR_INT32 dfa40_T203[] =
    {
	474
    };

static const ANTLR_INT32 dfa40_T204[] =
    {
	217
    };

static const ANTLR_INT32 dfa40_T205[] =
    {
	298, -1, -1, -1, 299
    };

static const ANTLR_INT32 dfa40_T206[] =
    {
	315
    };

static const ANTLR_INT32 dfa40_T207[] =
    {
	238
    };

static const ANTLR_INT32 dfa40_T208[] =
    {
	441
    };

static const ANTLR_INT32 dfa40_T209[] =
    {
	388
    };

static const ANTLR_INT32 dfa40_T210[] =
    {
	389
    };

static const ANTLR_INT32 dfa40_T211[] =
    {
	316
    };

static const ANTLR_INT32 dfa40_T212[] =
    {
	442
    };

static const ANTLR_INT32 dfa40_T213[] =
    {
	239
    };

static const ANTLR_INT32 dfa40_T214[] =
    {
	240
    };

static const ANTLR_INT32 dfa40_T215[] =
    {
	317
    };

static const ANTLR_INT32 dfa40_T216[] =
    {
	390
    };

static const ANTLR_INT32 dfa40_T217[] =
    {
	443
    };

static const ANTLR_INT32 dfa40_T218[] =
    {
	297
    };

static const ANTLR_INT32 dfa40_T219[] =
    {
	476
    };

static const ANTLR_INT32 dfa40_T220[] =
    {
	216
    };

static const ANTLR_INT32 dfa40_T221[] =
    {
	437
    };

static const ANTLR_INT32 dfa40_T222[] =
    {
	380
    };

static const ANTLR_INT32 dfa40_T223[] =
    {
	305
    };

static const ANTLR_INT32 dfa40_T224[] =
    {
	224
    };

static const ANTLR_INT32 dfa40_T225[] =
    {
	19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, -1, -1, -1, 69, -1, -1, -1, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19
    };

static const ANTLR_INT32 dfa40_T226[] =
    {
	156
    };

static const ANTLR_INT32 dfa40_T227[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 153, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T228[] =
    {
	157
    };

static const ANTLR_INT32 dfa40_T229[] =
    {
	237
    };

static const ANTLR_INT32 dfa40_T230[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 372, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T231[] =
    {
	314
    };

static const ANTLR_INT32 dfa40_T232[] =
    {
	318
    };

static const ANTLR_INT32 dfa40_T233[] =
    {
	391
    };

static const ANTLR_INT32 dfa40_T234[] =
    {
	107, -1, 108, -1, -1, -1, -1, -1, -1, -1, 109, -1, -1, -1, -1, 110
    };

static const ANTLR_INT32 dfa40_T235[] =
    {
	241
    };

static const ANTLR_INT32 dfa40_T236[] =
    {
	137
    };

static const ANTLR_INT32 dfa40_T237[] =
    {
	223
    };

static const ANTLR_INT32 dfa40_T238[] =
    {
	304
    };

static const ANTLR_INT32 dfa40_T239[] =
    {
	104, -1, -1, 105
    };

static const ANTLR_INT32 dfa40_T240[] =
    {
	444
    };

static const ANTLR_INT32 dfa40_T241[] =
    {
	291, -1, 292
    };

static const ANTLR_INT32 dfa40_T242[] =
    {
	111, -1, -1, -1, -1, -1, 112
    };

static const ANTLR_INT32 dfa40_T243[] =
    {
	231
    };

static const ANTLR_INT32 dfa40_T244[] =
    {
	311
    };

static const ANTLR_INT32 dfa40_T245[] =
    {
	328
    };

static const ANTLR_INT32 dfa40_T246[] =
    {
	399
    };

static const ANTLR_INT32 dfa40_T247[] =
    {
	451
    };

static const ANTLR_INT32 dfa40_T248[] =
    {
	482
    };

static const ANTLR_INT32 dfa40_T249[] =
    {
	169
    };

static const ANTLR_INT32 dfa40_T250[] =
    {
	251
    };

static const ANTLR_INT32 dfa40_T251[] =
    {
	250
    };

static const ANTLR_INT32 dfa40_T252[] =
    {
	208
    };

static const ANTLR_INT32 dfa40_T253[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 410, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T254[] =
    {
	170
    };

static const ANTLR_INT32 dfa40_T255[] =
    {
	252
    };

static const ANTLR_INT32 dfa40_T256[] =
    {
	448
    };

static const ANTLR_INT32 dfa40_T257[] =
    {
	324
    };

static const ANTLR_INT32 dfa40_T258[] =
    {
	396
    };

static const ANTLR_INT32 dfa40_T259[] =
    {
	247
    };

static const ANTLR_INT32 dfa40_T260[] =
    {
	246
    };

static const ANTLR_INT32 dfa40_T261[] =
    {
	286, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 287
    };

static const ANTLR_INT32 dfa40_T262[] =
    {
	207
    };

static const ANTLR_INT32 dfa40_T263[] =
    {
	158, 159, 160
    };

static const ANTLR_INT32 dfa40_T264[] =
    {
	398
    };

static const ANTLR_INT32 dfa40_T265[] =
    {
	326
    };

static const ANTLR_INT32 dfa40_T266[] =
    {
	249
    };

static const ANTLR_INT32 dfa40_T267[] =
    {
	55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 56, -1, -1, -1, -1, -1, 57
    };

static const ANTLR_INT32 dfa40_T268[] =
    {
	449
    };

static const ANTLR_INT32 dfa40_T269[] =
    {
	161, -1, -1, -1, 162
    };

static const ANTLR_INT32 dfa40_T270[] =
    {
	397
    };

static const ANTLR_INT32 dfa40_T271[] =
    {
	325
    };

static const ANTLR_INT32 dfa40_T272[] =
    {
	248
    };

static const ANTLR_INT32 dfa40_T273[] =
    {
	321
    };

static const ANTLR_INT32 dfa40_T274[] =
    {
	394
    };

static const ANTLR_INT32 dfa40_T275[] =
    {
	243
    };

static const ANTLR_INT32 dfa40_T276[] =
    {
	320
    };

static const ANTLR_INT32 dfa40_T277[] =
    {
	393
    };

static const ANTLR_INT32 dfa40_T278[] =
    {
	395
    };

static const ANTLR_INT32 dfa40_T279[] =
    {
	322
    };

static const ANTLR_INT32 dfa40_T280[] =
    {
	193
    };

static const ANTLR_INT32 dfa40_T281[] =
    {
	100, -1, -1, -1, 101, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, -1, 
	103
    };

static const ANTLR_INT32 dfa40_T282[] =
    {
	275
    };

static const ANTLR_INT32 dfa40_T283[] =
    {
	164
    };

static const ANTLR_INT32 dfa40_T284[] =
    {
	446
    };

static const ANTLR_INT32 dfa40_T285[] =
    {
	133, -1, -1, -1, -1, -1, -1, -1, 134
    };

static const ANTLR_INT32 dfa40_T286[] =
    {
	244, 245
    };

static const ANTLR_INT32 dfa40_T287[] =
    {
	497
    };

static const ANTLR_INT32 dfa40_T288[] =
    {
	163
    };

static const ANTLR_INT32 dfa40_T289[] =
    {
	97, -1, 98, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99
    };

static const ANTLR_INT32 dfa40_T290[] =
    {
	138, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 139, 
	-1, -1, 140
    };

static const ANTLR_INT32 dfa40_T291[] =
    {
	319
    };

static const ANTLR_INT32 dfa40_T292[] =
    {
	242
    };

static const ANTLR_INT32 dfa40_T293[] =
    {
	517
    };

static const ANTLR_INT32 dfa40_T294[] =
    {
	516
    };

static const ANTLR_INT32 dfa40_T295[] =
    {
	514
    };

static const ANTLR_INT32 dfa40_T296[] =
    {
	508
    };

static const ANTLR_INT32 dfa40_T297[] =
    {
	519
    };

static const ANTLR_INT32 dfa40_T298[] =
    {
	518
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa40_transitions[] =
{
    dfa40_T106, dfa40_T172, dfa40_T267, dfa40_T19, dfa40_T149, dfa40_T179, 
    NULL, dfa40_T1, NULL, NULL, NULL, NULL, NULL, dfa40_T183, NULL, NULL, 
    dfa40_T109, dfa40_T173, dfa40_T225, NULL, NULL, dfa40_T156, dfa40_T96, 
    dfa40_T92, dfa40_T92, dfa40_T92, dfa40_T11, NULL, NULL, NULL, NULL, 
    NULL, dfa40_T139, dfa40_T190, dfa40_T116, dfa40_T24, dfa40_T200, dfa40_T289, 
    dfa40_T281, dfa40_T239, dfa40_T111, dfa40_T234, dfa40_T242, dfa40_T42, 
    dfa40_T26, dfa40_T20, dfa40_T2, dfa40_T41, dfa40_T83, dfa40_T61, dfa40_T285, 
    dfa40_T14, NULL, NULL, dfa40_T236, NULL, dfa40_T290, dfa40_T167, dfa40_T17, 
    dfa40_T0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, dfa40_T48, 
    dfa40_T71, dfa40_T12, dfa40_T22, dfa40_T25, dfa40_T227, dfa40_T84, dfa40_T226, 
    dfa40_T228, dfa40_T263, dfa40_T269, dfa40_T288, dfa40_T283, dfa40_T192, 
    dfa40_T249, dfa40_T254, dfa40_T16, dfa40_T157, dfa40_T99, dfa40_T148, 
    dfa40_T137, dfa40_T141, dfa40_T134, dfa40_T132, dfa40_T30, dfa40_T129, 
    dfa40_T115, dfa40_T0, dfa40_T128, dfa40_T0, dfa40_T191, dfa40_T187, 
    dfa40_T188, dfa40_T280, dfa40_T93, dfa40_T0, dfa40_T0, dfa40_T166, dfa40_T23, 
    dfa40_T59, dfa40_T21, dfa40_T33, dfa40_T35, dfa40_T38, dfa40_T40, dfa40_T262, 
    dfa40_T252, dfa40_T0, dfa40_T101, dfa40_T18, dfa40_T103, dfa40_T95, 
    dfa40_T114, dfa40_T220, dfa40_T204, dfa40_T81, NULL, dfa40_T182, dfa40_T0, 
    dfa40_T170, dfa40_T168, dfa40_T237, dfa40_T224, NULL, dfa40_T147, dfa40_T62, 
    dfa40_T72, dfa40_T10, dfa40_T0, dfa40_T243, dfa40_T0, dfa40_T0, dfa40_T0, 
    NULL, dfa40_T82, dfa40_T229, dfa40_T207, dfa40_T213, dfa40_T214, dfa40_T235, 
    dfa40_T292, dfa40_T275, dfa40_T286, dfa40_T260, dfa40_T259, dfa40_T272, 
    dfa40_T266, dfa40_T251, dfa40_T250, dfa40_T255, dfa40_T15, dfa40_T0, 
    dfa40_T181, dfa40_T143, dfa40_T146, dfa40_T138, dfa40_T0, dfa40_T133, 
    dfa40_T136, dfa40_T135, dfa40_T126, dfa40_T130, dfa40_T125, NULL, dfa40_T68, 
    dfa40_T198, dfa40_T91, NULL, NULL, dfa40_T189, dfa40_T186, dfa40_T184, 
    dfa40_T282, dfa40_T86, NULL, NULL, dfa40_T165, dfa40_T53, NULL, dfa40_T57, 
    dfa40_T78, dfa40_T29, dfa40_T32, dfa40_T36, dfa40_T39, dfa40_T44, dfa40_T261, 
    dfa40_T144, NULL, dfa40_T100, dfa40_T241, dfa40_T4, dfa40_T104, dfa40_T94, 
    dfa40_T113, dfa40_T218, dfa40_T205, dfa40_T80, dfa40_T177, NULL, dfa40_T171, 
    dfa40_T0, dfa40_T238, dfa40_T223, dfa40_T51, dfa40_T65, dfa40_T60, dfa40_T73, 
    dfa40_T13, NULL, dfa40_T244, NULL, NULL, NULL, dfa40_T0, dfa40_T0, dfa40_T231, 
    dfa40_T206, dfa40_T211, dfa40_T215, dfa40_T232, dfa40_T291, dfa40_T276, 
    dfa40_T273, dfa40_T279, dfa40_T0, dfa40_T257, dfa40_T271, dfa40_T265, 
    dfa40_T0, dfa40_T245, dfa40_T0, dfa40_T0, dfa40_T9, NULL, dfa40_T158, 
    dfa40_T151, dfa40_T142, dfa40_T150, dfa40_T140, NULL, dfa40_T0, dfa40_T0, 
    dfa40_T127, dfa40_T131, dfa40_T118, dfa40_T124, dfa40_T63, dfa40_T201, 
    dfa40_T193, dfa40_T0, dfa40_T0, dfa40_T0, dfa40_T185, dfa40_T70, dfa40_T87, 
    dfa40_T164, dfa40_T52, dfa40_T58, dfa40_T79, dfa40_T28, dfa40_T31, dfa40_T37, 
    dfa40_T0, dfa40_T43, dfa40_T45, dfa40_T49, dfa40_T0, NULL, dfa40_T0, 
    dfa40_T98, dfa40_T107, dfa40_T5, dfa40_T105, dfa40_T97, dfa40_T112, 
    dfa40_T230, dfa40_T0, dfa40_T85, dfa40_T0, dfa40_T176, dfa40_T169, NULL, 
    dfa40_T0, dfa40_T222, dfa40_T50, dfa40_T64, dfa40_T0, dfa40_T74, dfa40_T0, 
    dfa40_T0, NULL, NULL, dfa40_T0, dfa40_T209, dfa40_T210, dfa40_T216, 
    dfa40_T233, dfa40_T0, dfa40_T277, dfa40_T274, dfa40_T278, NULL, dfa40_T258, 
    dfa40_T270, dfa40_T264, NULL, dfa40_T246, NULL, NULL, dfa40_T0, dfa40_T160, 
    dfa40_T152, dfa40_T145, dfa40_T0, dfa40_T0, NULL, NULL, dfa40_T0, dfa40_T0, 
    dfa40_T117, dfa40_T123, dfa40_T253, dfa40_T199, dfa40_T195, NULL, NULL, 
    NULL, dfa40_T0, dfa40_T0, NULL, dfa40_T88, dfa40_T163, dfa40_T0, dfa40_T55, 
    dfa40_T75, dfa40_T27, dfa40_T34, dfa40_T0, NULL, dfa40_T0, dfa40_T46, 
    dfa40_T0, NULL, NULL, dfa40_T0, dfa40_T108, dfa40_T6, dfa40_T102, dfa40_T0, 
    dfa40_T110, dfa40_T0, NULL, NULL, dfa40_T0, NULL, dfa40_T180, dfa40_T0, 
    NULL, dfa40_T221, dfa40_T3, dfa40_T67, NULL, dfa40_T0, NULL, NULL, NULL, 
    dfa40_T208, dfa40_T212, dfa40_T217, dfa40_T240, NULL, dfa40_T0, dfa40_T284, 
    dfa40_T0, dfa40_T256, dfa40_T268, dfa40_T0, dfa40_T247, NULL, dfa40_T159, 
    dfa40_T153, dfa40_T0, NULL, NULL, NULL, NULL, dfa40_T0, dfa40_T122, 
    dfa40_T202, NULL, dfa40_T0, dfa40_T194, NULL, NULL, dfa40_T89, dfa40_T0, 
    NULL, dfa40_T56, dfa40_T76, dfa40_T0, dfa40_T0, NULL, NULL, dfa40_T47, 
    NULL, NULL, dfa40_T0, dfa40_T8, dfa40_T0, NULL, dfa40_T0, NULL, NULL, 
    dfa40_T178, NULL, dfa40_T0, NULL, dfa40_T66, NULL, dfa40_T203, dfa40_T0, 
    dfa40_T219, dfa40_T7, NULL, dfa40_T0, NULL, dfa40_T0, dfa40_T0, NULL, 
    dfa40_T248, dfa40_T162, dfa40_T154, NULL, NULL, dfa40_T121, dfa40_T0, 
    NULL, dfa40_T197, dfa40_T90, NULL, dfa40_T54, dfa40_T77, NULL, NULL, 
    dfa40_T0, NULL, dfa40_T0, NULL, NULL, dfa40_T175, NULL, dfa40_T69, dfa40_T0, 
    NULL, dfa40_T0, dfa40_T287, NULL, NULL, NULL, NULL, dfa40_T0, dfa40_T161, 
    dfa40_T155, dfa40_T120, NULL, dfa40_T196, dfa40_T0, dfa40_T0, dfa40_T0, 
    NULL, NULL, dfa40_T174, dfa40_T0, NULL, NULL, dfa40_T296, NULL, dfa40_T0, 
    dfa40_T0, dfa40_T119, dfa40_T0, NULL, NULL, NULL, dfa40_T0, NULL, dfa40_T295, 
    NULL, NULL, dfa40_T0, NULL, NULL, dfa40_T294, NULL, dfa40_T293, dfa40_T298, 
    dfa40_T297, dfa40_T0, NULL
};


/* Declare tracking structure for Cyclic DFA 40
 */
class OracleDMLLexerCyclicDFA40 : public CyclicDFA< OracleDMLLexerImplTraits, OracleDMLLexer >, public OracleDMLLexerTokens
{
public:
	typedef CyclicDFA< OracleDMLLexerImplTraits, OracleDMLLexer >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	OracleDMLLexerCyclicDFA40( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static OracleDMLLexerCyclicDFA40  cdfa40(
	    40,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"1:1: Tokens : ( FOR_NOTATION | NATIONAL_CHAR_STRING_LIT | BIT_STRING_LIT | HEX_STRING_LIT | PERIOD | EXACT_NUM_LIT | CHAR_STRING | CHAR_STRING_PERL | DELIMITED_ID | PERCENT | AMPERSAND | LEFT_PAREN | RIGHT_PAREN | DOUBLE_ASTERISK | ASTERISK | PLUS_SIGN | COMMA | SOLIDUS | AT_SIGN | ASSIGN_OP | BINDVAR | COLON | SEMICOLON | LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP | GREATER_THAN_OR_EQUALS_OP | NOT_EQUAL_OP | CARRET_OPERATOR_PART | TILDE_OPERATOR_PART | EXCLAMATION_OPERATOR_PART | GREATER_THAN_OP | CONCATENATION_OP | VERTICAL_BAR | EQUALS_OP | LEFT_BRACKET | RIGHT_BRACKET | INTRODUCER | SEPARATOR | PROMPT | SQL92_RESERVED_ALL | SQL92_RESERVED_ALTER | SQL92_RESERVED_AND | SQL92_RESERVED_ANY | SQL92_RESERVED_AS | SQL92_RESERVED_ASC | SQL92_RESERVED_BEGIN | SQL92_RESERVED_BETWEEN | SQL92_RESERVED_BY | SQL92_RESERVED_CASE | SQL92_RESERVED_CHECK | PLSQL_RESERVED_CLUSTERS | PLSQL_RESERVED_COLAUTH | PLSQL_RESERVED_COMPRESS | SQL92_RESERVED_CONNECT | PLSQL_NON_RESERVED_CONNECT_BY_ROOT | PLSQL_RESERVED_CRASH | SQL92_RESERVED_CREATE | SQL92_RESERVED_CURRENT | SQL92_RESERVED_CURSOR | SQL92_RESERVED_DATE | SQL92_RESERVED_DECLARE | SQL92_RESERVED_DEFAULT | SQL92_RESERVED_DELETE | SQL92_RESERVED_DESC | SQL92_RESERVED_DISTINCT | SQL92_RESERVED_DROP | SQL92_RESERVED_ELSE | SQL92_RESERVED_END | SQL92_RESERVED_EXCEPTION | PLSQL_RESERVED_EXCLUSIVE | SQL92_RESERVED_EXISTS | SQL92_RESERVED_FALSE | SQL92_RESERVED_FETCH | SQL92_RESERVED_FOR | SQL92_RESERVED_FROM | SQL92_RESERVED_GOTO | SQL92_RESERVED_GRANT | SQL92_RESERVED_GROUP | SQL92_RESERVED_HAVING | PLSQL_RESERVED_IDENTIFIED | PLSQL_RESERVED_IF | SQL92_RESERVED_IN | PLSQL_RESERVED_INDEX | PLSQL_RESERVED_INDEXES | SQL92_RESERVED_INSERT | SQL92_RESERVED_INTERSECT | SQL92_RESERVED_INTO | SQL92_RESERVED_IS | SQL92_RESERVED_LIKE | PLSQL_RESERVED_LOCK | PLSQL_RESERVED_MINUS | PLSQL_RESERVED_MODE | PLSQL_RESERVED_NOCOMPRESS | SQL92_RESERVED_NOT | PLSQL_RESERVED_NOWAIT | SQL92_RESERVED_NULL | SQL92_RESERVED_OF | SQL92_RESERVED_ON | SQL92_RESERVED_OPTION | SQL92_RESERVED_OR | SQL92_RESERVED_ORDER | SQL92_RESERVED_OVERLAPS | SQL92_RESERVED_PRIOR | SQL92_RESERVED_PROCEDURE | SQL92_RESERVED_PUBLIC | PLSQL_RESERVED_RESOURCE | SQL92_RESERVED_REVOKE | SQL92_RESERVED_SELECT | PLSQL_RESERVED_SHARE | SQL92_RESERVED_SIZE | PLSQL_RESERVED_START | PLSQL_RESERVED_TABAUTH | SQL92_RESERVED_TABLE | SQL92_RESERVED_THE | SQL92_RESERVED_THEN | SQL92_RESERVED_TO | SQL92_RESERVED_TRUE | SQL92_RESERVED_UNION | SQL92_RESERVED_UNIQUE | SQL92_RESERVED_UPDATE | SQL92_RESERVED_VALUES | SQL92_RESERVED_VIEW | PLSQL_RESERVED_VIEWS | SQL92_RESERVED_WHEN | SQL92_RESERVED_WHERE | SQL92_RESERVED_WITH | PLSQL_NON_RESERVED_CAST | PLSQL_NON_RESERVED_MULTISET | PLSQL_NON_RESERVED_USING | PLSQL_NON_RESERVED_MODEL | PLSQL_NON_RESERVED_ELSIF | PLSQL_NON_RESERVED_PIVOT | PLSQL_NON_RESERVED_UNPIVOT | REGULAR_ID | ZV );",
	    dfa40_eot,	    /* EOT table			    */
	    dfa40_eof,	    /* EOF table			    */
	    dfa40_min,	    /* Minimum tokens for each state    */
	    dfa40_max,	    /* Maximum tokens for each state    */
	    dfa40_accept,	/* Accept table			    */
	    dfa40_special,	/* Special transition states	    */
	    dfa40_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 40
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 640:5: ( UNSIGNED_INTEGER '..' UNSIGNED_INTEGER )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FOR_NOTATION
 *
 * Looks to match the characters the constitute the token FOR_NOTATION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mFOR_NOTATION()
{
    ANTLR_UINT32	_type;
      

    _type	    = FOR_NOTATION;


    // OracleDMLLexer.g:640:5: ( UNSIGNED_INTEGER '..' UNSIGNED_INTEGER )
    // OracleDMLLexer.g:640:10: UNSIGNED_INTEGER '..' UNSIGNED_INTEGER
    {
        /* 640:10: UNSIGNED_INTEGER '..' UNSIGNED_INTEGER */
        mUNSIGNED_INTEGER();
        if  (this->hasException())
        {
            goto ruleFOR_NOTATIONEx;
        }



        this->matchs(lit_1);
        if  (this->hasException())
        {
            goto ruleFOR_NOTATIONEx;
        }




        /* 640:10: UNSIGNED_INTEGER '..' UNSIGNED_INTEGER */
        mUNSIGNED_INTEGER();
        if  (this->hasException())
        {
            goto ruleFOR_NOTATIONEx;
        }



    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleFOR_NOTATIONEx; /* Prevent compiler warnings */
    ruleFOR_NOTATIONEx: ;

}
// $ANTLR end FOR_NOTATION

//   Comes from: 651:5: ( ( 'N' | 'n' ) '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NATIONAL_CHAR_STRING_LIT
 *
 * Looks to match the characters the constitute the token NATIONAL_CHAR_STRING_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mNATIONAL_CHAR_STRING_LIT()
{
    ANTLR_UINT32	_type;
      

    _type	    = NATIONAL_CHAR_STRING_LIT;


    // OracleDMLLexer.g:651:5: ( ( 'N' | 'n' ) '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\'' )
    // OracleDMLLexer.g:651:10: ( 'N' | 'n' ) '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\''
    {
        if ( this->LA(1) == 'N' || this->LA(1) == 'n' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleNATIONAL_CHAR_STRING_LITEx;
        }


         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleNATIONAL_CHAR_STRING_LITEx;
        }


        // OracleDMLLexer.g:651:27: ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )*

        for (;;)
        {
            ANTLR_UINT32 alt1=4;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                ANTLR_UINT32 LA1_0 = this->LA(1);
                if ( (LA1_0 == '\''))
                {
                    switch ( this->LA(2) )
                    {
                    case '\'':
                    	{
                    		alt1=2;
                    	}
                        break;

                    }

                }
                else if ( (((LA1_0 >= 0x0000) && (LA1_0 <= '\t')) || ((LA1_0 >= 0x000B) && (LA1_0 <= '\f')) || ((LA1_0 >= 0x000E) && (LA1_0 <= '&')) || ((LA1_0 >= '(') && (LA1_0 <= 0xFFFF))))
                {
                    alt1=1;
                }
                else if ( (LA1_0 == '\n' || LA1_0 == '\r'))
                {
                    alt1=3;
                }

            }
            switch (alt1)
            {
        	case 1:
        	    // OracleDMLLexer.g:651:51: ~ ( '\\'' | '\\r' | '\\n' )
        	    {
        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= '&')) || ((this->LA(1) >= '(') && (this->LA(1) <= 0xFFFF)) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleNATIONAL_CHAR_STRING_LITEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // OracleDMLLexer.g:651:76: '\\'' '\\''
        	    {
        	         this->matchc('\'');
        	        if  (this->hasException())
        	        {
        	            goto ruleNATIONAL_CHAR_STRING_LITEx;
        	        }


        	         this->matchc('\'');
        	        if  (this->hasException())
        	        {
        	            goto ruleNATIONAL_CHAR_STRING_LITEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // OracleDMLLexer.g:651:88: NEWLINE
        	    {
        	        /* 651:88: NEWLINE */
        	        mNEWLINE();
        	        if  (this->hasException())
        	        {
        	            goto ruleNATIONAL_CHAR_STRING_LITEx;
        	        }



        	    }
        	    break;

        	default:
        	    goto loop1;	/* break out of the loop */
        	    break;
            }
        }
        loop1: ; /* Jump out to here if this rule does not match */


         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleNATIONAL_CHAR_STRING_LITEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleNATIONAL_CHAR_STRING_LITEx; /* Prevent compiler warnings */
    ruleNATIONAL_CHAR_STRING_LITEx: ;

}
// $ANTLR end NATIONAL_CHAR_STRING_LIT

//   Comes from: 658:5: ( ( 'B' | 'b' ) ( '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )? )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BIT_STRING_LIT
 *
 * Looks to match the characters the constitute the token BIT_STRING_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mBIT_STRING_LIT()
{
    ANTLR_UINT32	_type;
      

    _type	    = BIT_STRING_LIT;


    // OracleDMLLexer.g:658:5: ( ( 'B' | 'b' ) ( '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )? )+ )
    // OracleDMLLexer.g:658:10: ( 'B' | 'b' ) ( '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )? )+
    {
        if ( this->LA(1) == 'B' || this->LA(1) == 'b' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleBIT_STRING_LITEx;
        }


        // OracleDMLLexer.g:658:22: ( '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )? )+
        {
            int cnt4=0;

            for (;;)
            {
                ANTLR_UINT32 alt4=2;
        	switch ( this->LA(1) )
        	{
        	case '\'':
        		{
        			alt4=1;
        		}
        	    break;

        	}

        	switch (alt4)
        	{
        	    case 1:
        	        // OracleDMLLexer.g:658:23: '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )?
        	        {
        	             this->matchc('\'');
        	            if  (this->hasException())
        	            {
        	                goto ruleBIT_STRING_LITEx;
        	            }


        	            // OracleDMLLexer.g:658:28: ( '0' | '1' )*

        	            for (;;)
        	            {
        	                ANTLR_UINT32 alt2=2;
        	                switch ( this->LA(1) )
        	                {
        	                case '0':
        	                case '1':
        	                	{
        	                		alt2=1;
        	                	}
        	                    break;

        	                }

        	                switch (alt2)
        	                {
        	            	case 1:
        	            	    // OracleDMLLexer.g:
        	            	    {
        	            	        if ( ((this->LA(1) >= '0') && (this->LA(1) <= '1')) )
        	            	        {
        	            	            this->consume();
        	            	        }
        	            	        else
        	            	        {
        	            	            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            	            this->recover();
        	            	            goto ruleBIT_STRING_LITEx;
        	            	        }


        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop2;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop2: ; /* Jump out to here if this rule does not match */


        	             this->matchc('\'');
        	            if  (this->hasException())
        	            {
        	                goto ruleBIT_STRING_LITEx;
        	            }


        	            // OracleDMLLexer.g:658:46: ( SEPARATOR )?
        	            {
        	                ANTLR_UINT32 alt3=2;
        	                switch ( this->LA(1) )
        	                {
        	                    case '\t':
        	                    case '\n':
        	                    case '\r':
        	                    case ' ':
        	                    case '-':
        	                    case '/':
        	                    	{
        	                    		alt3=1;
        	                    	}
        	                        break;
        	                }

        	                switch (alt3)
        	                {
        	            	case 1:
        	            	    // OracleDMLLexer.g:658:46: SEPARATOR
        	            	    {
        	            	        /* 658:46: SEPARATOR */
        	            	        mSEPARATOR();
        	            	        if  (this->hasException())
        	            	        {
        	            	            goto ruleBIT_STRING_LITEx;
        	            	        }



        	            	    }
        	            	    break;

        	                }
        	            }

        	        }
        	        break;

        	    default:

        		if ( cnt4 >= 1 )
        		{
        		    goto loop4;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< OracleDMLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleBIT_STRING_LITEx;
        	}
        	cnt4++;
            }
            loop4: ;	/* Jump to here if this rule does not match */
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleBIT_STRING_LITEx; /* Prevent compiler warnings */
    ruleBIT_STRING_LITEx: ;

}
// $ANTLR end BIT_STRING_LIT

//   Comes from: 666:5: ( ( 'X' | 'x' ) ( '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )? )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_STRING_LIT
 *
 * Looks to match the characters the constitute the token HEX_STRING_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mHEX_STRING_LIT()
{
    ANTLR_UINT32	_type;
      

    _type	    = HEX_STRING_LIT;


    // OracleDMLLexer.g:666:5: ( ( 'X' | 'x' ) ( '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )? )+ )
    // OracleDMLLexer.g:666:10: ( 'X' | 'x' ) ( '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )? )+
    {
        if ( this->LA(1) == 'X' || this->LA(1) == 'x' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleHEX_STRING_LITEx;
        }


        // OracleDMLLexer.g:666:22: ( '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )? )+
        {
            int cnt7=0;

            for (;;)
            {
                ANTLR_UINT32 alt7=2;
        	switch ( this->LA(1) )
        	{
        	case '\'':
        		{
        			alt7=1;
        		}
        	    break;

        	}

        	switch (alt7)
        	{
        	    case 1:
        	        // OracleDMLLexer.g:666:23: '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )?
        	        {
        	             this->matchc('\'');
        	            if  (this->hasException())
        	            {
        	                goto ruleHEX_STRING_LITEx;
        	            }


        	            // OracleDMLLexer.g:666:28: ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )*

        	            for (;;)
        	            {
        	                ANTLR_UINT32 alt5=2;
        	                switch ( this->LA(1) )
        	                {
        	                case '0':
        	                case '1':
        	                case '2':
        	                case '3':
        	                case '4':
        	                case '5':
        	                case '6':
        	                case '7':
        	                case '8':
        	                case '9':
        	                case 'A':
        	                case 'B':
        	                case 'C':
        	                case 'D':
        	                case 'E':
        	                case 'F':
        	                case 'a':
        	                case 'b':
        	                case 'c':
        	                case 'd':
        	                case 'e':
        	                case 'f':
        	                	{
        	                		alt5=1;
        	                	}
        	                    break;

        	                }

        	                switch (alt5)
        	                {
        	            	case 1:
        	            	    // OracleDMLLexer.g:
        	            	    {
        	            	        if ( ((this->LA(1) >= '0') && (this->LA(1) <= '9')) || ((this->LA(1) >= 'A') && (this->LA(1) <= 'F')) || ((this->LA(1) >= 'a') && (this->LA(1) <= 'f')) )
        	            	        {
        	            	            this->consume();
        	            	        }
        	            	        else
        	            	        {
        	            	            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            	            this->recover();
        	            	            goto ruleHEX_STRING_LITEx;
        	            	        }


        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop5;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop5: ; /* Jump out to here if this rule does not match */


        	             this->matchc('\'');
        	            if  (this->hasException())
        	            {
        	                goto ruleHEX_STRING_LITEx;
        	            }


        	            // OracleDMLLexer.g:666:67: ( SEPARATOR )?
        	            {
        	                ANTLR_UINT32 alt6=2;
        	                switch ( this->LA(1) )
        	                {
        	                    case '\t':
        	                    case '\n':
        	                    case '\r':
        	                    case ' ':
        	                    case '-':
        	                    case '/':
        	                    	{
        	                    		alt6=1;
        	                    	}
        	                        break;
        	                }

        	                switch (alt6)
        	                {
        	            	case 1:
        	            	    // OracleDMLLexer.g:666:67: SEPARATOR
        	            	    {
        	            	        /* 666:67: SEPARATOR */
        	            	        mSEPARATOR();
        	            	        if  (this->hasException())
        	            	        {
        	            	            goto ruleHEX_STRING_LITEx;
        	            	        }



        	            	    }
        	            	    break;

        	                }
        	            }

        	        }
        	        break;

        	    default:

        		if ( cnt7 >= 1 )
        		{
        		    goto loop7;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< OracleDMLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleHEX_STRING_LITEx;
        	}
        	cnt7++;
            }
            loop7: ;	/* Jump to here if this rule does not match */
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleHEX_STRING_LITEx; /* Prevent compiler warnings */
    ruleHEX_STRING_LITEx: ;

}
// $ANTLR end HEX_STRING_LIT

//   Comes from: 671:5: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PERIOD
 *
 * Looks to match the characters the constitute the token PERIOD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPERIOD()
{
    ANTLR_UINT32	_type;
      

    _type	    = PERIOD;


    // OracleDMLLexer.g:671:5: ( '.' )
    // OracleDMLLexer.g:671:10: '.'
    {
         this->matchc('.');
        if  (this->hasException())
        {
            goto rulePERIODEx;
        }


        {
                if ((char) LA(1) == '.') {
                        consume();
                        _type = DOUBLE_PERIOD;
                    }
                
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePERIODEx; /* Prevent compiler warnings */
    rulePERIODEx: ;

}
// $ANTLR end PERIOD

//   Comes from: 685:5: ( ( UNSIGNED_INTEGER ( '.' ( UNSIGNED_INTEGER )? |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? | '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? ) ( 'D' | 'd' | 'f' | 'F' )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXACT_NUM_LIT
 *
 * Looks to match the characters the constitute the token EXACT_NUM_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mEXACT_NUM_LIT()
{
    ANTLR_UINT32	_type;
      

    _type	    = EXACT_NUM_LIT;


    // OracleDMLLexer.g:685:5: ( ( UNSIGNED_INTEGER ( '.' ( UNSIGNED_INTEGER )? |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? | '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? ) ( 'D' | 'd' | 'f' | 'F' )? )
    // OracleDMLLexer.g:685:7: ( UNSIGNED_INTEGER ( '.' ( UNSIGNED_INTEGER )? |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? | '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? ) ( 'D' | 'd' | 'f' | 'F' )?
    {
        // OracleDMLLexer.g:685:7: ( UNSIGNED_INTEGER ( '.' ( UNSIGNED_INTEGER )? |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? | '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? )
        {
            ANTLR_UINT32 alt14=2;
            switch ( this->LA(1) )
            {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            	{
            		alt14=1;
            	}
                break;
            case '.':
            	{
            		alt14=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 14 );
                ex->set_state( 0 );


                goto ruleEXACT_NUM_LITEx;

            }

            switch (alt14)
            {
        	case 1:
        	    // OracleDMLLexer.g:686:13: UNSIGNED_INTEGER ( '.' ( UNSIGNED_INTEGER )? |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )?
        	    {
        	        /* 686:13: UNSIGNED_INTEGER ( '.' ( UNSIGNED_INTEGER )? |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? */
        	        mUNSIGNED_INTEGER();
        	        if  (this->hasException())
        	        {
        	            goto ruleEXACT_NUM_LITEx;
        	        }



        	        // OracleDMLLexer.g:687:13: ( '.' ( UNSIGNED_INTEGER )? |)
        	        {
        	            ANTLR_UINT32 alt9=2;
        	            switch ( this->LA(1) )
        	            {
        	            case '.':
        	            	{
        	            		alt9=1;
        	            	}
        	                break;

        	            default:
        	                alt9=2;
        	            }

        	            switch (alt9)
        	            {
        	        	case 1:
        	        	    // OracleDMLLexer.g:687:15: '.' ( UNSIGNED_INTEGER )?
        	        	    {
        	        	         this->matchc('.');
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }


        	        	        // OracleDMLLexer.g:687:19: ( UNSIGNED_INTEGER )?
        	        	        {
        	        	            ANTLR_UINT32 alt8=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case '0':
        	        	                case '1':
        	        	                case '2':
        	        	                case '3':
        	        	                case '4':
        	        	                case '5':
        	        	                case '6':
        	        	                case '7':
        	        	                case '8':
        	        	                case '9':
        	        	                	{
        	        	                		alt8=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt8)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDMLLexer.g:687:19: UNSIGNED_INTEGER
        	        	        	    {
        	        	        	        /* 687:19: UNSIGNED_INTEGER */
        	        	        	        mUNSIGNED_INTEGER();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        	        }



        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDMLLexer.g:688:18: 
        	        	    {
        	        	        {
        	        	            _type = UNSIGNED_INTEGER;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDMLLexer.g:689:15: ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )?
        	        {
        	            ANTLR_UINT32 alt11=2;
        	            switch ( this->LA(1) )
        	            {
        	                case 'E':
        	                case 'e':
        	                	{
        	                		alt11=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt11)
        	            {
        	        	case 1:
        	        	    // OracleDMLLexer.g:689:17: ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER
        	        	    {
        	        	        if ( this->LA(1) == 'E' || this->LA(1) == 'e' )
        	        	        {
        	        	            this->consume();
        	        	        }
        	        	        else
        	        	        {
        	        	            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	        	            this->recover();
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }


        	        	        // OracleDMLLexer.g:689:29: ( '+' | '-' )?
        	        	        {
        	        	            ANTLR_UINT32 alt10=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case '+':
        	        	                case '-':
        	        	                	{
        	        	                		alt10=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt10)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDMLLexer.g:
        	        	        	    {
        	        	        	        if ( this->LA(1) == '+' || this->LA(1) == '-' )
        	        	        	        {
        	        	        	            this->consume();
        	        	        	        }
        	        	        	        else
        	        	        	        {
        	        	        	            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	        	        	            this->recover();
        	        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        /* 689:17: ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER */
        	        	        mUNSIGNED_INTEGER();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }



        	        	        {
        	        	            _type = APPROXIMATE_NUM_LIT;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDMLLexer.g:690:10: '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )?
        	    {
        	         this->matchc('.');
        	        if  (this->hasException())
        	        {
        	            goto ruleEXACT_NUM_LITEx;
        	        }


        	        /* 690:10: '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? */
        	        mUNSIGNED_INTEGER();
        	        if  (this->hasException())
        	        {
        	            goto ruleEXACT_NUM_LITEx;
        	        }



        	        // OracleDMLLexer.g:690:31: ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )?
        	        {
        	            ANTLR_UINT32 alt13=2;
        	            switch ( this->LA(1) )
        	            {
        	                case 'E':
        	                case 'e':
        	                	{
        	                		alt13=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt13)
        	            {
        	        	case 1:
        	        	    // OracleDMLLexer.g:690:33: ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER
        	        	    {
        	        	        if ( this->LA(1) == 'E' || this->LA(1) == 'e' )
        	        	        {
        	        	            this->consume();
        	        	        }
        	        	        else
        	        	        {
        	        	            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	        	            this->recover();
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }


        	        	        // OracleDMLLexer.g:690:45: ( '+' | '-' )?
        	        	        {
        	        	            ANTLR_UINT32 alt12=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case '+':
        	        	                case '-':
        	        	                	{
        	        	                		alt12=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt12)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDMLLexer.g:
        	        	        	    {
        	        	        	        if ( this->LA(1) == '+' || this->LA(1) == '-' )
        	        	        	        {
        	        	        	            this->consume();
        	        	        	        }
        	        	        	        else
        	        	        	        {
        	        	        	            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	        	        	            this->recover();
        	        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        /* 690:33: ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER */
        	        	        mUNSIGNED_INTEGER();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }



        	        	        {
        	        	            _type = APPROXIMATE_NUM_LIT;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }

        // OracleDMLLexer.g:692:5: ( 'D' | 'd' | 'f' | 'F' )?
        {
            ANTLR_UINT32 alt15=2;
            switch ( this->LA(1) )
            {
                case 'D':
                case 'F':
                case 'd':
                case 'f':
                	{
                		alt15=1;
                	}
                    break;
            }

            switch (alt15)
            {
        	case 1:
        	    // OracleDMLLexer.g:
        	    {
        	        if ( this->LA(1) == 'D' || this->LA(1) == 'F' || this->LA(1) == 'd' || this->LA(1) == 'f' )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleEXACT_NUM_LITEx;
        	        }


        	    }
        	    break;

            }
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleEXACT_NUM_LITEx; /* Prevent compiler warnings */
    ruleEXACT_NUM_LITEx: ;

}
// $ANTLR end EXACT_NUM_LIT

//   Comes from: 699:5: ( '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHAR_STRING
 *
 * Looks to match the characters the constitute the token CHAR_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mCHAR_STRING()
{
    ANTLR_UINT32	_type;
      

    _type	    = CHAR_STRING;


    // OracleDMLLexer.g:699:5: ( '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\'' )
    // OracleDMLLexer.g:699:10: '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\''
    {
         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleCHAR_STRINGEx;
        }


        // OracleDMLLexer.g:699:15: ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )*

        for (;;)
        {
            ANTLR_UINT32 alt16=4;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                ANTLR_UINT32 LA16_0 = this->LA(1);
                if ( (LA16_0 == '\''))
                {
                    switch ( this->LA(2) )
                    {
                    case '\'':
                    	{
                    		alt16=2;
                    	}
                        break;

                    }

                }
                else if ( (((LA16_0 >= 0x0000) && (LA16_0 <= '\t')) || ((LA16_0 >= 0x000B) && (LA16_0 <= '\f')) || ((LA16_0 >= 0x000E) && (LA16_0 <= '&')) || ((LA16_0 >= '(') && (LA16_0 <= 0xFFFF))))
                {
                    alt16=1;
                }
                else if ( (LA16_0 == '\n' || LA16_0 == '\r'))
                {
                    alt16=3;
                }

            }
            switch (alt16)
            {
        	case 1:
        	    // OracleDMLLexer.g:699:39: ~ ( '\\'' | '\\r' | '\\n' )
        	    {
        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= '&')) || ((this->LA(1) >= '(') && (this->LA(1) <= 0xFFFF)) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleCHAR_STRINGEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // OracleDMLLexer.g:699:63: '\\'' '\\''
        	    {
        	         this->matchc('\'');
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRINGEx;
        	        }


        	         this->matchc('\'');
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRINGEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // OracleDMLLexer.g:699:75: NEWLINE
        	    {
        	        /* 699:75: NEWLINE */
        	        mNEWLINE();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRINGEx;
        	        }



        	    }
        	    break;

        	default:
        	    goto loop16;	/* break out of the loop */
        	    break;
            }
        }
        loop16: ; /* Jump out to here if this rule does not match */


         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleCHAR_STRINGEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCHAR_STRINGEx; /* Prevent compiler warnings */
    ruleCHAR_STRINGEx: ;

}
// $ANTLR end CHAR_STRING

//   Comes from: 704:21: ( ( 'q' | 'Q' ) ( QS_ANGLE | QS_BRACE | QS_BRACK | QS_PAREN | QS_OTHER ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHAR_STRING_PERL
 *
 * Looks to match the characters the constitute the token CHAR_STRING_PERL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mCHAR_STRING_PERL()
{
    ANTLR_UINT32	_type;
      

    _type	    = CHAR_STRING_PERL;


    // OracleDMLLexer.g:704:21: ( ( 'q' | 'Q' ) ( QS_ANGLE | QS_BRACE | QS_BRACK | QS_PAREN | QS_OTHER ) )
    // OracleDMLLexer.g:704:23: ( 'q' | 'Q' ) ( QS_ANGLE | QS_BRACE | QS_BRACK | QS_PAREN | QS_OTHER )
    {
        if ( this->LA(1) == 'Q' || this->LA(1) == 'q' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleCHAR_STRING_PERLEx;
        }


        // OracleDMLLexer.g:704:33: ( QS_ANGLE | QS_BRACE | QS_BRACK | QS_PAREN | QS_OTHER )
        {
            ANTLR_UINT32 alt17=5;
            switch ( this->LA(1) )
            {
            case '\'':
            	{
            		{
            		    ANTLR_UINT32 LA17_1 = this->LA(2);
            		    if ( (LA17_1 == '<'))
            		    {
            		        alt17=1;
            		    }
            		    else if ( (LA17_1 == '{'))
            		    {
            		        alt17=2;
            		    }
            		    else if ( (LA17_1 == '['))
            		    {
            		        alt17=3;
            		    }
            		    else if ( (LA17_1 == '('))
            		    {
            		        alt17=4;
            		    }
            		    else if ( (((LA17_1 >= 0x0000) && (LA17_1 <= '\b')) || ((LA17_1 >= 0x000B) && (LA17_1 <= '\f')) || ((LA17_1 >= 0x000E) && (LA17_1 <= 0x001F)) || ((LA17_1 >= '!') && (LA17_1 <= '\'')) || ((LA17_1 >= ')') && (LA17_1 <= ';')) || ((LA17_1 >= '=') && (LA17_1 <= 'Z')) || ((LA17_1 >= '\\') && (LA17_1 <= 'z')) || ((LA17_1 >= '|') && (LA17_1 <= 0xFFFF))))
            		    {
            		        alt17=5;
            		    }
            		    else
            		    {

            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 17 );
            		        ex->set_state( 1 );


            		        goto ruleCHAR_STRING_PERLEx;

            		    }
            		}
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 17 );
                ex->set_state( 0 );


                goto ruleCHAR_STRING_PERLEx;

            }

            switch (alt17)
            {
        	case 1:
        	    // OracleDMLLexer.g:704:35: QS_ANGLE
        	    {
        	        /* 704:35: QS_ANGLE */
        	        mQS_ANGLE();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // OracleDMLLexer.g:704:46: QS_BRACE
        	    {
        	        /* 704:46: QS_BRACE */
        	        mQS_BRACE();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;
        	case 3:
        	    // OracleDMLLexer.g:704:57: QS_BRACK
        	    {
        	        /* 704:57: QS_BRACK */
        	        mQS_BRACK();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;
        	case 4:
        	    // OracleDMLLexer.g:704:68: QS_PAREN
        	    {
        	        /* 704:68: QS_PAREN */
        	        mQS_PAREN();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;
        	case 5:
        	    // OracleDMLLexer.g:704:79: QS_OTHER
        	    {
        	        /* 704:79: QS_OTHER */
        	        mQS_OTHER();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;

            }
        }

        {
            _type = CHAR_STRING;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCHAR_STRING_PERLEx; /* Prevent compiler warnings */
    ruleCHAR_STRING_PERLEx: ;

}
// $ANTLR end CHAR_STRING_PERL

//   Comes from: 705:21: ( '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUOTE
 *
 * Looks to match the characters the constitute the token QUOTE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mQUOTE()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:705:21: ( '\\'' )
    // OracleDMLLexer.g:705:23: '\\''
    {
         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleQUOTEEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleQUOTEEx; /* Prevent compiler warnings */
    ruleQUOTEEx: ;

}
// $ANTLR end QUOTE

//   Comes from: 706:21: ( QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_ANGLE
 *
 * Looks to match the characters the constitute the token QS_ANGLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mQS_ANGLE()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:706:21: ( QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE )
    // OracleDMLLexer.g:706:23: QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE
    {
        /* 706:23: QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_ANGLEEx;
        }



         this->matchc('<');
        if  (this->hasException())
        {
            goto ruleQS_ANGLEEx;
        }


        // OracleDMLLexer.g:706:33: ( options {greedy=false; } : . )*

        for (;;)
        {
            ANTLR_UINT32 alt18=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                ANTLR_UINT32 LA18_0 = this->LA(1);
                if ( (LA18_0 == '>'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        ANTLR_UINT32 LA18_1 = this->LA(2);
                        if ( (LA18_1 == '\''))
                        {
                            alt18=2;
                        }
                        else if ( (((LA18_1 >= 0x0000) && (LA18_1 <= '&')) || ((LA18_1 >= '(') && (LA18_1 <= 0xFFFF))))
                        {
                            alt18=1;
                        }

                    }
                }
                else if ( (((LA18_0 >= 0x0000) && (LA18_0 <= '=')) || ((LA18_0 >= '?') && (LA18_0 <= 0xFFFF))))
                {
                    alt18=1;
                }

            }
            switch (alt18)
            {
        	case 1:
        	    // OracleDMLLexer.g:706:61: .
        	    {
        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_ANGLEEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop18;	/* break out of the loop */
        	    break;
            }
        }
        loop18: ; /* Jump out to here if this rule does not match */


         this->matchc('>');
        if  (this->hasException())
        {
            goto ruleQS_ANGLEEx;
        }


        /* 706:23: QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_ANGLEEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_ANGLEEx; /* Prevent compiler warnings */
    ruleQS_ANGLEEx: ;

}
// $ANTLR end QS_ANGLE

//   Comes from: 707:21: ( QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_BRACE
 *
 * Looks to match the characters the constitute the token QS_BRACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mQS_BRACE()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:707:21: ( QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE )
    // OracleDMLLexer.g:707:23: QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE
    {
        /* 707:23: QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_BRACEEx;
        }



         this->matchc('{');
        if  (this->hasException())
        {
            goto ruleQS_BRACEEx;
        }


        // OracleDMLLexer.g:707:33: ( options {greedy=false; } : . )*

        for (;;)
        {
            ANTLR_UINT32 alt19=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                ANTLR_UINT32 LA19_0 = this->LA(1);
                if ( (LA19_0 == '}'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        ANTLR_UINT32 LA19_1 = this->LA(2);
                        if ( (LA19_1 == '\''))
                        {
                            alt19=2;
                        }
                        else if ( (((LA19_1 >= 0x0000) && (LA19_1 <= '&')) || ((LA19_1 >= '(') && (LA19_1 <= 0xFFFF))))
                        {
                            alt19=1;
                        }

                    }
                }
                else if ( (((LA19_0 >= 0x0000) && (LA19_0 <= '|')) || ((LA19_0 >= '~') && (LA19_0 <= 0xFFFF))))
                {
                    alt19=1;
                }

            }
            switch (alt19)
            {
        	case 1:
        	    // OracleDMLLexer.g:707:61: .
        	    {
        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_BRACEEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop19;	/* break out of the loop */
        	    break;
            }
        }
        loop19: ; /* Jump out to here if this rule does not match */


         this->matchc('}');
        if  (this->hasException())
        {
            goto ruleQS_BRACEEx;
        }


        /* 707:23: QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_BRACEEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_BRACEEx; /* Prevent compiler warnings */
    ruleQS_BRACEEx: ;

}
// $ANTLR end QS_BRACE

//   Comes from: 708:21: ( QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_BRACK
 *
 * Looks to match the characters the constitute the token QS_BRACK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mQS_BRACK()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:708:21: ( QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE )
    // OracleDMLLexer.g:708:23: QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE
    {
        /* 708:23: QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_BRACKEx;
        }



         this->matchc('[');
        if  (this->hasException())
        {
            goto ruleQS_BRACKEx;
        }


        // OracleDMLLexer.g:708:33: ( options {greedy=false; } : . )*

        for (;;)
        {
            ANTLR_UINT32 alt20=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                ANTLR_UINT32 LA20_0 = this->LA(1);
                if ( (LA20_0 == ']'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        ANTLR_UINT32 LA20_1 = this->LA(2);
                        if ( (LA20_1 == '\''))
                        {
                            alt20=2;
                        }
                        else if ( (((LA20_1 >= 0x0000) && (LA20_1 <= '&')) || ((LA20_1 >= '(') && (LA20_1 <= 0xFFFF))))
                        {
                            alt20=1;
                        }

                    }
                }
                else if ( (((LA20_0 >= 0x0000) && (LA20_0 <= '\\')) || ((LA20_0 >= '^') && (LA20_0 <= 0xFFFF))))
                {
                    alt20=1;
                }

            }
            switch (alt20)
            {
        	case 1:
        	    // OracleDMLLexer.g:708:61: .
        	    {
        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_BRACKEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop20;	/* break out of the loop */
        	    break;
            }
        }
        loop20: ; /* Jump out to here if this rule does not match */


         this->matchc(']');
        if  (this->hasException())
        {
            goto ruleQS_BRACKEx;
        }


        /* 708:23: QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_BRACKEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_BRACKEx; /* Prevent compiler warnings */
    ruleQS_BRACKEx: ;

}
// $ANTLR end QS_BRACK

//   Comes from: 709:21: ( QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_PAREN
 *
 * Looks to match the characters the constitute the token QS_PAREN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mQS_PAREN()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:709:21: ( QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE )
    // OracleDMLLexer.g:709:23: QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE
    {
        /* 709:23: QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_PARENEx;
        }



         this->matchc('(');
        if  (this->hasException())
        {
            goto ruleQS_PARENEx;
        }


        // OracleDMLLexer.g:709:33: ( options {greedy=false; } : . )*

        for (;;)
        {
            ANTLR_UINT32 alt21=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                ANTLR_UINT32 LA21_0 = this->LA(1);
                if ( (LA21_0 == ')'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        ANTLR_UINT32 LA21_1 = this->LA(2);
                        if ( (LA21_1 == '\''))
                        {
                            alt21=2;
                        }
                        else if ( (((LA21_1 >= 0x0000) && (LA21_1 <= '&')) || ((LA21_1 >= '(') && (LA21_1 <= 0xFFFF))))
                        {
                            alt21=1;
                        }

                    }
                }
                else if ( (((LA21_0 >= 0x0000) && (LA21_0 <= '(')) || ((LA21_0 >= '*') && (LA21_0 <= 0xFFFF))))
                {
                    alt21=1;
                }

            }
            switch (alt21)
            {
        	case 1:
        	    // OracleDMLLexer.g:709:61: .
        	    {
        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_PARENEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop21;	/* break out of the loop */
        	    break;
            }
        }
        loop21: ; /* Jump out to here if this rule does not match */


         this->matchc(')');
        if  (this->hasException())
        {
            goto ruleQS_PARENEx;
        }


        /* 709:23: QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_PARENEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_PARENEx; /* Prevent compiler warnings */
    ruleQS_PARENEx: ;

}
// $ANTLR end QS_PAREN

//   Comes from: 711:21: (~ ( '<' | '{' | '[' | '(' | ' ' | '\\t' | '\\n' | '\\r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_OTHER_CH
 *
 * Looks to match the characters the constitute the token QS_OTHER_CH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mQS_OTHER_CH()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:711:21: (~ ( '<' | '{' | '[' | '(' | ' ' | '\\t' | '\\n' | '\\r' ) )
    // OracleDMLLexer.g:
    {
        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\b')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= 0x001F)) || ((this->LA(1) >= '!') && (this->LA(1) <= '\'')) || ((this->LA(1) >= ')') && (this->LA(1) <= ';')) || ((this->LA(1) >= '=') && (this->LA(1) <= 'Z')) || ((this->LA(1) >= '\\') && (this->LA(1) <= 'z')) || ((this->LA(1) >= '|') && (this->LA(1) <= 0xFFFF)) )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleQS_OTHER_CHEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleQS_OTHER_CHEx; /* Prevent compiler warnings */
    ruleQS_OTHER_CHEx: ;

}
// $ANTLR end QS_OTHER_CH

//   Comes from: 721:3: ( QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_OTHER
 *
 * Looks to match the characters the constitute the token QS_OTHER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mQS_OTHER()
{
    ANTLR_UINT32	_type;
      

    std::unique_ptr<ImplTraits::CommonTokenType> delimiter = NULL;


    // OracleDMLLexer.g:721:3: ( QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE )
    // OracleDMLLexer.g:722:3: QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE
    {
        /* 722:3: QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_OTHEREx;
        }



        /* 722:3: QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE */
        {
            ANTLR_MARKER delimiterStart4445 = this->getCharIndex();
            ANTLR_UINT32 delimiterStartLine4445 = this->getLine();
            ANTLR_UINT32 delimiterStartCharPos4445 = this->getCharPositionInLine();
        mQS_OTHER_CH( );
            if  (this->hasException())
            {
                goto ruleQS_OTHEREx;
            }

            delimiter.reset( new CommonTokenType() );
            delimiter->set_type( CommonTokenType::TOKEN_INVALID);
            delimiter->set_startIndex( delimiterStart4445 );
            delimiter->set_stopIndex( this->getCharIndex()-1 );
            delimiter->set_input( this->get_input() );
            delimiter->set_line( delimiterStartLine4445 );
            delimiter->set_charPositionInLine( delimiterStartCharPos4445 );
        }


        // OracleDMLLexer.g:731:3: ({...}? => . )*

        for (;;)
        {
            ANTLR_UINT32 alt22=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                ANTLR_UINT32 LA22_0 = this->LA(1);
                if ( (((LA22_0 >= 0x0000) && (LA22_0 <= 0xFFFF))) && (((( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' ))||(( LA(1) == delimiter->getText().at(0) && LA(2) == '\'' )))))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        ANTLR_UINT32 LA22_1 = this->LA(2);
                        if ( (LA22_1 == '\'') && (((( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' ))||(( LA(1) == delimiter->getText().at(0) && LA(2) == '\'' )))))
                        {
                            {
                               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                */
                                ANTLR_UINT32 LA22_2 = this->LA(3);
                                if ( (((LA22_2 >= 0x0000) && (LA22_2 <= 0xFFFF))) && (( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' )))
                                {
                                    alt22=1;
                                }

                            }
                        }
                        else if ( (((LA22_1 >= 0x0000) && (LA22_1 <= '&')) || ((LA22_1 >= '(') && (LA22_1 <= 0xFFFF))) && (( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' )))
                        {
                            alt22=1;
                        }

                    }
                }

            }
            switch (alt22)
            {
        	case 1:
        	    // OracleDMLLexer.g:731:5: {...}? => .
        	    {
        	        if ( !(( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' )) )
        	        {
        	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLLexerImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " LA(1) != $delimiter->getText().at(0) || LA(2) != '\\'' " );
        	                ex->set_ruleName( "QS_OTHER" );


        	        }

        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_OTHEREx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop22;	/* break out of the loop */
        	    break;
            }
        }
        loop22: ; /* Jump out to here if this rule does not match */


        // OracleDMLLexer.g:732:3: ({...}? => . )
        // OracleDMLLexer.g:732:5: {...}? => .
        {
            if ( !(( LA(1) == delimiter->getText().at(0) && LA(2) == '\'' )) )
            {
                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLLexerImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " LA(1) == $delimiter->getText().at(0) && LA(2) == '\\'' " );
                    ex->set_ruleName( "QS_OTHER" );


            }

            this->matchAny();
            if  (this->hasException())
            {
                goto ruleQS_OTHEREx;
            }


        }


        /* 722:3: QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_OTHEREx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_OTHEREx; /* Prevent compiler warnings */
    ruleQS_OTHEREx: ;

    delimiter = NULL;

}
// $ANTLR end QS_OTHER

//   Comes from: 738:5: ( '\"' (~ ( '\"' | '\\r' | '\\n' ) | '\"' '\"' )+ '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DELIMITED_ID
 *
 * Looks to match the characters the constitute the token DELIMITED_ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mDELIMITED_ID()
{
    ANTLR_UINT32	_type;
      

    _type	    = DELIMITED_ID;


    // OracleDMLLexer.g:738:5: ( '\"' (~ ( '\"' | '\\r' | '\\n' ) | '\"' '\"' )+ '\"' )
    // OracleDMLLexer.g:738:10: '\"' (~ ( '\"' | '\\r' | '\\n' ) | '\"' '\"' )+ '\"'
    {
         this->matchc('"');
        if  (this->hasException())
        {
            goto ruleDELIMITED_IDEx;
        }


        // OracleDMLLexer.g:738:14: (~ ( '\"' | '\\r' | '\\n' ) | '\"' '\"' )+
        {
            int cnt23=0;

            for (;;)
            {
                ANTLR_UINT32 alt23=3;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    ANTLR_UINT32 LA23_0 = this->LA(1);
        	    if ( (LA23_0 == '"'))
        	    {
        	        switch ( this->LA(2) )
        	        {
        	        case '"':
        	        	{
        	        		alt23=2;
        	        	}
        	            break;

        	        }

        	    }
        	    else if ( (((LA23_0 >= 0x0000) && (LA23_0 <= '\t')) || ((LA23_0 >= 0x000B) && (LA23_0 <= '\f')) || ((LA23_0 >= 0x000E) && (LA23_0 <= '!')) || ((LA23_0 >= '#') && (LA23_0 <= 0xFFFF))))
        	    {
        	        alt23=1;
        	    }

        	}
        	switch (alt23)
        	{
        	    case 1:
        	        // OracleDMLLexer.g:738:15: ~ ( '\"' | '\\r' | '\\n' )
        	        {
        	            if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= '!')) || ((this->LA(1) >= '#') && (this->LA(1) <= 0xFFFF)) )
        	            {
        	                this->consume();
        	            }
        	            else
        	            {
        	                new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	                this->recover();
        	                goto ruleDELIMITED_IDEx;
        	            }


        	        }
        	        break;
        	    case 2:
        	        // OracleDMLLexer.g:738:38: '\"' '\"'
        	        {
        	             this->matchc('"');
        	            if  (this->hasException())
        	            {
        	                goto ruleDELIMITED_IDEx;
        	            }


        	             this->matchc('"');
        	            if  (this->hasException())
        	            {
        	                goto ruleDELIMITED_IDEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt23 >= 1 )
        		{
        		    goto loop23;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< OracleDMLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleDELIMITED_IDEx;
        	}
        	cnt23++;
            }
            loop23: ;	/* Jump to here if this rule does not match */
        }

         this->matchc('"');
        if  (this->hasException())
        {
            goto ruleDELIMITED_IDEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleDELIMITED_IDEx; /* Prevent compiler warnings */
    ruleDELIMITED_IDEx: ;

}
// $ANTLR end DELIMITED_ID

//   Comes from: 744:5: ( '%' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PERCENT
 *
 * Looks to match the characters the constitute the token PERCENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPERCENT()
{
    ANTLR_UINT32	_type;
      

    _type	    = PERCENT;


    // OracleDMLLexer.g:744:5: ( '%' )
    // OracleDMLLexer.g:744:10: '%'
    {
         this->matchc('%');
        if  (this->hasException())
        {
            goto rulePERCENTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePERCENTEx; /* Prevent compiler warnings */
    rulePERCENTEx: ;

}
// $ANTLR end PERCENT

//   Comes from: 748:5: ( '&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AMPERSAND
 *
 * Looks to match the characters the constitute the token AMPERSAND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mAMPERSAND()
{
    ANTLR_UINT32	_type;
      

    _type	    = AMPERSAND;


    // OracleDMLLexer.g:748:5: ( '&' )
    // OracleDMLLexer.g:748:10: '&'
    {
         this->matchc('&');
        if  (this->hasException())
        {
            goto ruleAMPERSANDEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleAMPERSANDEx; /* Prevent compiler warnings */
    ruleAMPERSANDEx: ;

}
// $ANTLR end AMPERSAND

//   Comes from: 752:5: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LEFT_PAREN
 *
 * Looks to match the characters the constitute the token LEFT_PAREN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mLEFT_PAREN()
{
    ANTLR_UINT32	_type;
      

    _type	    = LEFT_PAREN;


    // OracleDMLLexer.g:752:5: ( '(' )
    // OracleDMLLexer.g:752:10: '('
    {
         this->matchc('(');
        if  (this->hasException())
        {
            goto ruleLEFT_PARENEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLEFT_PARENEx; /* Prevent compiler warnings */
    ruleLEFT_PARENEx: ;

}
// $ANTLR end LEFT_PAREN

//   Comes from: 756:5: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RIGHT_PAREN
 *
 * Looks to match the characters the constitute the token RIGHT_PAREN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mRIGHT_PAREN()
{
    ANTLR_UINT32	_type;
      

    _type	    = RIGHT_PAREN;


    // OracleDMLLexer.g:756:5: ( ')' )
    // OracleDMLLexer.g:756:10: ')'
    {
         this->matchc(')');
        if  (this->hasException())
        {
            goto ruleRIGHT_PARENEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRIGHT_PARENEx; /* Prevent compiler warnings */
    ruleRIGHT_PARENEx: ;

}
// $ANTLR end RIGHT_PAREN

//   Comes from: 760:5: ( '**' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_ASTERISK
 *
 * Looks to match the characters the constitute the token DOUBLE_ASTERISK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mDOUBLE_ASTERISK()
{
    ANTLR_UINT32	_type;
      

    _type	    = DOUBLE_ASTERISK;


    // OracleDMLLexer.g:760:5: ( '**' )
    // OracleDMLLexer.g:760:10: '**'
    {
        this->matchs(lit_2);
        if  (this->hasException())
        {
            goto ruleDOUBLE_ASTERISKEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_ASTERISKEx; /* Prevent compiler warnings */
    ruleDOUBLE_ASTERISKEx: ;

}
// $ANTLR end DOUBLE_ASTERISK

//   Comes from: 764:5: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASTERISK
 *
 * Looks to match the characters the constitute the token ASTERISK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mASTERISK()
{
    ANTLR_UINT32	_type;
      

    _type	    = ASTERISK;


    // OracleDMLLexer.g:764:5: ( '*' )
    // OracleDMLLexer.g:764:10: '*'
    {
         this->matchc('*');
        if  (this->hasException())
        {
            goto ruleASTERISKEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleASTERISKEx; /* Prevent compiler warnings */
    ruleASTERISKEx: ;

}
// $ANTLR end ASTERISK

//   Comes from: 768:5: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLUS_SIGN
 *
 * Looks to match the characters the constitute the token PLUS_SIGN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLUS_SIGN()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLUS_SIGN;


    // OracleDMLLexer.g:768:5: ( '+' )
    // OracleDMLLexer.g:768:10: '+'
    {
         this->matchc('+');
        if  (this->hasException())
        {
            goto rulePLUS_SIGNEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLUS_SIGNEx; /* Prevent compiler warnings */
    rulePLUS_SIGNEx: ;

}
// $ANTLR end PLUS_SIGN

//   Comes from: 772:5: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMA
 *
 * Looks to match the characters the constitute the token COMMA
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mCOMMA()
{
    ANTLR_UINT32	_type;
      

    _type	    = COMMA;


    // OracleDMLLexer.g:772:5: ( ',' )
    // OracleDMLLexer.g:772:10: ','
    {
         this->matchc(',');
        if  (this->hasException())
        {
            goto ruleCOMMAEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCOMMAEx; /* Prevent compiler warnings */
    ruleCOMMAEx: ;

}
// $ANTLR end COMMA

//   Comes from: 776:5: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SOLIDUS
 *
 * Looks to match the characters the constitute the token SOLIDUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSOLIDUS()
{
    ANTLR_UINT32	_type;
      

    _type	    = SOLIDUS;


    // OracleDMLLexer.g:776:5: ( '/' )
    // OracleDMLLexer.g:776:10: '/'
    {
         this->matchc('/');
        if  (this->hasException())
        {
            goto ruleSOLIDUSEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSOLIDUSEx; /* Prevent compiler warnings */
    ruleSOLIDUSEx: ;

}
// $ANTLR end SOLIDUS

//   Comes from: 780:5: ( '@' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AT_SIGN
 *
 * Looks to match the characters the constitute the token AT_SIGN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mAT_SIGN()
{
    ANTLR_UINT32	_type;
      

    _type	    = AT_SIGN;


    // OracleDMLLexer.g:780:5: ( '@' )
    // OracleDMLLexer.g:780:10: '@'
    {
         this->matchc('@');
        if  (this->hasException())
        {
            goto ruleAT_SIGNEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleAT_SIGNEx; /* Prevent compiler warnings */
    ruleAT_SIGNEx: ;

}
// $ANTLR end AT_SIGN

//   Comes from: 784:5: ( ':=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASSIGN_OP
 *
 * Looks to match the characters the constitute the token ASSIGN_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mASSIGN_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = ASSIGN_OP;


    // OracleDMLLexer.g:784:5: ( ':=' )
    // OracleDMLLexer.g:784:10: ':='
    {
        this->matchs(lit_3);
        if  (this->hasException())
        {
            goto ruleASSIGN_OPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleASSIGN_OPEx; /* Prevent compiler warnings */
    ruleASSIGN_OPEx: ;

}
// $ANTLR end ASSIGN_OP

//   Comes from: 789:5: ( COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )* | COLON DELIMITED_ID | COLON UNSIGNED_INTEGER | QUESTION_MARK )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BINDVAR
 *
 * Looks to match the characters the constitute the token BINDVAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mBINDVAR()
{
    ANTLR_UINT32	_type;
      

    _type	    = BINDVAR;


    {
        //  OracleDMLLexer.g:789:5: ( COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )* | COLON DELIMITED_ID | COLON UNSIGNED_INTEGER | QUESTION_MARK )

        ANTLR_UINT32 alt25;

        alt25=4;

        switch ( this->LA(1) )
        {
        case ':':
        	{
        		switch ( this->LA(2) )
        		{
        		case 'A':
        		case 'B':
        		case 'C':
        		case 'D':
        		case 'E':
        		case 'F':
        		case 'G':
        		case 'H':
        		case 'I':
        		case 'J':
        		case 'K':
        		case 'L':
        		case 'M':
        		case 'N':
        		case 'O':
        		case 'P':
        		case 'Q':
        		case 'R':
        		case 'S':
        		case 'T':
        		case 'U':
        		case 'V':
        		case 'W':
        		case 'X':
        		case 'Y':
        		case 'Z':
        		case 'a':
        		case 'b':
        		case 'c':
        		case 'd':
        		case 'e':
        		case 'f':
        		case 'g':
        		case 'h':
        		case 'i':
        		case 'j':
        		case 'k':
        		case 'l':
        		case 'm':
        		case 'n':
        		case 'o':
        		case 'p':
        		case 'q':
        		case 'r':
        		case 's':
        		case 't':
        		case 'u':
        		case 'v':
        		case 'w':
        		case 'x':
        		case 'y':
        		case 'z':
        			{
        				alt25=1;
        			}
        		    break;
        		case '"':
        			{
        				alt25=2;
        			}
        		    break;
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        		case '8':
        		case '9':
        			{
        				alt25=3;
        			}
        		    break;

        		default:
        		    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        		    ex->set_decisionNum( 25 );
        		    ex->set_state( 1 );


        		    goto ruleBINDVAREx;

        		}

        	}
            break;
        case '?':
        	{
        		alt25=4;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 25 );
            ex->set_state( 0 );


            goto ruleBINDVAREx;

        }

        switch (alt25)
        {
    	case 1:
    	    // OracleDMLLexer.g:789:10: COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )*
    	    {
    	        /* 789:10: COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )* */
    	        mCOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	        /* 789:10: COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )* */
    	        mSIMPLE_LETTER();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	        // OracleDMLLexer.g:789:31: ( SIMPLE_LETTER | '0' .. '9' | '_' )*

    	        for (;;)
    	        {
    	            ANTLR_UINT32 alt24=2;
    	            switch ( this->LA(1) )
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            case 'A':
    	            case 'B':
    	            case 'C':
    	            case 'D':
    	            case 'E':
    	            case 'F':
    	            case 'G':
    	            case 'H':
    	            case 'I':
    	            case 'J':
    	            case 'K':
    	            case 'L':
    	            case 'M':
    	            case 'N':
    	            case 'O':
    	            case 'P':
    	            case 'Q':
    	            case 'R':
    	            case 'S':
    	            case 'T':
    	            case 'U':
    	            case 'V':
    	            case 'W':
    	            case 'X':
    	            case 'Y':
    	            case 'Z':
    	            case '_':
    	            case 'a':
    	            case 'b':
    	            case 'c':
    	            case 'd':
    	            case 'e':
    	            case 'f':
    	            case 'g':
    	            case 'h':
    	            case 'i':
    	            case 'j':
    	            case 'k':
    	            case 'l':
    	            case 'm':
    	            case 'n':
    	            case 'o':
    	            case 'p':
    	            case 'q':
    	            case 'r':
    	            case 's':
    	            case 't':
    	            case 'u':
    	            case 'v':
    	            case 'w':
    	            case 'x':
    	            case 'y':
    	            case 'z':
    	            	{
    	            		alt24=1;
    	            	}
    	                break;

    	            }

    	            switch (alt24)
    	            {
    	        	case 1:
    	        	    // OracleDMLLexer.g:
    	        	    {
    	        	        if ( ((this->LA(1) >= '0') && (this->LA(1) <= '9')) || ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || this->LA(1) == '_' || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
    	        	        {
    	        	            this->consume();
    	        	        }
    	        	        else
    	        	        {
    	        	            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

    	        	            this->recover();
    	        	            goto ruleBINDVAREx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop24;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop24: ; /* Jump out to here if this rule does not match */


    	    }
    	    break;
    	case 2:
    	    // OracleDMLLexer.g:790:10: COLON DELIMITED_ID
    	    {
    	        /* 790:10: COLON DELIMITED_ID */
    	        mCOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	        /* 790:10: COLON DELIMITED_ID */
    	        mDELIMITED_ID();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // OracleDMLLexer.g:791:10: COLON UNSIGNED_INTEGER
    	    {
    	        /* 791:10: COLON UNSIGNED_INTEGER */
    	        mCOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	        /* 791:10: COLON UNSIGNED_INTEGER */
    	        mUNSIGNED_INTEGER();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // OracleDMLLexer.g:792:10: QUESTION_MARK
    	    {
    	        /* 792:10: QUESTION_MARK */
    	        mQUESTION_MARK();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleBINDVAREx; /* Prevent compiler warnings */
    ruleBINDVAREx: ;

}
// $ANTLR end BINDVAR

//   Comes from: 796:5: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COLON
 *
 * Looks to match the characters the constitute the token COLON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mCOLON()
{
    ANTLR_UINT32	_type;
      

    _type	    = COLON;


    // OracleDMLLexer.g:796:5: ( ':' )
    // OracleDMLLexer.g:796:10: ':'
    {
         this->matchc(':');
        if  (this->hasException())
        {
            goto ruleCOLONEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCOLONEx; /* Prevent compiler warnings */
    ruleCOLONEx: ;

}
// $ANTLR end COLON

//   Comes from: 800:5: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEMICOLON
 *
 * Looks to match the characters the constitute the token SEMICOLON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSEMICOLON()
{
    ANTLR_UINT32	_type;
      

    _type	    = SEMICOLON;


    // OracleDMLLexer.g:800:5: ( ';' )
    // OracleDMLLexer.g:800:10: ';'
    {
         this->matchc(';');
        if  (this->hasException())
        {
            goto ruleSEMICOLONEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSEMICOLONEx; /* Prevent compiler warnings */
    ruleSEMICOLONEx: ;

}
// $ANTLR end SEMICOLON

//   Comes from: 804:5: ( '<=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LESS_THAN_OR_EQUALS_OP
 *
 * Looks to match the characters the constitute the token LESS_THAN_OR_EQUALS_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mLESS_THAN_OR_EQUALS_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = LESS_THAN_OR_EQUALS_OP;


    // OracleDMLLexer.g:804:5: ( '<=' )
    // OracleDMLLexer.g:804:10: '<='
    {
        this->matchs(lit_4);
        if  (this->hasException())
        {
            goto ruleLESS_THAN_OR_EQUALS_OPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLESS_THAN_OR_EQUALS_OPEx; /* Prevent compiler warnings */
    ruleLESS_THAN_OR_EQUALS_OPEx: ;

}
// $ANTLR end LESS_THAN_OR_EQUALS_OP

//   Comes from: 808:5: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LESS_THAN_OP
 *
 * Looks to match the characters the constitute the token LESS_THAN_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mLESS_THAN_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = LESS_THAN_OP;


    // OracleDMLLexer.g:808:5: ( '<' )
    // OracleDMLLexer.g:808:10: '<'
    {
         this->matchc('<');
        if  (this->hasException())
        {
            goto ruleLESS_THAN_OPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLESS_THAN_OPEx; /* Prevent compiler warnings */
    ruleLESS_THAN_OPEx: ;

}
// $ANTLR end LESS_THAN_OP

//   Comes from: 812:5: ( '>=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GREATER_THAN_OR_EQUALS_OP
 *
 * Looks to match the characters the constitute the token GREATER_THAN_OR_EQUALS_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mGREATER_THAN_OR_EQUALS_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = GREATER_THAN_OR_EQUALS_OP;


    // OracleDMLLexer.g:812:5: ( '>=' )
    // OracleDMLLexer.g:812:10: '>='
    {
        this->matchs(lit_5);
        if  (this->hasException())
        {
            goto ruleGREATER_THAN_OR_EQUALS_OPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleGREATER_THAN_OR_EQUALS_OPEx; /* Prevent compiler warnings */
    ruleGREATER_THAN_OR_EQUALS_OPEx: ;

}
// $ANTLR end GREATER_THAN_OR_EQUALS_OP

//   Comes from: 816:5: ( '!=' | '<>' | '^=' | '~=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOT_EQUAL_OP
 *
 * Looks to match the characters the constitute the token NOT_EQUAL_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mNOT_EQUAL_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = NOT_EQUAL_OP;


    {
        //  OracleDMLLexer.g:816:5: ( '!=' | '<>' | '^=' | '~=' )

        ANTLR_UINT32 alt26;

        alt26=4;

        switch ( this->LA(1) )
        {
        case '!':
        	{
        		alt26=1;
        	}
            break;
        case '<':
        	{
        		alt26=2;
        	}
            break;
        case '^':
        	{
        		alt26=3;
        	}
            break;
        case '~':
        	{
        		alt26=4;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 26 );
            ex->set_state( 0 );


            goto ruleNOT_EQUAL_OPEx;

        }

        switch (alt26)
        {
    	case 1:
    	    // OracleDMLLexer.g:816:10: '!='
    	    {
    	        this->matchs(lit_6);
    	        if  (this->hasException())
    	        {
    	            goto ruleNOT_EQUAL_OPEx;
    	        }




    	    }
    	    break;
    	case 2:
    	    // OracleDMLLexer.g:817:10: '<>'
    	    {
    	        this->matchs(lit_7);
    	        if  (this->hasException())
    	        {
    	            goto ruleNOT_EQUAL_OPEx;
    	        }




    	    }
    	    break;
    	case 3:
    	    // OracleDMLLexer.g:818:10: '^='
    	    {
    	        this->matchs(lit_8);
    	        if  (this->hasException())
    	        {
    	            goto ruleNOT_EQUAL_OPEx;
    	        }




    	    }
    	    break;
    	case 4:
    	    // OracleDMLLexer.g:819:10: '~='
    	    {
    	        this->matchs(lit_9);
    	        if  (this->hasException())
    	        {
    	            goto ruleNOT_EQUAL_OPEx;
    	        }




    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleNOT_EQUAL_OPEx; /* Prevent compiler warnings */
    ruleNOT_EQUAL_OPEx: ;

}
// $ANTLR end NOT_EQUAL_OP

//   Comes from: 822:5: ( '^' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CARRET_OPERATOR_PART
 *
 * Looks to match the characters the constitute the token CARRET_OPERATOR_PART
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mCARRET_OPERATOR_PART()
{
    ANTLR_UINT32	_type;
      

    _type	    = CARRET_OPERATOR_PART;


    // OracleDMLLexer.g:822:5: ( '^' )
    // OracleDMLLexer.g:822:10: '^'
    {
         this->matchc('^');
        if  (this->hasException())
        {
            goto ruleCARRET_OPERATOR_PARTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCARRET_OPERATOR_PARTEx; /* Prevent compiler warnings */
    ruleCARRET_OPERATOR_PARTEx: ;

}
// $ANTLR end CARRET_OPERATOR_PART

//   Comes from: 826:5: ( '~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TILDE_OPERATOR_PART
 *
 * Looks to match the characters the constitute the token TILDE_OPERATOR_PART
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mTILDE_OPERATOR_PART()
{
    ANTLR_UINT32	_type;
      

    _type	    = TILDE_OPERATOR_PART;


    // OracleDMLLexer.g:826:5: ( '~' )
    // OracleDMLLexer.g:826:10: '~'
    {
         this->matchc('~');
        if  (this->hasException())
        {
            goto ruleTILDE_OPERATOR_PARTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleTILDE_OPERATOR_PARTEx; /* Prevent compiler warnings */
    ruleTILDE_OPERATOR_PARTEx: ;

}
// $ANTLR end TILDE_OPERATOR_PART

//   Comes from: 830:5: ( '!' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXCLAMATION_OPERATOR_PART
 *
 * Looks to match the characters the constitute the token EXCLAMATION_OPERATOR_PART
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mEXCLAMATION_OPERATOR_PART()
{
    ANTLR_UINT32	_type;
      

    _type	    = EXCLAMATION_OPERATOR_PART;


    // OracleDMLLexer.g:830:5: ( '!' )
    // OracleDMLLexer.g:830:10: '!'
    {
         this->matchc('!');
        if  (this->hasException())
        {
            goto ruleEXCLAMATION_OPERATOR_PARTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleEXCLAMATION_OPERATOR_PARTEx; /* Prevent compiler warnings */
    ruleEXCLAMATION_OPERATOR_PARTEx: ;

}
// $ANTLR end EXCLAMATION_OPERATOR_PART

//   Comes from: 834:5: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GREATER_THAN_OP
 *
 * Looks to match the characters the constitute the token GREATER_THAN_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mGREATER_THAN_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = GREATER_THAN_OP;


    // OracleDMLLexer.g:834:5: ( '>' )
    // OracleDMLLexer.g:834:10: '>'
    {
         this->matchc('>');
        if  (this->hasException())
        {
            goto ruleGREATER_THAN_OPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleGREATER_THAN_OPEx; /* Prevent compiler warnings */
    ruleGREATER_THAN_OPEx: ;

}
// $ANTLR end GREATER_THAN_OP

//   Comes from: 839:5: ( '?' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUESTION_MARK
 *
 * Looks to match the characters the constitute the token QUESTION_MARK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mQUESTION_MARK()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:839:5: ( '?' )
    // OracleDMLLexer.g:839:10: '?'
    {
         this->matchc('?');
        if  (this->hasException())
        {
            goto ruleQUESTION_MARKEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleQUESTION_MARKEx; /* Prevent compiler warnings */
    ruleQUESTION_MARKEx: ;

}
// $ANTLR end QUESTION_MARK

//   Comes from: 844:5: ( '||' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONCATENATION_OP
 *
 * Looks to match the characters the constitute the token CONCATENATION_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mCONCATENATION_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = CONCATENATION_OP;


    // OracleDMLLexer.g:844:5: ( '||' )
    // OracleDMLLexer.g:844:10: '||'
    {
        this->matchs(lit_10);
        if  (this->hasException())
        {
            goto ruleCONCATENATION_OPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCONCATENATION_OPEx; /* Prevent compiler warnings */
    ruleCONCATENATION_OPEx: ;

}
// $ANTLR end CONCATENATION_OP

//   Comes from: 848:5: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VERTICAL_BAR
 *
 * Looks to match the characters the constitute the token VERTICAL_BAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mVERTICAL_BAR()
{
    ANTLR_UINT32	_type;
      

    _type	    = VERTICAL_BAR;


    // OracleDMLLexer.g:848:5: ( '|' )
    // OracleDMLLexer.g:848:10: '|'
    {
         this->matchc('|');
        if  (this->hasException())
        {
            goto ruleVERTICAL_BAREx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleVERTICAL_BAREx; /* Prevent compiler warnings */
    ruleVERTICAL_BAREx: ;

}
// $ANTLR end VERTICAL_BAR

//   Comes from: 852:5: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EQUALS_OP
 *
 * Looks to match the characters the constitute the token EQUALS_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mEQUALS_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = EQUALS_OP;


    // OracleDMLLexer.g:852:5: ( '=' )
    // OracleDMLLexer.g:852:10: '='
    {
         this->matchc('=');
        if  (this->hasException())
        {
            goto ruleEQUALS_OPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleEQUALS_OPEx; /* Prevent compiler warnings */
    ruleEQUALS_OPEx: ;

}
// $ANTLR end EQUALS_OP

//   Comes from: 857:5: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LEFT_BRACKET
 *
 * Looks to match the characters the constitute the token LEFT_BRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mLEFT_BRACKET()
{
    ANTLR_UINT32	_type;
      

    _type	    = LEFT_BRACKET;


    // OracleDMLLexer.g:857:5: ( '[' )
    // OracleDMLLexer.g:857:10: '['
    {
         this->matchc('[');
        if  (this->hasException())
        {
            goto ruleLEFT_BRACKETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLEFT_BRACKETEx; /* Prevent compiler warnings */
    ruleLEFT_BRACKETEx: ;

}
// $ANTLR end LEFT_BRACKET

//   Comes from: 861:5: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RIGHT_BRACKET
 *
 * Looks to match the characters the constitute the token RIGHT_BRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mRIGHT_BRACKET()
{
    ANTLR_UINT32	_type;
      

    _type	    = RIGHT_BRACKET;


    // OracleDMLLexer.g:861:5: ( ']' )
    // OracleDMLLexer.g:861:10: ']'
    {
         this->matchc(']');
        if  (this->hasException())
        {
            goto ruleRIGHT_BRACKETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRIGHT_BRACKETEx; /* Prevent compiler warnings */
    ruleRIGHT_BRACKETEx: ;

}
// $ANTLR end RIGHT_BRACKET

//   Comes from: 868:5: ( '_' ( SEPARATOR )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INTRODUCER
 *
 * Looks to match the characters the constitute the token INTRODUCER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mINTRODUCER()
{
    ANTLR_UINT32	_type;
      

    _type	    = INTRODUCER;


    // OracleDMLLexer.g:868:5: ( '_' ( SEPARATOR )? )
    // OracleDMLLexer.g:868:10: '_' ( SEPARATOR )?
    {
         this->matchc('_');
        if  (this->hasException())
        {
            goto ruleINTRODUCEREx;
        }


        // OracleDMLLexer.g:868:14: ( SEPARATOR )?
        {
            ANTLR_UINT32 alt27=2;
            switch ( this->LA(1) )
            {
                case '\t':
                case '\n':
                case '\r':
                case ' ':
                case '-':
                case '/':
                	{
                		alt27=1;
                	}
                    break;
            }

            switch (alt27)
            {
        	case 1:
        	    // OracleDMLLexer.g:868:15: SEPARATOR
        	    {
        	        /* 868:15: SEPARATOR */
        	        mSEPARATOR();
        	        if  (this->hasException())
        	        {
        	            goto ruleINTRODUCEREx;
        	        }



        	        {
        	            _type = UNDERSCORE;
        	        }


        	    }
        	    break;

            }
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleINTRODUCEREx; /* Prevent compiler warnings */
    ruleINTRODUCEREx: ;

}
// $ANTLR end INTRODUCER

//   Comes from: 874:5: ( '-' | COMMENT | ( SPACE | NEWLINE )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEPARATOR
 *
 * Looks to match the characters the constitute the token SEPARATOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSEPARATOR()
{
    ANTLR_UINT32	_type;
      

    _type	    = SEPARATOR;


    {
        //  OracleDMLLexer.g:874:5: ( '-' | COMMENT | ( SPACE | NEWLINE )+ )

        ANTLR_UINT32 alt29;

        alt29=3;

        switch ( this->LA(1) )
        {
        case '-':
        	{
        		switch ( this->LA(2) )
        		{
        		case '-':
        			{
        				alt29=2;
        			}
        		    break;

        		default:
        		    alt29=1;
        		}

        	}
            break;
        case '/':
        	{
        		alt29=2;
        	}
            break;
        case '\t':
        case '\n':
        case '\r':
        case ' ':
        	{
        		alt29=3;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 29 );
            ex->set_state( 0 );


            goto ruleSEPARATOREx;

        }

        switch (alt29)
        {
    	case 1:
    	    // OracleDMLLexer.g:874:10: '-'
    	    {
    	         this->matchc('-');
    	        if  (this->hasException())
    	        {
    	            goto ruleSEPARATOREx;
    	        }


    	        {
    	            _type = MINUS_SIGN;
    	        }


    	    }
    	    break;
    	case 2:
    	    // OracleDMLLexer.g:875:10: COMMENT
    	    {
    	        /* 875:10: COMMENT */
    	        mCOMMENT();
    	        if  (this->hasException())
    	        {
    	            goto ruleSEPARATOREx;
    	        }



    	        {
    	             this->get_state()->get_channel()=HIDDEN; 
    	        }


    	    }
    	    break;
    	case 3:
    	    // OracleDMLLexer.g:876:10: ( SPACE | NEWLINE )+
    	    {
    	        // OracleDMLLexer.g:876:10: ( SPACE | NEWLINE )+
    	        {
    	            int cnt28=0;

    	            for (;;)
    	            {
    	                ANTLR_UINT32 alt28=3;
    	        	switch ( this->LA(1) )
    	        	{
    	        	case '\t':
    	        	case ' ':
    	        		{
    	        			alt28=1;
    	        		}
    	        	    break;
    	        	case '\n':
    	        	case '\r':
    	        		{
    	        			alt28=2;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt28)
    	        	{
    	        	    case 1:
    	        	        // OracleDMLLexer.g:876:11: SPACE
    	        	        {
    	        	            /* 876:11: SPACE */
    	        	            mSPACE();
    	        	            if  (this->hasException())
    	        	            {
    	        	                goto ruleSEPARATOREx;
    	        	            }



    	        	        }
    	        	        break;
    	        	    case 2:
    	        	        // OracleDMLLexer.g:876:19: NEWLINE
    	        	        {
    	        	            /* 876:19: NEWLINE */
    	        	            mNEWLINE();
    	        	            if  (this->hasException())
    	        	            {
    	        	                goto ruleSEPARATOREx;
    	        	            }



    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt28 >= 1 )
    	        		{
    	        		    goto loop28;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		new ANTLR_Exception< OracleDMLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


    	        		goto ruleSEPARATOREx;
    	        	}
    	        	cnt28++;
    	            }
    	            loop28: ;	/* Jump to here if this rule does not match */
    	        }

    	        {
    	             this->get_state()->get_channel()=HIDDEN; 
    	        }


    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSEPARATOREx; /* Prevent compiler warnings */
    ruleSEPARATOREx: ;

}
// $ANTLR end SEPARATOR

//   Comes from: 884:5: ( 'a' .. 'z' | 'A' .. 'Z' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SIMPLE_LETTER
 *
 * Looks to match the characters the constitute the token SIMPLE_LETTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSIMPLE_LETTER()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:884:5: ( 'a' .. 'z' | 'A' .. 'Z' )
    // OracleDMLLexer.g:
    {
        if ( ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleSIMPLE_LETTEREx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleSIMPLE_LETTEREx; /* Prevent compiler warnings */
    ruleSIMPLE_LETTEREx: ;

}
// $ANTLR end SIMPLE_LETTER

//   Comes from: 893:5: ( ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNSIGNED_INTEGER
 *
 * Looks to match the characters the constitute the token UNSIGNED_INTEGER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mUNSIGNED_INTEGER()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:893:5: ( ( '0' .. '9' )+ )
    // OracleDMLLexer.g:893:10: ( '0' .. '9' )+
    {
        // OracleDMLLexer.g:893:10: ( '0' .. '9' )+
        {
            int cnt30=0;

            for (;;)
            {
                ANTLR_UINT32 alt30=2;
        	switch ( this->LA(1) )
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt30=1;
        		}
        	    break;

        	}

        	switch (alt30)
        	{
        	    case 1:
        	        // OracleDMLLexer.g:
        	        {
        	            if ( ((this->LA(1) >= '0') && (this->LA(1) <= '9')) )
        	            {
        	                this->consume();
        	            }
        	            else
        	            {
        	                new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	                this->recover();
        	                goto ruleUNSIGNED_INTEGEREx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt30 >= 1 )
        		{
        		    goto loop30;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< OracleDMLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleUNSIGNED_INTEGEREx;
        	}
        	cnt30++;
            }
            loop30: ;	/* Jump to here if this rule does not match */
        }

    }


    // This is where rules clean up and exit
    //
    goto ruleUNSIGNED_INTEGEREx; /* Prevent compiler warnings */
    ruleUNSIGNED_INTEGEREx: ;

}
// $ANTLR end UNSIGNED_INTEGER

//   Comes from: 900:5: ( '--' (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) | '/*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mCOMMENT()
{
    ANTLR_UINT32	_type;
      


    {
        //  OracleDMLLexer.g:900:5: ( '--' (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) | '/*' ( options {greedy=false; } : . )* '*/' )

        ANTLR_UINT32 alt34;

        alt34=2;

        switch ( this->LA(1) )
        {
        case '-':
        	{
        		alt34=1;
        	}
            break;
        case '/':
        	{
        		alt34=2;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 34 );
            ex->set_state( 0 );


            goto ruleCOMMENTEx;

        }

        switch (alt34)
        {
    	case 1:
    	    // OracleDMLLexer.g:900:10: '--' (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF )
    	    {
    	        this->matchs(lit_11);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        // OracleDMLLexer.g:900:15: (~ ( '\\r' | '\\n' ) )*

    	        for (;;)
    	        {
    	            ANTLR_UINT32 alt31=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                ANTLR_UINT32 LA31_0 = this->LA(1);
    	                if ( (((LA31_0 >= 0x0000) && (LA31_0 <= '\t')) || ((LA31_0 >= 0x000B) && (LA31_0 <= '\f')) || ((LA31_0 >= 0x000E) && (LA31_0 <= 0xFFFF))))
    	                {
    	                    alt31=1;
    	                }

    	            }
    	            switch (alt31)
    	            {
    	        	case 1:
    	        	    // OracleDMLLexer.g:
    	        	    {
    	        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= 0xFFFF)) )
    	        	        {
    	        	            this->consume();
    	        	        }
    	        	        else
    	        	        {
    	        	            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

    	        	            this->recover();
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop31;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop31: ; /* Jump out to here if this rule does not match */


    	        // OracleDMLLexer.g:900:35: ( NEWLINE | EOF )
    	        {
    	            ANTLR_UINT32 alt32=2;
    	            switch ( this->LA(1) )
    	            {
    	            case '\n':
    	            case '\r':
    	            	{
    	            		alt32=1;
    	            	}
    	                break;

    	            default:
    	                alt32=2;
    	            }

    	            switch (alt32)
    	            {
    	        	case 1:
    	        	    // OracleDMLLexer.g:900:36: NEWLINE
    	        	    {
    	        	        /* 900:36: NEWLINE */
    	        	        mNEWLINE();
    	        	        if  (this->hasException())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }



    	        	    }
    	        	    break;
    	        	case 2:
    	        	    // OracleDMLLexer.g:900:44: EOF
    	        	    {
    	        	            this->matchc(ANTLR_CHARSTREAM_EOF);
    	        	            if  (this->hasException())
    	        	            {
    	        	                goto ruleCOMMENTEx;
    	        	            }



    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // OracleDMLLexer.g:901:10: '/*' ( options {greedy=false; } : . )* '*/'
    	    {
    	        this->matchs(lit_12);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        // OracleDMLLexer.g:901:15: ( options {greedy=false; } : . )*

    	        for (;;)
    	        {
    	            ANTLR_UINT32 alt33=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                ANTLR_UINT32 LA33_0 = this->LA(1);
    	                if ( (LA33_0 == '*'))
    	                {
    	                    {
    	                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                        */
    	                        ANTLR_UINT32 LA33_1 = this->LA(2);
    	                        if ( (LA33_1 == '/'))
    	                        {
    	                            alt33=2;
    	                        }
    	                        else if ( (((LA33_1 >= 0x0000) && (LA33_1 <= '.')) || ((LA33_1 >= '0') && (LA33_1 <= 0xFFFF))))
    	                        {
    	                            alt33=1;
    	                        }

    	                    }
    	                }
    	                else if ( (((LA33_0 >= 0x0000) && (LA33_0 <= ')')) || ((LA33_0 >= '+') && (LA33_0 <= 0xFFFF))))
    	                {
    	                    alt33=1;
    	                }

    	            }
    	            switch (alt33)
    	            {
    	        	case 1:
    	        	    // OracleDMLLexer.g:901:41: .
    	        	    {
    	        	        this->matchAny();
    	        	        if  (this->hasException())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop33;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop33: ; /* Jump out to here if this rule does not match */


    	        this->matchs(lit_13);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	    }
    	    break;

        }
    }

    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 908:2: ( 'PROMPT' SPACE (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PROMPT
 *
 * Looks to match the characters the constitute the token PROMPT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPROMPT()
{
    ANTLR_UINT32	_type;
      

    _type	    = PROMPT;


    // OracleDMLLexer.g:908:2: ( 'PROMPT' SPACE (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) )
    // OracleDMLLexer.g:908:4: 'PROMPT' SPACE (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF )
    {
        this->matchs(lit_14);
        if  (this->hasException())
        {
            goto rulePROMPTEx;
        }




        /* 908:4: 'PROMPT' SPACE (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) */
        mSPACE();
        if  (this->hasException())
        {
            goto rulePROMPTEx;
        }



        // OracleDMLLexer.g:908:19: (~ ( '\\r' | '\\n' ) )*

        for (;;)
        {
            ANTLR_UINT32 alt35=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                ANTLR_UINT32 LA35_0 = this->LA(1);
                if ( (((LA35_0 >= 0x0000) && (LA35_0 <= '\t')) || ((LA35_0 >= 0x000B) && (LA35_0 <= '\f')) || ((LA35_0 >= 0x000E) && (LA35_0 <= 0xFFFF))))
                {
                    alt35=1;
                }

            }
            switch (alt35)
            {
        	case 1:
        	    // OracleDMLLexer.g:
        	    {
        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= 0xFFFF)) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto rulePROMPTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop35;	/* break out of the loop */
        	    break;
            }
        }
        loop35: ; /* Jump out to here if this rule does not match */


        // OracleDMLLexer.g:908:39: ( NEWLINE | EOF )
        {
            ANTLR_UINT32 alt36=2;
            switch ( this->LA(1) )
            {
            case '\n':
            case '\r':
            	{
            		alt36=1;
            	}
                break;

            default:
                alt36=2;
            }

            switch (alt36)
            {
        	case 1:
        	    // OracleDMLLexer.g:908:40: NEWLINE
        	    {
        	        /* 908:40: NEWLINE */
        	        mNEWLINE();
        	        if  (this->hasException())
        	        {
        	            goto rulePROMPTEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // OracleDMLLexer.g:908:48: EOF
        	    {
        	            this->matchc(ANTLR_CHARSTREAM_EOF);
        	            if  (this->hasException())
        	            {
        	                goto rulePROMPTEx;
        	            }



        	    }
        	    break;

            }
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePROMPTEx; /* Prevent compiler warnings */
    rulePROMPTEx: ;

}
// $ANTLR end PROMPT

//   Comes from: 917:5: ( '\\r' ( options {greedy=true; } : '\\n' )? | '\\n' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NEWLINE
 *
 * Looks to match the characters the constitute the token NEWLINE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mNEWLINE()
{
    ANTLR_UINT32	_type;
      


    {
        //  OracleDMLLexer.g:917:5: ( '\\r' ( options {greedy=true; } : '\\n' )? | '\\n' )

        ANTLR_UINT32 alt38;

        alt38=2;

        switch ( this->LA(1) )
        {
        case '\r':
        	{
        		alt38=1;
        	}
            break;
        case '\n':
        	{
        		alt38=2;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 38 );
            ex->set_state( 0 );


            goto ruleNEWLINEEx;

        }

        switch (alt38)
        {
    	case 1:
    	    // OracleDMLLexer.g:917:10: '\\r' ( options {greedy=true; } : '\\n' )?
    	    {
    	         this->matchc('\r');
    	        if  (this->hasException())
    	        {
    	            goto ruleNEWLINEEx;
    	        }


    	        // OracleDMLLexer.g:917:15: ( options {greedy=true; } : '\\n' )?
    	        {
    	            ANTLR_UINT32 alt37=2;
    	            switch ( this->LA(1) )
    	            {
    	                case '\n':
    	                	{
    	                		alt37=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt37)
    	            {
    	        	case 1:
    	        	    // OracleDMLLexer.g:917:39: '\\n'
    	        	    {
    	        	         this->matchc('\n');
    	        	        if  (this->hasException())
    	        	        {
    	        	            goto ruleNEWLINEEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // OracleDMLLexer.g:918:10: '\\n'
    	    {
    	         this->matchc('\n');
    	        if  (this->hasException())
    	        {
    	            goto ruleNEWLINEEx;
    	        }


    	    }
    	    break;

        }
    }

    // This is where rules clean up and exit
    //
    goto ruleNEWLINEEx; /* Prevent compiler warnings */
    ruleNEWLINEEx: ;

}
// $ANTLR end NEWLINE

//   Comes from: 924:10: ( ' ' | '\\t' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SPACE
 *
 * Looks to match the characters the constitute the token SPACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSPACE()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:924:10: ( ' ' | '\\t' )
    // OracleDMLLexer.g:
    {
        if ( this->LA(1) == '\t' || this->LA(1) == ' ' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleSPACEEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleSPACEEx; /* Prevent compiler warnings */
    ruleSPACEEx: ;

}
// $ANTLR end SPACE

//   Comes from: 929:29: ()
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start APPROXIMATE_NUM_LIT
 *
 * Looks to match the characters the constitute the token APPROXIMATE_NUM_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mAPPROXIMATE_NUM_LIT()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:929:29: ()
    // OracleDMLLexer.g:929:31: 
    {
    }


    // This is where rules clean up and exit
    //
    goto ruleAPPROXIMATE_NUM_LITEx; /* Prevent compiler warnings */
    ruleAPPROXIMATE_NUM_LITEx: ;

}
// $ANTLR end APPROXIMATE_NUM_LIT

//   Comes from: 930:20: ()
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MINUS_SIGN
 *
 * Looks to match the characters the constitute the token MINUS_SIGN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mMINUS_SIGN()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:930:20: ()
    // OracleDMLLexer.g:930:22: 
    {
    }


    // This is where rules clean up and exit
    //
    goto ruleMINUS_SIGNEx; /* Prevent compiler warnings */
    ruleMINUS_SIGNEx: ;

}
// $ANTLR end MINUS_SIGN

//   Comes from: 931:20: ()
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNDERSCORE
 *
 * Looks to match the characters the constitute the token UNDERSCORE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mUNDERSCORE()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:931:20: ()
    // OracleDMLLexer.g:931:22: 
    {
    }


    // This is where rules clean up and exit
    //
    goto ruleUNDERSCOREEx; /* Prevent compiler warnings */
    ruleUNDERSCOREEx: ;

}
// $ANTLR end UNDERSCORE

//   Comes from: 932:23: ()
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_PERIOD
 *
 * Looks to match the characters the constitute the token DOUBLE_PERIOD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mDOUBLE_PERIOD()
{
    ANTLR_UINT32	_type;
      


    // OracleDMLLexer.g:932:23: ()
    // OracleDMLLexer.g:932:25: 
    {
    }


    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_PERIODEx; /* Prevent compiler warnings */
    ruleDOUBLE_PERIODEx: ;

}
// $ANTLR end DOUBLE_PERIOD

//   Comes from: 938:5: ( 'ALL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ALL
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ALL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_ALL()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ALL;


    // OracleDMLLexer.g:938:5: ( 'ALL' )
    // OracleDMLLexer.g:938:10: 'ALL'
    {
        this->matchs(lit_15);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ALLEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ALLEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ALLEx: ;

}
// $ANTLR end SQL92_RESERVED_ALL

//   Comes from: 942:5: ( 'ALTER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ALTER
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ALTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_ALTER()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ALTER;


    // OracleDMLLexer.g:942:5: ( 'ALTER' )
    // OracleDMLLexer.g:942:10: 'ALTER'
    {
        this->matchs(lit_16);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ALTEREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ALTEREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ALTEREx: ;

}
// $ANTLR end SQL92_RESERVED_ALTER

//   Comes from: 946:5: ( 'AND' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_AND
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_AND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_AND()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_AND;


    // OracleDMLLexer.g:946:5: ( 'AND' )
    // OracleDMLLexer.g:946:10: 'AND'
    {
        this->matchs(lit_17);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ANDEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ANDEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ANDEx: ;

}
// $ANTLR end SQL92_RESERVED_AND

//   Comes from: 950:5: ( 'ANY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ANY
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ANY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_ANY()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ANY;


    // OracleDMLLexer.g:950:5: ( 'ANY' )
    // OracleDMLLexer.g:950:10: 'ANY'
    {
        this->matchs(lit_18);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ANYEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ANYEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ANYEx: ;

}
// $ANTLR end SQL92_RESERVED_ANY

//   Comes from: 954:5: ( 'AS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_AS
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_AS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_AS()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_AS;


    // OracleDMLLexer.g:954:5: ( 'AS' )
    // OracleDMLLexer.g:954:10: 'AS'
    {
        this->matchs(lit_19);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ASEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ASEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ASEx: ;

}
// $ANTLR end SQL92_RESERVED_AS

//   Comes from: 958:5: ( 'ASC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ASC
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ASC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_ASC()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ASC;


    // OracleDMLLexer.g:958:5: ( 'ASC' )
    // OracleDMLLexer.g:958:10: 'ASC'
    {
        this->matchs(lit_20);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ASCEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ASCEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ASCEx: ;

}
// $ANTLR end SQL92_RESERVED_ASC

//   Comes from: 966:5: ( 'BEGIN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_BEGIN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_BEGIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_BEGIN()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_BEGIN;


    // OracleDMLLexer.g:966:5: ( 'BEGIN' )
    // OracleDMLLexer.g:966:10: 'BEGIN'
    {
        this->matchs(lit_21);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_BEGINEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_BEGINEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_BEGINEx: ;

}
// $ANTLR end SQL92_RESERVED_BEGIN

//   Comes from: 970:5: ( 'BETWEEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_BETWEEN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_BETWEEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_BETWEEN()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_BETWEEN;


    // OracleDMLLexer.g:970:5: ( 'BETWEEN' )
    // OracleDMLLexer.g:970:10: 'BETWEEN'
    {
        this->matchs(lit_22);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_BETWEENEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_BETWEENEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_BETWEENEx: ;

}
// $ANTLR end SQL92_RESERVED_BETWEEN

//   Comes from: 974:5: ( 'BY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_BY
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_BY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_BY()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_BY;


    // OracleDMLLexer.g:974:5: ( 'BY' )
    // OracleDMLLexer.g:974:10: 'BY'
    {
        this->matchs(lit_23);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_BYEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_BYEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_BYEx: ;

}
// $ANTLR end SQL92_RESERVED_BY

//   Comes from: 978:5: ( 'CASE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CASE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CASE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_CASE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_CASE;


    // OracleDMLLexer.g:978:5: ( 'CASE' )
    // OracleDMLLexer.g:978:10: 'CASE'
    {
        this->matchs(lit_24);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CASEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CASEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CASEEx: ;

}
// $ANTLR end SQL92_RESERVED_CASE

//   Comes from: 982:5: ( 'CHECK' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CHECK
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CHECK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_CHECK()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_CHECK;


    // OracleDMLLexer.g:982:5: ( 'CHECK' )
    // OracleDMLLexer.g:982:10: 'CHECK'
    {
        this->matchs(lit_25);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CHECKEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CHECKEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CHECKEx: ;

}
// $ANTLR end SQL92_RESERVED_CHECK

//   Comes from: 986:5: ( 'CLUSTERS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_CLUSTERS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_CLUSTERS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_CLUSTERS()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_CLUSTERS;


    // OracleDMLLexer.g:986:5: ( 'CLUSTERS' )
    // OracleDMLLexer.g:986:10: 'CLUSTERS'
    {
        this->matchs(lit_26);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_CLUSTERSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_CLUSTERSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_CLUSTERSEx: ;

}
// $ANTLR end PLSQL_RESERVED_CLUSTERS

//   Comes from: 990:5: ( 'COLAUTH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_COLAUTH
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_COLAUTH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_COLAUTH()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_COLAUTH;


    // OracleDMLLexer.g:990:5: ( 'COLAUTH' )
    // OracleDMLLexer.g:990:10: 'COLAUTH'
    {
        this->matchs(lit_27);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_COLAUTHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_COLAUTHEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_COLAUTHEx: ;

}
// $ANTLR end PLSQL_RESERVED_COLAUTH

//   Comes from: 994:5: ( 'COMPRESS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_COMPRESS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_COMPRESS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_COMPRESS()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_COMPRESS;


    // OracleDMLLexer.g:994:5: ( 'COMPRESS' )
    // OracleDMLLexer.g:994:10: 'COMPRESS'
    {
        this->matchs(lit_28);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_COMPRESSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_COMPRESSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_COMPRESSEx: ;

}
// $ANTLR end PLSQL_RESERVED_COMPRESS

//   Comes from: 998:5: ( 'CONNECT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CONNECT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CONNECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_CONNECT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_CONNECT;


    // OracleDMLLexer.g:998:5: ( 'CONNECT' )
    // OracleDMLLexer.g:998:10: 'CONNECT'
    {
        this->matchs(lit_29);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CONNECTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CONNECTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CONNECTEx: ;

}
// $ANTLR end SQL92_RESERVED_CONNECT

//   Comes from: 1006:5: ( 'CONNECT_BY_ROOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_CONNECT_BY_ROOT
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_CONNECT_BY_ROOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_NON_RESERVED_CONNECT_BY_ROOT()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_CONNECT_BY_ROOT;


    // OracleDMLLexer.g:1006:5: ( 'CONNECT_BY_ROOT' )
    // OracleDMLLexer.g:1006:10: 'CONNECT_BY_ROOT'
    {
        this->matchs(lit_30);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_CONNECT_BY_ROOTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_CONNECT_BY_ROOTEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_CONNECT_BY_ROOTEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_CONNECT_BY_ROOT

//   Comes from: 1010:5: ( 'CRASH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_CRASH
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_CRASH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_CRASH()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_CRASH;


    // OracleDMLLexer.g:1010:5: ( 'CRASH' )
    // OracleDMLLexer.g:1010:10: 'CRASH'
    {
        this->matchs(lit_31);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_CRASHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_CRASHEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_CRASHEx: ;

}
// $ANTLR end PLSQL_RESERVED_CRASH

//   Comes from: 1014:5: ( 'CREATE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CREATE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CREATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_CREATE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_CREATE;


    // OracleDMLLexer.g:1014:5: ( 'CREATE' )
    // OracleDMLLexer.g:1014:10: 'CREATE'
    {
        this->matchs(lit_32);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CREATEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CREATEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CREATEEx: ;

}
// $ANTLR end SQL92_RESERVED_CREATE

//   Comes from: 1018:5: ( 'CURRENT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CURRENT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CURRENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_CURRENT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_CURRENT;


    // OracleDMLLexer.g:1018:5: ( 'CURRENT' )
    // OracleDMLLexer.g:1018:10: 'CURRENT'
    {
        this->matchs(lit_33);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CURRENTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CURRENTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CURRENTEx: ;

}
// $ANTLR end SQL92_RESERVED_CURRENT

//   Comes from: 1022:5: ( 'CURSOR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CURSOR
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CURSOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_CURSOR()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_CURSOR;


    // OracleDMLLexer.g:1022:5: ( 'CURSOR' )
    // OracleDMLLexer.g:1022:10: 'CURSOR'
    {
        this->matchs(lit_34);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CURSOREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CURSOREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CURSOREx: ;

}
// $ANTLR end SQL92_RESERVED_CURSOR

//   Comes from: 1026:5: ( 'DATE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DATE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_DATE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DATE;


    // OracleDMLLexer.g:1026:5: ( 'DATE' )
    // OracleDMLLexer.g:1026:10: 'DATE'
    {
        this->matchs(lit_35);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DATEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DATEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DATEEx: ;

}
// $ANTLR end SQL92_RESERVED_DATE

//   Comes from: 1030:5: ( 'DECLARE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DECLARE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DECLARE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_DECLARE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DECLARE;


    // OracleDMLLexer.g:1030:5: ( 'DECLARE' )
    // OracleDMLLexer.g:1030:10: 'DECLARE'
    {
        this->matchs(lit_36);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DECLAREEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DECLAREEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DECLAREEx: ;

}
// $ANTLR end SQL92_RESERVED_DECLARE

//   Comes from: 1034:5: ( 'DEFAULT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DEFAULT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DEFAULT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_DEFAULT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DEFAULT;


    // OracleDMLLexer.g:1034:5: ( 'DEFAULT' )
    // OracleDMLLexer.g:1034:10: 'DEFAULT'
    {
        this->matchs(lit_37);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DEFAULTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DEFAULTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DEFAULTEx: ;

}
// $ANTLR end SQL92_RESERVED_DEFAULT

//   Comes from: 1038:5: ( 'DELETE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DELETE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DELETE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_DELETE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DELETE;


    // OracleDMLLexer.g:1038:5: ( 'DELETE' )
    // OracleDMLLexer.g:1038:10: 'DELETE'
    {
        this->matchs(lit_38);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DELETEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DELETEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DELETEEx: ;

}
// $ANTLR end SQL92_RESERVED_DELETE

//   Comes from: 1042:5: ( 'DESC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DESC
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_DESC()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DESC;


    // OracleDMLLexer.g:1042:5: ( 'DESC' )
    // OracleDMLLexer.g:1042:10: 'DESC'
    {
        this->matchs(lit_39);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DESCEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DESCEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DESCEx: ;

}
// $ANTLR end SQL92_RESERVED_DESC

//   Comes from: 1046:5: ( 'DISTINCT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DISTINCT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DISTINCT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_DISTINCT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DISTINCT;


    // OracleDMLLexer.g:1046:5: ( 'DISTINCT' )
    // OracleDMLLexer.g:1046:10: 'DISTINCT'
    {
        this->matchs(lit_40);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DISTINCTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DISTINCTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DISTINCTEx: ;

}
// $ANTLR end SQL92_RESERVED_DISTINCT

//   Comes from: 1050:5: ( 'DROP' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DROP
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DROP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_DROP()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DROP;


    // OracleDMLLexer.g:1050:5: ( 'DROP' )
    // OracleDMLLexer.g:1050:10: 'DROP'
    {
        this->matchs(lit_41);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DROPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DROPEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DROPEx: ;

}
// $ANTLR end SQL92_RESERVED_DROP

//   Comes from: 1054:5: ( 'ELSE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ELSE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ELSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_ELSE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ELSE;


    // OracleDMLLexer.g:1054:5: ( 'ELSE' )
    // OracleDMLLexer.g:1054:10: 'ELSE'
    {
        this->matchs(lit_42);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ELSEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ELSEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ELSEEx: ;

}
// $ANTLR end SQL92_RESERVED_ELSE

//   Comes from: 1058:5: ( 'END' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_END
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_END()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_END;


    // OracleDMLLexer.g:1058:5: ( 'END' )
    // OracleDMLLexer.g:1058:10: 'END'
    {
        this->matchs(lit_43);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ENDEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ENDEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ENDEx: ;

}
// $ANTLR end SQL92_RESERVED_END

//   Comes from: 1065:5: ( 'EXCEPTION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_EXCEPTION
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_EXCEPTION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_EXCEPTION()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_EXCEPTION;


    // OracleDMLLexer.g:1065:5: ( 'EXCEPTION' )
    // OracleDMLLexer.g:1065:10: 'EXCEPTION'
    {
        this->matchs(lit_44);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_EXCEPTIONEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_EXCEPTIONEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_EXCEPTIONEx: ;

}
// $ANTLR end SQL92_RESERVED_EXCEPTION

//   Comes from: 1121:5: ( 'EXCLUSIVE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_EXCLUSIVE
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_EXCLUSIVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_EXCLUSIVE()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_EXCLUSIVE;


    // OracleDMLLexer.g:1121:5: ( 'EXCLUSIVE' )
    // OracleDMLLexer.g:1121:10: 'EXCLUSIVE'
    {
        this->matchs(lit_45);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_EXCLUSIVEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_EXCLUSIVEEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_EXCLUSIVEEx: ;

}
// $ANTLR end PLSQL_RESERVED_EXCLUSIVE

//   Comes from: 1125:5: ( 'EXISTS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_EXISTS
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_EXISTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_EXISTS()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_EXISTS;


    // OracleDMLLexer.g:1125:5: ( 'EXISTS' )
    // OracleDMLLexer.g:1125:10: 'EXISTS'
    {
        this->matchs(lit_46);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_EXISTSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_EXISTSEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_EXISTSEx: ;

}
// $ANTLR end SQL92_RESERVED_EXISTS

//   Comes from: 1129:5: ( 'FALSE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_FALSE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_FALSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_FALSE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_FALSE;


    // OracleDMLLexer.g:1129:5: ( 'FALSE' )
    // OracleDMLLexer.g:1129:10: 'FALSE'
    {
        this->matchs(lit_47);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_FALSEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_FALSEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_FALSEEx: ;

}
// $ANTLR end SQL92_RESERVED_FALSE

//   Comes from: 1133:5: ( 'FETCH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_FETCH
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_FETCH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_FETCH()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_FETCH;


    // OracleDMLLexer.g:1133:5: ( 'FETCH' )
    // OracleDMLLexer.g:1133:10: 'FETCH'
    {
        this->matchs(lit_48);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_FETCHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_FETCHEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_FETCHEx: ;

}
// $ANTLR end SQL92_RESERVED_FETCH

//   Comes from: 1137:5: ( 'FOR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_FOR
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_FOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_FOR()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_FOR;


    // OracleDMLLexer.g:1137:5: ( 'FOR' )
    // OracleDMLLexer.g:1137:10: 'FOR'
    {
        this->matchs(lit_49);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_FOREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_FOREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_FOREx: ;

}
// $ANTLR end SQL92_RESERVED_FOR

//   Comes from: 1141:5: ( 'FROM' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_FROM
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_FROM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_FROM()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_FROM;


    // OracleDMLLexer.g:1141:5: ( 'FROM' )
    // OracleDMLLexer.g:1141:10: 'FROM'
    {
        this->matchs(lit_50);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_FROMEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_FROMEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_FROMEx: ;

}
// $ANTLR end SQL92_RESERVED_FROM

//   Comes from: 1145:5: ( 'GOTO' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_GOTO
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_GOTO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_GOTO()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_GOTO;


    // OracleDMLLexer.g:1145:5: ( 'GOTO' )
    // OracleDMLLexer.g:1145:10: 'GOTO'
    {
        this->matchs(lit_51);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_GOTOEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_GOTOEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_GOTOEx: ;

}
// $ANTLR end SQL92_RESERVED_GOTO

//   Comes from: 1149:5: ( 'GRANT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_GRANT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_GRANT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_GRANT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_GRANT;


    // OracleDMLLexer.g:1149:5: ( 'GRANT' )
    // OracleDMLLexer.g:1149:10: 'GRANT'
    {
        this->matchs(lit_52);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_GRANTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_GRANTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_GRANTEx: ;

}
// $ANTLR end SQL92_RESERVED_GRANT

//   Comes from: 1153:5: ( 'GROUP' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_GROUP
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_GROUP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_GROUP()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_GROUP;


    // OracleDMLLexer.g:1153:5: ( 'GROUP' )
    // OracleDMLLexer.g:1153:10: 'GROUP'
    {
        this->matchs(lit_53);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_GROUPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_GROUPEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_GROUPEx: ;

}
// $ANTLR end SQL92_RESERVED_GROUP

//   Comes from: 1157:5: ( 'HAVING' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_HAVING
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_HAVING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_HAVING()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_HAVING;


    // OracleDMLLexer.g:1157:5: ( 'HAVING' )
    // OracleDMLLexer.g:1157:10: 'HAVING'
    {
        this->matchs(lit_54);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_HAVINGEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_HAVINGEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_HAVINGEx: ;

}
// $ANTLR end SQL92_RESERVED_HAVING

//   Comes from: 1161:5: ( 'IDENTIFIED' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_IDENTIFIED
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_IDENTIFIED
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_IDENTIFIED()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_IDENTIFIED;


    // OracleDMLLexer.g:1161:5: ( 'IDENTIFIED' )
    // OracleDMLLexer.g:1161:10: 'IDENTIFIED'
    {
        this->matchs(lit_55);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_IDENTIFIEDEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_IDENTIFIEDEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_IDENTIFIEDEx: ;

}
// $ANTLR end PLSQL_RESERVED_IDENTIFIED

//   Comes from: 1165:5: ( 'IF' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_IF
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_IF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_IF()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_IF;


    // OracleDMLLexer.g:1165:5: ( 'IF' )
    // OracleDMLLexer.g:1165:10: 'IF'
    {
        this->matchs(lit_56);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_IFEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_IFEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_IFEx: ;

}
// $ANTLR end PLSQL_RESERVED_IF

//   Comes from: 1169:5: ( 'IN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_IN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_IN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_IN()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_IN;


    // OracleDMLLexer.g:1169:5: ( 'IN' )
    // OracleDMLLexer.g:1169:10: 'IN'
    {
        this->matchs(lit_57);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_INEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_INEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_INEx: ;

}
// $ANTLR end SQL92_RESERVED_IN

//   Comes from: 1173:5: ( 'INDEX' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_INDEX
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_INDEX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_INDEX()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_INDEX;


    // OracleDMLLexer.g:1173:5: ( 'INDEX' )
    // OracleDMLLexer.g:1173:10: 'INDEX'
    {
        this->matchs(lit_58);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_INDEXEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_INDEXEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_INDEXEx: ;

}
// $ANTLR end PLSQL_RESERVED_INDEX

//   Comes from: 1177:5: ( 'INDEXES' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_INDEXES
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_INDEXES
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_INDEXES()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_INDEXES;


    // OracleDMLLexer.g:1177:5: ( 'INDEXES' )
    // OracleDMLLexer.g:1177:10: 'INDEXES'
    {
        this->matchs(lit_59);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_INDEXESEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_INDEXESEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_INDEXESEx: ;

}
// $ANTLR end PLSQL_RESERVED_INDEXES

//   Comes from: 1181:5: ( 'INSERT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_INSERT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_INSERT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_INSERT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_INSERT;


    // OracleDMLLexer.g:1181:5: ( 'INSERT' )
    // OracleDMLLexer.g:1181:10: 'INSERT'
    {
        this->matchs(lit_60);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_INSERTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_INSERTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_INSERTEx: ;

}
// $ANTLR end SQL92_RESERVED_INSERT

//   Comes from: 1185:5: ( 'INTERSECT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_INTERSECT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_INTERSECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_INTERSECT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_INTERSECT;


    // OracleDMLLexer.g:1185:5: ( 'INTERSECT' )
    // OracleDMLLexer.g:1185:10: 'INTERSECT'
    {
        this->matchs(lit_61);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_INTERSECTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_INTERSECTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_INTERSECTEx: ;

}
// $ANTLR end SQL92_RESERVED_INTERSECT

//   Comes from: 1189:5: ( 'INTO' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_INTO
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_INTO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_INTO()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_INTO;


    // OracleDMLLexer.g:1189:5: ( 'INTO' )
    // OracleDMLLexer.g:1189:10: 'INTO'
    {
        this->matchs(lit_62);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_INTOEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_INTOEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_INTOEx: ;

}
// $ANTLR end SQL92_RESERVED_INTO

//   Comes from: 1193:5: ( 'IS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_IS
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_IS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_IS()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_IS;


    // OracleDMLLexer.g:1193:5: ( 'IS' )
    // OracleDMLLexer.g:1193:10: 'IS'
    {
        this->matchs(lit_63);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ISEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ISEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ISEx: ;

}
// $ANTLR end SQL92_RESERVED_IS

//   Comes from: 1197:5: ( 'LIKE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_LIKE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_LIKE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_LIKE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_LIKE;


    // OracleDMLLexer.g:1197:5: ( 'LIKE' )
    // OracleDMLLexer.g:1197:10: 'LIKE'
    {
        this->matchs(lit_64);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_LIKEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_LIKEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_LIKEEx: ;

}
// $ANTLR end SQL92_RESERVED_LIKE

//   Comes from: 1201:5: ( 'LOCK' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_LOCK
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_LOCK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_LOCK()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_LOCK;


    // OracleDMLLexer.g:1201:5: ( 'LOCK' )
    // OracleDMLLexer.g:1201:10: 'LOCK'
    {
        this->matchs(lit_65);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_LOCKEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_LOCKEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_LOCKEx: ;

}
// $ANTLR end PLSQL_RESERVED_LOCK

//   Comes from: 1205:5: ( 'MINUS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_MINUS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_MINUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_MINUS()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_MINUS;


    // OracleDMLLexer.g:1205:5: ( 'MINUS' )
    // OracleDMLLexer.g:1205:10: 'MINUS'
    {
        this->matchs(lit_66);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_MINUSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_MINUSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_MINUSEx: ;

}
// $ANTLR end PLSQL_RESERVED_MINUS

//   Comes from: 1209:5: ( 'MODE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_MODE
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_MODE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_MODE()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_MODE;


    // OracleDMLLexer.g:1209:5: ( 'MODE' )
    // OracleDMLLexer.g:1209:10: 'MODE'
    {
        this->matchs(lit_67);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_MODEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_MODEEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_MODEEx: ;

}
// $ANTLR end PLSQL_RESERVED_MODE

//   Comes from: 1213:5: ( 'NOCOMPRESS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_NOCOMPRESS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_NOCOMPRESS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_NOCOMPRESS()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_NOCOMPRESS;


    // OracleDMLLexer.g:1213:5: ( 'NOCOMPRESS' )
    // OracleDMLLexer.g:1213:10: 'NOCOMPRESS'
    {
        this->matchs(lit_68);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_NOCOMPRESSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_NOCOMPRESSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_NOCOMPRESSEx: ;

}
// $ANTLR end PLSQL_RESERVED_NOCOMPRESS

//   Comes from: 1217:5: ( 'NOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_NOT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_NOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_NOT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_NOT;


    // OracleDMLLexer.g:1217:5: ( 'NOT' )
    // OracleDMLLexer.g:1217:10: 'NOT'
    {
        this->matchs(lit_69);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_NOTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_NOTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_NOTEx: ;

}
// $ANTLR end SQL92_RESERVED_NOT

//   Comes from: 1221:5: ( 'NOWAIT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_NOWAIT
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_NOWAIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_NOWAIT()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_NOWAIT;


    // OracleDMLLexer.g:1221:5: ( 'NOWAIT' )
    // OracleDMLLexer.g:1221:10: 'NOWAIT'
    {
        this->matchs(lit_70);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_NOWAITEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_NOWAITEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_NOWAITEx: ;

}
// $ANTLR end PLSQL_RESERVED_NOWAIT

//   Comes from: 1225:5: ( 'NULL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_NULL
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_NULL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_NULL()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_NULL;


    // OracleDMLLexer.g:1225:5: ( 'NULL' )
    // OracleDMLLexer.g:1225:10: 'NULL'
    {
        this->matchs(lit_71);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_NULLEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_NULLEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_NULLEx: ;

}
// $ANTLR end SQL92_RESERVED_NULL

//   Comes from: 1229:5: ( 'OF' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_OF
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_OF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_OF()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_OF;


    // OracleDMLLexer.g:1229:5: ( 'OF' )
    // OracleDMLLexer.g:1229:10: 'OF'
    {
        this->matchs(lit_72);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_OFEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_OFEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_OFEx: ;

}
// $ANTLR end SQL92_RESERVED_OF

//   Comes from: 1233:5: ( 'ON' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ON
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_ON()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ON;


    // OracleDMLLexer.g:1233:5: ( 'ON' )
    // OracleDMLLexer.g:1233:10: 'ON'
    {
        this->matchs(lit_73);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ONEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ONEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ONEx: ;

}
// $ANTLR end SQL92_RESERVED_ON

//   Comes from: 1237:5: ( 'OPTION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_OPTION
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_OPTION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_OPTION()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_OPTION;


    // OracleDMLLexer.g:1237:5: ( 'OPTION' )
    // OracleDMLLexer.g:1237:10: 'OPTION'
    {
        this->matchs(lit_74);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_OPTIONEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_OPTIONEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_OPTIONEx: ;

}
// $ANTLR end SQL92_RESERVED_OPTION

//   Comes from: 1241:5: ( 'OR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_OR
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_OR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_OR()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_OR;


    // OracleDMLLexer.g:1241:5: ( 'OR' )
    // OracleDMLLexer.g:1241:10: 'OR'
    {
        this->matchs(lit_75);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_OREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_OREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_OREx: ;

}
// $ANTLR end SQL92_RESERVED_OR

//   Comes from: 1245:5: ( 'ORDER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ORDER
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ORDER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_ORDER()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ORDER;


    // OracleDMLLexer.g:1245:5: ( 'ORDER' )
    // OracleDMLLexer.g:1245:10: 'ORDER'
    {
        this->matchs(lit_76);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ORDEREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ORDEREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ORDEREx: ;

}
// $ANTLR end SQL92_RESERVED_ORDER

//   Comes from: 1249:5: ( 'OVERLAPS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_OVERLAPS
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_OVERLAPS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_OVERLAPS()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_OVERLAPS;


    // OracleDMLLexer.g:1249:5: ( 'OVERLAPS' )
    // OracleDMLLexer.g:1249:10: 'OVERLAPS'
    {
        this->matchs(lit_77);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_OVERLAPSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_OVERLAPSEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_OVERLAPSEx: ;

}
// $ANTLR end SQL92_RESERVED_OVERLAPS

//   Comes from: 1253:5: ( 'PRIOR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_PRIOR
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_PRIOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_PRIOR()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_PRIOR;


    // OracleDMLLexer.g:1253:5: ( 'PRIOR' )
    // OracleDMLLexer.g:1253:10: 'PRIOR'
    {
        this->matchs(lit_78);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_PRIOREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_PRIOREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_PRIOREx: ;

}
// $ANTLR end SQL92_RESERVED_PRIOR

//   Comes from: 1257:5: ( 'PROCEDURE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_PROCEDURE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_PROCEDURE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_PROCEDURE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_PROCEDURE;


    // OracleDMLLexer.g:1257:5: ( 'PROCEDURE' )
    // OracleDMLLexer.g:1257:10: 'PROCEDURE'
    {
        this->matchs(lit_79);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_PROCEDUREEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_PROCEDUREEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_PROCEDUREEx: ;

}
// $ANTLR end SQL92_RESERVED_PROCEDURE

//   Comes from: 1261:5: ( 'PUBLIC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_PUBLIC
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_PUBLIC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_PUBLIC()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_PUBLIC;


    // OracleDMLLexer.g:1261:5: ( 'PUBLIC' )
    // OracleDMLLexer.g:1261:10: 'PUBLIC'
    {
        this->matchs(lit_80);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_PUBLICEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_PUBLICEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_PUBLICEx: ;

}
// $ANTLR end SQL92_RESERVED_PUBLIC

//   Comes from: 1265:5: ( 'RESOURCE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_RESOURCE
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_RESOURCE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_RESOURCE()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_RESOURCE;


    // OracleDMLLexer.g:1265:5: ( 'RESOURCE' )
    // OracleDMLLexer.g:1265:10: 'RESOURCE'
    {
        this->matchs(lit_81);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_RESOURCEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_RESOURCEEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_RESOURCEEx: ;

}
// $ANTLR end PLSQL_RESERVED_RESOURCE

//   Comes from: 1269:5: ( 'REVOKE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_REVOKE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_REVOKE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_REVOKE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_REVOKE;


    // OracleDMLLexer.g:1269:5: ( 'REVOKE' )
    // OracleDMLLexer.g:1269:10: 'REVOKE'
    {
        this->matchs(lit_82);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_REVOKEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_REVOKEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_REVOKEEx: ;

}
// $ANTLR end SQL92_RESERVED_REVOKE

//   Comes from: 1273:5: ( 'SELECT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_SELECT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_SELECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_SELECT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_SELECT;


    // OracleDMLLexer.g:1273:5: ( 'SELECT' )
    // OracleDMLLexer.g:1273:10: 'SELECT'
    {
        this->matchs(lit_83);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_SELECTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_SELECTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_SELECTEx: ;

}
// $ANTLR end SQL92_RESERVED_SELECT

//   Comes from: 1277:5: ( 'SHARE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_SHARE
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_SHARE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_SHARE()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_SHARE;


    // OracleDMLLexer.g:1277:5: ( 'SHARE' )
    // OracleDMLLexer.g:1277:10: 'SHARE'
    {
        this->matchs(lit_84);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_SHAREEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_SHAREEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_SHAREEx: ;

}
// $ANTLR end PLSQL_RESERVED_SHARE

//   Comes from: 1281:5: ( 'SIZE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_SIZE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_SIZE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_SIZE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_SIZE;


    // OracleDMLLexer.g:1281:5: ( 'SIZE' )
    // OracleDMLLexer.g:1281:10: 'SIZE'
    {
        this->matchs(lit_85);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_SIZEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_SIZEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_SIZEEx: ;

}
// $ANTLR end SQL92_RESERVED_SIZE

//   Comes from: 1289:5: ( 'START' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_START
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_START()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_START;


    // OracleDMLLexer.g:1289:5: ( 'START' )
    // OracleDMLLexer.g:1289:10: 'START'
    {
        this->matchs(lit_86);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_STARTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_STARTEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_STARTEx: ;

}
// $ANTLR end PLSQL_RESERVED_START

//   Comes from: 1293:5: ( 'TABAUTH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_TABAUTH
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_TABAUTH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_TABAUTH()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_TABAUTH;


    // OracleDMLLexer.g:1293:5: ( 'TABAUTH' )
    // OracleDMLLexer.g:1293:10: 'TABAUTH'
    {
        this->matchs(lit_87);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_TABAUTHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_TABAUTHEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_TABAUTHEx: ;

}
// $ANTLR end PLSQL_RESERVED_TABAUTH

//   Comes from: 1297:5: ( 'TABLE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_TABLE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_TABLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_TABLE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_TABLE;


    // OracleDMLLexer.g:1297:5: ( 'TABLE' )
    // OracleDMLLexer.g:1297:10: 'TABLE'
    {
        this->matchs(lit_88);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_TABLEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_TABLEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_TABLEEx: ;

}
// $ANTLR end SQL92_RESERVED_TABLE

//   Comes from: 1301:5: ( 'THE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_THE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_THE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_THE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_THE;


    // OracleDMLLexer.g:1301:5: ( 'THE' )
    // OracleDMLLexer.g:1301:10: 'THE'
    {
        this->matchs(lit_89);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_THEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_THEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_THEEx: ;

}
// $ANTLR end SQL92_RESERVED_THE

//   Comes from: 1305:5: ( 'THEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_THEN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_THEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_THEN()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_THEN;


    // OracleDMLLexer.g:1305:5: ( 'THEN' )
    // OracleDMLLexer.g:1305:10: 'THEN'
    {
        this->matchs(lit_90);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_THENEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_THENEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_THENEx: ;

}
// $ANTLR end SQL92_RESERVED_THEN

//   Comes from: 1309:5: ( 'TO' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_TO
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_TO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_TO()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_TO;


    // OracleDMLLexer.g:1309:5: ( 'TO' )
    // OracleDMLLexer.g:1309:10: 'TO'
    {
        this->matchs(lit_91);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_TOEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_TOEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_TOEx: ;

}
// $ANTLR end SQL92_RESERVED_TO

//   Comes from: 1313:5: ( 'TRUE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_TRUE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_TRUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_TRUE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_TRUE;


    // OracleDMLLexer.g:1313:5: ( 'TRUE' )
    // OracleDMLLexer.g:1313:10: 'TRUE'
    {
        this->matchs(lit_92);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_TRUEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_TRUEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_TRUEEx: ;

}
// $ANTLR end SQL92_RESERVED_TRUE

//   Comes from: 1317:5: ( 'UNION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_UNION
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_UNION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_UNION()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_UNION;


    // OracleDMLLexer.g:1317:5: ( 'UNION' )
    // OracleDMLLexer.g:1317:10: 'UNION'
    {
        this->matchs(lit_93);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_UNIONEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_UNIONEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_UNIONEx: ;

}
// $ANTLR end SQL92_RESERVED_UNION

//   Comes from: 1321:5: ( 'UNIQUE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_UNIQUE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_UNIQUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_UNIQUE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_UNIQUE;


    // OracleDMLLexer.g:1321:5: ( 'UNIQUE' )
    // OracleDMLLexer.g:1321:10: 'UNIQUE'
    {
        this->matchs(lit_94);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_UNIQUEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_UNIQUEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_UNIQUEEx: ;

}
// $ANTLR end SQL92_RESERVED_UNIQUE

//   Comes from: 1325:5: ( 'UPDATE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_UPDATE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_UPDATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_UPDATE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_UPDATE;


    // OracleDMLLexer.g:1325:5: ( 'UPDATE' )
    // OracleDMLLexer.g:1325:10: 'UPDATE'
    {
        this->matchs(lit_95);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_UPDATEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_UPDATEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_UPDATEEx: ;

}
// $ANTLR end SQL92_RESERVED_UPDATE

//   Comes from: 1329:5: ( 'VALUES' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_VALUES
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_VALUES
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_VALUES()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_VALUES;


    // OracleDMLLexer.g:1329:5: ( 'VALUES' )
    // OracleDMLLexer.g:1329:10: 'VALUES'
    {
        this->matchs(lit_96);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_VALUESEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_VALUESEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_VALUESEx: ;

}
// $ANTLR end SQL92_RESERVED_VALUES

//   Comes from: 1333:5: ( 'VIEW' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_VIEW
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_VIEW
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_VIEW()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_VIEW;


    // OracleDMLLexer.g:1333:5: ( 'VIEW' )
    // OracleDMLLexer.g:1333:10: 'VIEW'
    {
        this->matchs(lit_97);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_VIEWEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_VIEWEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_VIEWEx: ;

}
// $ANTLR end SQL92_RESERVED_VIEW

//   Comes from: 1337:5: ( 'VIEWS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_VIEWS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_VIEWS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_RESERVED_VIEWS()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_VIEWS;


    // OracleDMLLexer.g:1337:5: ( 'VIEWS' )
    // OracleDMLLexer.g:1337:10: 'VIEWS'
    {
        this->matchs(lit_98);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_VIEWSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_VIEWSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_VIEWSEx: ;

}
// $ANTLR end PLSQL_RESERVED_VIEWS

//   Comes from: 1341:5: ( 'WHEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_WHEN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_WHEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_WHEN()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_WHEN;


    // OracleDMLLexer.g:1341:5: ( 'WHEN' )
    // OracleDMLLexer.g:1341:10: 'WHEN'
    {
        this->matchs(lit_99);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_WHENEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_WHENEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_WHENEx: ;

}
// $ANTLR end SQL92_RESERVED_WHEN

//   Comes from: 1345:5: ( 'WHERE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_WHERE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_WHERE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_WHERE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_WHERE;


    // OracleDMLLexer.g:1345:5: ( 'WHERE' )
    // OracleDMLLexer.g:1345:10: 'WHERE'
    {
        this->matchs(lit_100);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_WHEREEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_WHEREEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_WHEREEx: ;

}
// $ANTLR end SQL92_RESERVED_WHERE

//   Comes from: 1349:5: ( 'WITH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_WITH
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_WITH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mSQL92_RESERVED_WITH()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_WITH;


    // OracleDMLLexer.g:1349:5: ( 'WITH' )
    // OracleDMLLexer.g:1349:10: 'WITH'
    {
        this->matchs(lit_101);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_WITHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_WITHEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_WITHEx: ;

}
// $ANTLR end SQL92_RESERVED_WITH

//   Comes from: 1352:5: ( 'CAST' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_CAST
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_CAST
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_NON_RESERVED_CAST()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_CAST;


    // OracleDMLLexer.g:1352:5: ( 'CAST' )
    // OracleDMLLexer.g:1352:10: 'CAST'
    {
        this->matchs(lit_102);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_CASTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_CASTEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_CASTEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_CAST

//   Comes from: 1356:8: ( 'MULTISET' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_MULTISET
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_MULTISET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_NON_RESERVED_MULTISET()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_MULTISET;


    // OracleDMLLexer.g:1356:8: ( 'MULTISET' )
    // OracleDMLLexer.g:1356:16: 'MULTISET'
    {
        this->matchs(lit_103);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_MULTISETEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_MULTISETEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_MULTISETEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_MULTISET

//   Comes from: 1360:5: ( 'USING' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_USING
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_USING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_NON_RESERVED_USING()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_USING;


    // OracleDMLLexer.g:1360:5: ( 'USING' )
    // OracleDMLLexer.g:1360:10: 'USING'
    {
        this->matchs(lit_104);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_USINGEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_USINGEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_USINGEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_USING

//   Comes from: 1364:5: ( 'MODEL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_MODEL
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_MODEL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_NON_RESERVED_MODEL()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_MODEL;


    // OracleDMLLexer.g:1364:5: ( 'MODEL' )
    // OracleDMLLexer.g:1364:10: 'MODEL'
    {
        this->matchs(lit_105);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_MODELEx;
        }




        {

                     // "MODEL" is a keyword if and only if it is followed by ("main"|"partition"|"dimension")
                     // otherwise it is a identifier(REGULAR_ID).
                     // This wodoo implements something like context sensitive lexer.
                     // Here we've matched the word "model". Then the Token is created and en-queued in tokenBuffer
                     // We still remember the reference(m) onto this Token
                     _type = PLSQL_NON_RESERVED_MODEL;
                     // emit(m);
                     // advanceInput();

                     // _type = Token.INVALID_TOKEN_TYPE;
                     // int markModel = input.mark();

                     // // Now loop over next Tokens in the input and eventually set Token's type to REGULAR_ID

                     // // Subclassed version will return NULL unless EOF is reached.
                     // // nextToken either returns NULL => then the next token is put into the queue tokenBuffer
                     // // or it returns Token.EOF, then nothing is put into the queue
                     // Token t1 = super.nextToken();
                     // {    // This "if" handles the situation when the "model" is the last text in the input.
                     //      if( t1 != null && t1.getType() == Token.EOF)
                     //      {
                     //          $m.set_type(REGULAR_ID);
                     //      } else {
                     //          t1 = tokenBuffer.pollLast(); // "withdraw" the next token from the queue
                     //          while(true)
                     //          {
                     //             if(t1.getType() == EOF)   // is it EOF?
                     //             {
                     //                 $m.set_type(REGULAR_ID);
                     //                 break;
                     //             }

                     //             if(t1.getChannel() == HIDDEN) // is it a white space? then advance to the next token
                     //             {
                     //                 t1 = super.nextToken(); if( t1 == null) { t1 = tokenBuffer.pollLast(); };
                     //                 continue;
                     //             }

                     //             if( t1.getType() != REGULAR_ID || // is something other than ("main"|"partition"|"dimension")
                     //                ( !t1.getText().equalsIgnoreCase("main") &&
                     //                  !t1.getText().equalsIgnoreCase("partition") &&
                     //                  !t1.getText().equalsIgnoreCase("dimension")
                     //               ))
                     //             {
                     //                 $m.set_type(REGULAR_ID);
                     //                 break;
                     //             }

                     //             break; // we are in the model_clase do not rewrite anything
                     //          } // while true
                     //      } // else if( t1 != null && t1.getType() == Token.EOF)
                     // }
                     // input.rewind(markModel);
                
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_MODELEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_MODELEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_MODEL

//   Comes from: 1423:5: ( 'ELSIF' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_ELSIF
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_ELSIF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_NON_RESERVED_ELSIF()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_ELSIF;


    // OracleDMLLexer.g:1423:5: ( 'ELSIF' )
    // OracleDMLLexer.g:1423:10: 'ELSIF'
    {
        this->matchs(lit_106);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_ELSIFEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_ELSIFEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_ELSIFEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_ELSIF

//   Comes from: 1427:5: ( 'PIVOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_PIVOT
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_PIVOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_NON_RESERVED_PIVOT()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_PIVOT;


    // OracleDMLLexer.g:1427:5: ( 'PIVOT' )
    // OracleDMLLexer.g:1427:10: 'PIVOT'
    {
        this->matchs(lit_107);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_PIVOTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_PIVOTEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_PIVOTEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_PIVOT

//   Comes from: 1431:5: ( 'UNPIVOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_UNPIVOT
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_UNPIVOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mPLSQL_NON_RESERVED_UNPIVOT()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_UNPIVOT;


    // OracleDMLLexer.g:1431:5: ( 'UNPIVOT' )
    // OracleDMLLexer.g:1431:10: 'UNPIVOT'
    {
        this->matchs(lit_108);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_UNPIVOTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_UNPIVOTEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_UNPIVOTEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_UNPIVOT

//   Comes from: 1435:5: ( ( SIMPLE_LETTER ) ( SIMPLE_LETTER | '$' | '_' | '#' | '0' .. '9' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REGULAR_ID
 *
 * Looks to match the characters the constitute the token REGULAR_ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mREGULAR_ID()
{
    ANTLR_UINT32	_type;
      

    _type	    = REGULAR_ID;


    // OracleDMLLexer.g:1435:5: ( ( SIMPLE_LETTER ) ( SIMPLE_LETTER | '$' | '_' | '#' | '0' .. '9' )* )
    // OracleDMLLexer.g:1435:10: ( SIMPLE_LETTER ) ( SIMPLE_LETTER | '$' | '_' | '#' | '0' .. '9' )*
    {
        if ( ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleREGULAR_IDEx;
        }


        // OracleDMLLexer.g:1435:26: ( SIMPLE_LETTER | '$' | '_' | '#' | '0' .. '9' )*

        for (;;)
        {
            ANTLR_UINT32 alt39=2;
            switch ( this->LA(1) )
            {
            case '#':
            case '$':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            	{
            		alt39=1;
            	}
                break;

            }

            switch (alt39)
            {
        	case 1:
        	    // OracleDMLLexer.g:
        	    {
        	        if ( ((this->LA(1) >= '#') && (this->LA(1) <= '$')) || ((this->LA(1) >= '0') && (this->LA(1) <= '9')) || ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || this->LA(1) == '_' || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< OracleDMLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleREGULAR_IDEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop39;	/* break out of the loop */
        	    break;
            }
        }
        loop39: ; /* Jump out to here if this rule does not match */


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleREGULAR_IDEx; /* Prevent compiler warnings */
    ruleREGULAR_IDEx: ;

}
// $ANTLR end REGULAR_ID

//   Comes from: 1439:5: ( '@!' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ZV
 *
 * Looks to match the characters the constitute the token ZV
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void OracleDMLLexer::mZV()
{
    ANTLR_UINT32	_type;
      

    _type	    = ZV;


    // OracleDMLLexer.g:1439:5: ( '@!' )
    // OracleDMLLexer.g:1439:10: '@!'
    {
        this->matchs(lit_109);
        if  (this->hasException())
        {
            goto ruleZVEx;
        }




        {
            this->get_state()->get_channel()=HIDDEN;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleZVEx; /* Prevent compiler warnings */
    ruleZVEx: ;

}
// $ANTLR end ZV

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
void
OracleDMLLexer::mTokens()
{
    {
        //  OracleDMLLexer.g:1:8: ( FOR_NOTATION | NATIONAL_CHAR_STRING_LIT | BIT_STRING_LIT | HEX_STRING_LIT | PERIOD | EXACT_NUM_LIT | CHAR_STRING | CHAR_STRING_PERL | DELIMITED_ID | PERCENT | AMPERSAND | LEFT_PAREN | RIGHT_PAREN | DOUBLE_ASTERISK | ASTERISK | PLUS_SIGN | COMMA | SOLIDUS | AT_SIGN | ASSIGN_OP | BINDVAR | COLON | SEMICOLON | LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP | GREATER_THAN_OR_EQUALS_OP | NOT_EQUAL_OP | CARRET_OPERATOR_PART | TILDE_OPERATOR_PART | EXCLAMATION_OPERATOR_PART | GREATER_THAN_OP | CONCATENATION_OP | VERTICAL_BAR | EQUALS_OP | LEFT_BRACKET | RIGHT_BRACKET | INTRODUCER | SEPARATOR | PROMPT | SQL92_RESERVED_ALL | SQL92_RESERVED_ALTER | SQL92_RESERVED_AND | SQL92_RESERVED_ANY | SQL92_RESERVED_AS | SQL92_RESERVED_ASC | SQL92_RESERVED_BEGIN | SQL92_RESERVED_BETWEEN | SQL92_RESERVED_BY | SQL92_RESERVED_CASE | SQL92_RESERVED_CHECK | PLSQL_RESERVED_CLUSTERS | PLSQL_RESERVED_COLAUTH | PLSQL_RESERVED_COMPRESS | SQL92_RESERVED_CONNECT | PLSQL_NON_RESERVED_CONNECT_BY_ROOT | PLSQL_RESERVED_CRASH | SQL92_RESERVED_CREATE | SQL92_RESERVED_CURRENT | SQL92_RESERVED_CURSOR | SQL92_RESERVED_DATE | SQL92_RESERVED_DECLARE | SQL92_RESERVED_DEFAULT | SQL92_RESERVED_DELETE | SQL92_RESERVED_DESC | SQL92_RESERVED_DISTINCT | SQL92_RESERVED_DROP | SQL92_RESERVED_ELSE | SQL92_RESERVED_END | SQL92_RESERVED_EXCEPTION | PLSQL_RESERVED_EXCLUSIVE | SQL92_RESERVED_EXISTS | SQL92_RESERVED_FALSE | SQL92_RESERVED_FETCH | SQL92_RESERVED_FOR | SQL92_RESERVED_FROM | SQL92_RESERVED_GOTO | SQL92_RESERVED_GRANT | SQL92_RESERVED_GROUP | SQL92_RESERVED_HAVING | PLSQL_RESERVED_IDENTIFIED | PLSQL_RESERVED_IF | SQL92_RESERVED_IN | PLSQL_RESERVED_INDEX | PLSQL_RESERVED_INDEXES | SQL92_RESERVED_INSERT | SQL92_RESERVED_INTERSECT | SQL92_RESERVED_INTO | SQL92_RESERVED_IS | SQL92_RESERVED_LIKE | PLSQL_RESERVED_LOCK | PLSQL_RESERVED_MINUS | PLSQL_RESERVED_MODE | PLSQL_RESERVED_NOCOMPRESS | SQL92_RESERVED_NOT | PLSQL_RESERVED_NOWAIT | SQL92_RESERVED_NULL | SQL92_RESERVED_OF | SQL92_RESERVED_ON | SQL92_RESERVED_OPTION | SQL92_RESERVED_OR | SQL92_RESERVED_ORDER | SQL92_RESERVED_OVERLAPS | SQL92_RESERVED_PRIOR | SQL92_RESERVED_PROCEDURE | SQL92_RESERVED_PUBLIC | PLSQL_RESERVED_RESOURCE | SQL92_RESERVED_REVOKE | SQL92_RESERVED_SELECT | PLSQL_RESERVED_SHARE | SQL92_RESERVED_SIZE | PLSQL_RESERVED_START | PLSQL_RESERVED_TABAUTH | SQL92_RESERVED_TABLE | SQL92_RESERVED_THE | SQL92_RESERVED_THEN | SQL92_RESERVED_TO | SQL92_RESERVED_TRUE | SQL92_RESERVED_UNION | SQL92_RESERVED_UNIQUE | SQL92_RESERVED_UPDATE | SQL92_RESERVED_VALUES | SQL92_RESERVED_VIEW | PLSQL_RESERVED_VIEWS | SQL92_RESERVED_WHEN | SQL92_RESERVED_WHERE | SQL92_RESERVED_WITH | PLSQL_NON_RESERVED_CAST | PLSQL_NON_RESERVED_MULTISET | PLSQL_NON_RESERVED_USING | PLSQL_NON_RESERVED_MODEL | PLSQL_NON_RESERVED_ELSIF | PLSQL_NON_RESERVED_PIVOT | PLSQL_NON_RESERVED_UNPIVOT | REGULAR_ID | ZV )

        ANTLR_UINT32 alt40;

        alt40=135;

        alt40 = cdfa40.predict(this, this->get_rec(), this->get_istream(), cdfa40 );
        if  (this->hasException())
        {
            goto ruleTokensEx;
        }

        switch (alt40)
        {
    	case 1:
    	    // OracleDMLLexer.g:1:10: FOR_NOTATION
    	    {
    	        /* 1:10: FOR_NOTATION */
    	        mFOR_NOTATION();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 2:
    	    // OracleDMLLexer.g:1:23: NATIONAL_CHAR_STRING_LIT
    	    {
    	        /* 1:23: NATIONAL_CHAR_STRING_LIT */
    	        mNATIONAL_CHAR_STRING_LIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // OracleDMLLexer.g:1:48: BIT_STRING_LIT
    	    {
    	        /* 1:48: BIT_STRING_LIT */
    	        mBIT_STRING_LIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // OracleDMLLexer.g:1:63: HEX_STRING_LIT
    	    {
    	        /* 1:63: HEX_STRING_LIT */
    	        mHEX_STRING_LIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 5:
    	    // OracleDMLLexer.g:1:78: PERIOD
    	    {
    	        /* 1:78: PERIOD */
    	        mPERIOD();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 6:
    	    // OracleDMLLexer.g:1:85: EXACT_NUM_LIT
    	    {
    	        /* 1:85: EXACT_NUM_LIT */
    	        mEXACT_NUM_LIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 7:
    	    // OracleDMLLexer.g:1:99: CHAR_STRING
    	    {
    	        /* 1:99: CHAR_STRING */
    	        mCHAR_STRING();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 8:
    	    // OracleDMLLexer.g:1:111: CHAR_STRING_PERL
    	    {
    	        /* 1:111: CHAR_STRING_PERL */
    	        mCHAR_STRING_PERL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 9:
    	    // OracleDMLLexer.g:1:128: DELIMITED_ID
    	    {
    	        /* 1:128: DELIMITED_ID */
    	        mDELIMITED_ID();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 10:
    	    // OracleDMLLexer.g:1:141: PERCENT
    	    {
    	        /* 1:141: PERCENT */
    	        mPERCENT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 11:
    	    // OracleDMLLexer.g:1:149: AMPERSAND
    	    {
    	        /* 1:149: AMPERSAND */
    	        mAMPERSAND();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 12:
    	    // OracleDMLLexer.g:1:159: LEFT_PAREN
    	    {
    	        /* 1:159: LEFT_PAREN */
    	        mLEFT_PAREN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 13:
    	    // OracleDMLLexer.g:1:170: RIGHT_PAREN
    	    {
    	        /* 1:170: RIGHT_PAREN */
    	        mRIGHT_PAREN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 14:
    	    // OracleDMLLexer.g:1:182: DOUBLE_ASTERISK
    	    {
    	        /* 1:182: DOUBLE_ASTERISK */
    	        mDOUBLE_ASTERISK();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 15:
    	    // OracleDMLLexer.g:1:198: ASTERISK
    	    {
    	        /* 1:198: ASTERISK */
    	        mASTERISK();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 16:
    	    // OracleDMLLexer.g:1:207: PLUS_SIGN
    	    {
    	        /* 1:207: PLUS_SIGN */
    	        mPLUS_SIGN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 17:
    	    // OracleDMLLexer.g:1:217: COMMA
    	    {
    	        /* 1:217: COMMA */
    	        mCOMMA();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 18:
    	    // OracleDMLLexer.g:1:223: SOLIDUS
    	    {
    	        /* 1:223: SOLIDUS */
    	        mSOLIDUS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 19:
    	    // OracleDMLLexer.g:1:231: AT_SIGN
    	    {
    	        /* 1:231: AT_SIGN */
    	        mAT_SIGN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 20:
    	    // OracleDMLLexer.g:1:239: ASSIGN_OP
    	    {
    	        /* 1:239: ASSIGN_OP */
    	        mASSIGN_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 21:
    	    // OracleDMLLexer.g:1:249: BINDVAR
    	    {
    	        /* 1:249: BINDVAR */
    	        mBINDVAR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 22:
    	    // OracleDMLLexer.g:1:257: COLON
    	    {
    	        /* 1:257: COLON */
    	        mCOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 23:
    	    // OracleDMLLexer.g:1:263: SEMICOLON
    	    {
    	        /* 1:263: SEMICOLON */
    	        mSEMICOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 24:
    	    // OracleDMLLexer.g:1:273: LESS_THAN_OR_EQUALS_OP
    	    {
    	        /* 1:273: LESS_THAN_OR_EQUALS_OP */
    	        mLESS_THAN_OR_EQUALS_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 25:
    	    // OracleDMLLexer.g:1:296: LESS_THAN_OP
    	    {
    	        /* 1:296: LESS_THAN_OP */
    	        mLESS_THAN_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 26:
    	    // OracleDMLLexer.g:1:309: GREATER_THAN_OR_EQUALS_OP
    	    {
    	        /* 1:309: GREATER_THAN_OR_EQUALS_OP */
    	        mGREATER_THAN_OR_EQUALS_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 27:
    	    // OracleDMLLexer.g:1:335: NOT_EQUAL_OP
    	    {
    	        /* 1:335: NOT_EQUAL_OP */
    	        mNOT_EQUAL_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 28:
    	    // OracleDMLLexer.g:1:348: CARRET_OPERATOR_PART
    	    {
    	        /* 1:348: CARRET_OPERATOR_PART */
    	        mCARRET_OPERATOR_PART();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 29:
    	    // OracleDMLLexer.g:1:369: TILDE_OPERATOR_PART
    	    {
    	        /* 1:369: TILDE_OPERATOR_PART */
    	        mTILDE_OPERATOR_PART();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 30:
    	    // OracleDMLLexer.g:1:389: EXCLAMATION_OPERATOR_PART
    	    {
    	        /* 1:389: EXCLAMATION_OPERATOR_PART */
    	        mEXCLAMATION_OPERATOR_PART();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 31:
    	    // OracleDMLLexer.g:1:415: GREATER_THAN_OP
    	    {
    	        /* 1:415: GREATER_THAN_OP */
    	        mGREATER_THAN_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 32:
    	    // OracleDMLLexer.g:1:431: CONCATENATION_OP
    	    {
    	        /* 1:431: CONCATENATION_OP */
    	        mCONCATENATION_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 33:
    	    // OracleDMLLexer.g:1:448: VERTICAL_BAR
    	    {
    	        /* 1:448: VERTICAL_BAR */
    	        mVERTICAL_BAR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 34:
    	    // OracleDMLLexer.g:1:461: EQUALS_OP
    	    {
    	        /* 1:461: EQUALS_OP */
    	        mEQUALS_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 35:
    	    // OracleDMLLexer.g:1:471: LEFT_BRACKET
    	    {
    	        /* 1:471: LEFT_BRACKET */
    	        mLEFT_BRACKET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 36:
    	    // OracleDMLLexer.g:1:484: RIGHT_BRACKET
    	    {
    	        /* 1:484: RIGHT_BRACKET */
    	        mRIGHT_BRACKET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 37:
    	    // OracleDMLLexer.g:1:498: INTRODUCER
    	    {
    	        /* 1:498: INTRODUCER */
    	        mINTRODUCER();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 38:
    	    // OracleDMLLexer.g:1:509: SEPARATOR
    	    {
    	        /* 1:509: SEPARATOR */
    	        mSEPARATOR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 39:
    	    // OracleDMLLexer.g:1:519: PROMPT
    	    {
    	        /* 1:519: PROMPT */
    	        mPROMPT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 40:
    	    // OracleDMLLexer.g:1:526: SQL92_RESERVED_ALL
    	    {
    	        /* 1:526: SQL92_RESERVED_ALL */
    	        mSQL92_RESERVED_ALL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 41:
    	    // OracleDMLLexer.g:1:545: SQL92_RESERVED_ALTER
    	    {
    	        /* 1:545: SQL92_RESERVED_ALTER */
    	        mSQL92_RESERVED_ALTER();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 42:
    	    // OracleDMLLexer.g:1:566: SQL92_RESERVED_AND
    	    {
    	        /* 1:566: SQL92_RESERVED_AND */
    	        mSQL92_RESERVED_AND();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 43:
    	    // OracleDMLLexer.g:1:585: SQL92_RESERVED_ANY
    	    {
    	        /* 1:585: SQL92_RESERVED_ANY */
    	        mSQL92_RESERVED_ANY();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 44:
    	    // OracleDMLLexer.g:1:604: SQL92_RESERVED_AS
    	    {
    	        /* 1:604: SQL92_RESERVED_AS */
    	        mSQL92_RESERVED_AS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 45:
    	    // OracleDMLLexer.g:1:622: SQL92_RESERVED_ASC
    	    {
    	        /* 1:622: SQL92_RESERVED_ASC */
    	        mSQL92_RESERVED_ASC();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 46:
    	    // OracleDMLLexer.g:1:641: SQL92_RESERVED_BEGIN
    	    {
    	        /* 1:641: SQL92_RESERVED_BEGIN */
    	        mSQL92_RESERVED_BEGIN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 47:
    	    // OracleDMLLexer.g:1:662: SQL92_RESERVED_BETWEEN
    	    {
    	        /* 1:662: SQL92_RESERVED_BETWEEN */
    	        mSQL92_RESERVED_BETWEEN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 48:
    	    // OracleDMLLexer.g:1:685: SQL92_RESERVED_BY
    	    {
    	        /* 1:685: SQL92_RESERVED_BY */
    	        mSQL92_RESERVED_BY();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 49:
    	    // OracleDMLLexer.g:1:703: SQL92_RESERVED_CASE
    	    {
    	        /* 1:703: SQL92_RESERVED_CASE */
    	        mSQL92_RESERVED_CASE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 50:
    	    // OracleDMLLexer.g:1:723: SQL92_RESERVED_CHECK
    	    {
    	        /* 1:723: SQL92_RESERVED_CHECK */
    	        mSQL92_RESERVED_CHECK();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 51:
    	    // OracleDMLLexer.g:1:744: PLSQL_RESERVED_CLUSTERS
    	    {
    	        /* 1:744: PLSQL_RESERVED_CLUSTERS */
    	        mPLSQL_RESERVED_CLUSTERS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 52:
    	    // OracleDMLLexer.g:1:768: PLSQL_RESERVED_COLAUTH
    	    {
    	        /* 1:768: PLSQL_RESERVED_COLAUTH */
    	        mPLSQL_RESERVED_COLAUTH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 53:
    	    // OracleDMLLexer.g:1:791: PLSQL_RESERVED_COMPRESS
    	    {
    	        /* 1:791: PLSQL_RESERVED_COMPRESS */
    	        mPLSQL_RESERVED_COMPRESS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 54:
    	    // OracleDMLLexer.g:1:815: SQL92_RESERVED_CONNECT
    	    {
    	        /* 1:815: SQL92_RESERVED_CONNECT */
    	        mSQL92_RESERVED_CONNECT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 55:
    	    // OracleDMLLexer.g:1:838: PLSQL_NON_RESERVED_CONNECT_BY_ROOT
    	    {
    	        /* 1:838: PLSQL_NON_RESERVED_CONNECT_BY_ROOT */
    	        mPLSQL_NON_RESERVED_CONNECT_BY_ROOT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 56:
    	    // OracleDMLLexer.g:1:873: PLSQL_RESERVED_CRASH
    	    {
    	        /* 1:873: PLSQL_RESERVED_CRASH */
    	        mPLSQL_RESERVED_CRASH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 57:
    	    // OracleDMLLexer.g:1:894: SQL92_RESERVED_CREATE
    	    {
    	        /* 1:894: SQL92_RESERVED_CREATE */
    	        mSQL92_RESERVED_CREATE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 58:
    	    // OracleDMLLexer.g:1:916: SQL92_RESERVED_CURRENT
    	    {
    	        /* 1:916: SQL92_RESERVED_CURRENT */
    	        mSQL92_RESERVED_CURRENT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 59:
    	    // OracleDMLLexer.g:1:939: SQL92_RESERVED_CURSOR
    	    {
    	        /* 1:939: SQL92_RESERVED_CURSOR */
    	        mSQL92_RESERVED_CURSOR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 60:
    	    // OracleDMLLexer.g:1:961: SQL92_RESERVED_DATE
    	    {
    	        /* 1:961: SQL92_RESERVED_DATE */
    	        mSQL92_RESERVED_DATE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 61:
    	    // OracleDMLLexer.g:1:981: SQL92_RESERVED_DECLARE
    	    {
    	        /* 1:981: SQL92_RESERVED_DECLARE */
    	        mSQL92_RESERVED_DECLARE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 62:
    	    // OracleDMLLexer.g:1:1004: SQL92_RESERVED_DEFAULT
    	    {
    	        /* 1:1004: SQL92_RESERVED_DEFAULT */
    	        mSQL92_RESERVED_DEFAULT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 63:
    	    // OracleDMLLexer.g:1:1027: SQL92_RESERVED_DELETE
    	    {
    	        /* 1:1027: SQL92_RESERVED_DELETE */
    	        mSQL92_RESERVED_DELETE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 64:
    	    // OracleDMLLexer.g:1:1049: SQL92_RESERVED_DESC
    	    {
    	        /* 1:1049: SQL92_RESERVED_DESC */
    	        mSQL92_RESERVED_DESC();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 65:
    	    // OracleDMLLexer.g:1:1069: SQL92_RESERVED_DISTINCT
    	    {
    	        /* 1:1069: SQL92_RESERVED_DISTINCT */
    	        mSQL92_RESERVED_DISTINCT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 66:
    	    // OracleDMLLexer.g:1:1093: SQL92_RESERVED_DROP
    	    {
    	        /* 1:1093: SQL92_RESERVED_DROP */
    	        mSQL92_RESERVED_DROP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 67:
    	    // OracleDMLLexer.g:1:1113: SQL92_RESERVED_ELSE
    	    {
    	        /* 1:1113: SQL92_RESERVED_ELSE */
    	        mSQL92_RESERVED_ELSE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 68:
    	    // OracleDMLLexer.g:1:1133: SQL92_RESERVED_END
    	    {
    	        /* 1:1133: SQL92_RESERVED_END */
    	        mSQL92_RESERVED_END();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 69:
    	    // OracleDMLLexer.g:1:1152: SQL92_RESERVED_EXCEPTION
    	    {
    	        /* 1:1152: SQL92_RESERVED_EXCEPTION */
    	        mSQL92_RESERVED_EXCEPTION();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 70:
    	    // OracleDMLLexer.g:1:1177: PLSQL_RESERVED_EXCLUSIVE
    	    {
    	        /* 1:1177: PLSQL_RESERVED_EXCLUSIVE */
    	        mPLSQL_RESERVED_EXCLUSIVE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 71:
    	    // OracleDMLLexer.g:1:1202: SQL92_RESERVED_EXISTS
    	    {
    	        /* 1:1202: SQL92_RESERVED_EXISTS */
    	        mSQL92_RESERVED_EXISTS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 72:
    	    // OracleDMLLexer.g:1:1224: SQL92_RESERVED_FALSE
    	    {
    	        /* 1:1224: SQL92_RESERVED_FALSE */
    	        mSQL92_RESERVED_FALSE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 73:
    	    // OracleDMLLexer.g:1:1245: SQL92_RESERVED_FETCH
    	    {
    	        /* 1:1245: SQL92_RESERVED_FETCH */
    	        mSQL92_RESERVED_FETCH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 74:
    	    // OracleDMLLexer.g:1:1266: SQL92_RESERVED_FOR
    	    {
    	        /* 1:1266: SQL92_RESERVED_FOR */
    	        mSQL92_RESERVED_FOR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 75:
    	    // OracleDMLLexer.g:1:1285: SQL92_RESERVED_FROM
    	    {
    	        /* 1:1285: SQL92_RESERVED_FROM */
    	        mSQL92_RESERVED_FROM();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 76:
    	    // OracleDMLLexer.g:1:1305: SQL92_RESERVED_GOTO
    	    {
    	        /* 1:1305: SQL92_RESERVED_GOTO */
    	        mSQL92_RESERVED_GOTO();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 77:
    	    // OracleDMLLexer.g:1:1325: SQL92_RESERVED_GRANT
    	    {
    	        /* 1:1325: SQL92_RESERVED_GRANT */
    	        mSQL92_RESERVED_GRANT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 78:
    	    // OracleDMLLexer.g:1:1346: SQL92_RESERVED_GROUP
    	    {
    	        /* 1:1346: SQL92_RESERVED_GROUP */
    	        mSQL92_RESERVED_GROUP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 79:
    	    // OracleDMLLexer.g:1:1367: SQL92_RESERVED_HAVING
    	    {
    	        /* 1:1367: SQL92_RESERVED_HAVING */
    	        mSQL92_RESERVED_HAVING();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 80:
    	    // OracleDMLLexer.g:1:1389: PLSQL_RESERVED_IDENTIFIED
    	    {
    	        /* 1:1389: PLSQL_RESERVED_IDENTIFIED */
    	        mPLSQL_RESERVED_IDENTIFIED();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 81:
    	    // OracleDMLLexer.g:1:1415: PLSQL_RESERVED_IF
    	    {
    	        /* 1:1415: PLSQL_RESERVED_IF */
    	        mPLSQL_RESERVED_IF();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 82:
    	    // OracleDMLLexer.g:1:1433: SQL92_RESERVED_IN
    	    {
    	        /* 1:1433: SQL92_RESERVED_IN */
    	        mSQL92_RESERVED_IN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 83:
    	    // OracleDMLLexer.g:1:1451: PLSQL_RESERVED_INDEX
    	    {
    	        /* 1:1451: PLSQL_RESERVED_INDEX */
    	        mPLSQL_RESERVED_INDEX();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 84:
    	    // OracleDMLLexer.g:1:1472: PLSQL_RESERVED_INDEXES
    	    {
    	        /* 1:1472: PLSQL_RESERVED_INDEXES */
    	        mPLSQL_RESERVED_INDEXES();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 85:
    	    // OracleDMLLexer.g:1:1495: SQL92_RESERVED_INSERT
    	    {
    	        /* 1:1495: SQL92_RESERVED_INSERT */
    	        mSQL92_RESERVED_INSERT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 86:
    	    // OracleDMLLexer.g:1:1517: SQL92_RESERVED_INTERSECT
    	    {
    	        /* 1:1517: SQL92_RESERVED_INTERSECT */
    	        mSQL92_RESERVED_INTERSECT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 87:
    	    // OracleDMLLexer.g:1:1542: SQL92_RESERVED_INTO
    	    {
    	        /* 1:1542: SQL92_RESERVED_INTO */
    	        mSQL92_RESERVED_INTO();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 88:
    	    // OracleDMLLexer.g:1:1562: SQL92_RESERVED_IS
    	    {
    	        /* 1:1562: SQL92_RESERVED_IS */
    	        mSQL92_RESERVED_IS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 89:
    	    // OracleDMLLexer.g:1:1580: SQL92_RESERVED_LIKE
    	    {
    	        /* 1:1580: SQL92_RESERVED_LIKE */
    	        mSQL92_RESERVED_LIKE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 90:
    	    // OracleDMLLexer.g:1:1600: PLSQL_RESERVED_LOCK
    	    {
    	        /* 1:1600: PLSQL_RESERVED_LOCK */
    	        mPLSQL_RESERVED_LOCK();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 91:
    	    // OracleDMLLexer.g:1:1620: PLSQL_RESERVED_MINUS
    	    {
    	        /* 1:1620: PLSQL_RESERVED_MINUS */
    	        mPLSQL_RESERVED_MINUS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 92:
    	    // OracleDMLLexer.g:1:1641: PLSQL_RESERVED_MODE
    	    {
    	        /* 1:1641: PLSQL_RESERVED_MODE */
    	        mPLSQL_RESERVED_MODE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 93:
    	    // OracleDMLLexer.g:1:1661: PLSQL_RESERVED_NOCOMPRESS
    	    {
    	        /* 1:1661: PLSQL_RESERVED_NOCOMPRESS */
    	        mPLSQL_RESERVED_NOCOMPRESS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 94:
    	    // OracleDMLLexer.g:1:1687: SQL92_RESERVED_NOT
    	    {
    	        /* 1:1687: SQL92_RESERVED_NOT */
    	        mSQL92_RESERVED_NOT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 95:
    	    // OracleDMLLexer.g:1:1706: PLSQL_RESERVED_NOWAIT
    	    {
    	        /* 1:1706: PLSQL_RESERVED_NOWAIT */
    	        mPLSQL_RESERVED_NOWAIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 96:
    	    // OracleDMLLexer.g:1:1728: SQL92_RESERVED_NULL
    	    {
    	        /* 1:1728: SQL92_RESERVED_NULL */
    	        mSQL92_RESERVED_NULL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 97:
    	    // OracleDMLLexer.g:1:1748: SQL92_RESERVED_OF
    	    {
    	        /* 1:1748: SQL92_RESERVED_OF */
    	        mSQL92_RESERVED_OF();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 98:
    	    // OracleDMLLexer.g:1:1766: SQL92_RESERVED_ON
    	    {
    	        /* 1:1766: SQL92_RESERVED_ON */
    	        mSQL92_RESERVED_ON();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 99:
    	    // OracleDMLLexer.g:1:1784: SQL92_RESERVED_OPTION
    	    {
    	        /* 1:1784: SQL92_RESERVED_OPTION */
    	        mSQL92_RESERVED_OPTION();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 100:
    	    // OracleDMLLexer.g:1:1806: SQL92_RESERVED_OR
    	    {
    	        /* 1:1806: SQL92_RESERVED_OR */
    	        mSQL92_RESERVED_OR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 101:
    	    // OracleDMLLexer.g:1:1824: SQL92_RESERVED_ORDER
    	    {
    	        /* 1:1824: SQL92_RESERVED_ORDER */
    	        mSQL92_RESERVED_ORDER();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 102:
    	    // OracleDMLLexer.g:1:1845: SQL92_RESERVED_OVERLAPS
    	    {
    	        /* 1:1845: SQL92_RESERVED_OVERLAPS */
    	        mSQL92_RESERVED_OVERLAPS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 103:
    	    // OracleDMLLexer.g:1:1869: SQL92_RESERVED_PRIOR
    	    {
    	        /* 1:1869: SQL92_RESERVED_PRIOR */
    	        mSQL92_RESERVED_PRIOR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 104:
    	    // OracleDMLLexer.g:1:1890: SQL92_RESERVED_PROCEDURE
    	    {
    	        /* 1:1890: SQL92_RESERVED_PROCEDURE */
    	        mSQL92_RESERVED_PROCEDURE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 105:
    	    // OracleDMLLexer.g:1:1915: SQL92_RESERVED_PUBLIC
    	    {
    	        /* 1:1915: SQL92_RESERVED_PUBLIC */
    	        mSQL92_RESERVED_PUBLIC();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 106:
    	    // OracleDMLLexer.g:1:1937: PLSQL_RESERVED_RESOURCE
    	    {
    	        /* 1:1937: PLSQL_RESERVED_RESOURCE */
    	        mPLSQL_RESERVED_RESOURCE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 107:
    	    // OracleDMLLexer.g:1:1961: SQL92_RESERVED_REVOKE
    	    {
    	        /* 1:1961: SQL92_RESERVED_REVOKE */
    	        mSQL92_RESERVED_REVOKE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 108:
    	    // OracleDMLLexer.g:1:1983: SQL92_RESERVED_SELECT
    	    {
    	        /* 1:1983: SQL92_RESERVED_SELECT */
    	        mSQL92_RESERVED_SELECT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 109:
    	    // OracleDMLLexer.g:1:2005: PLSQL_RESERVED_SHARE
    	    {
    	        /* 1:2005: PLSQL_RESERVED_SHARE */
    	        mPLSQL_RESERVED_SHARE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 110:
    	    // OracleDMLLexer.g:1:2026: SQL92_RESERVED_SIZE
    	    {
    	        /* 1:2026: SQL92_RESERVED_SIZE */
    	        mSQL92_RESERVED_SIZE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 111:
    	    // OracleDMLLexer.g:1:2046: PLSQL_RESERVED_START
    	    {
    	        /* 1:2046: PLSQL_RESERVED_START */
    	        mPLSQL_RESERVED_START();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 112:
    	    // OracleDMLLexer.g:1:2067: PLSQL_RESERVED_TABAUTH
    	    {
    	        /* 1:2067: PLSQL_RESERVED_TABAUTH */
    	        mPLSQL_RESERVED_TABAUTH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 113:
    	    // OracleDMLLexer.g:1:2090: SQL92_RESERVED_TABLE
    	    {
    	        /* 1:2090: SQL92_RESERVED_TABLE */
    	        mSQL92_RESERVED_TABLE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 114:
    	    // OracleDMLLexer.g:1:2111: SQL92_RESERVED_THE
    	    {
    	        /* 1:2111: SQL92_RESERVED_THE */
    	        mSQL92_RESERVED_THE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 115:
    	    // OracleDMLLexer.g:1:2130: SQL92_RESERVED_THEN
    	    {
    	        /* 1:2130: SQL92_RESERVED_THEN */
    	        mSQL92_RESERVED_THEN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 116:
    	    // OracleDMLLexer.g:1:2150: SQL92_RESERVED_TO
    	    {
    	        /* 1:2150: SQL92_RESERVED_TO */
    	        mSQL92_RESERVED_TO();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 117:
    	    // OracleDMLLexer.g:1:2168: SQL92_RESERVED_TRUE
    	    {
    	        /* 1:2168: SQL92_RESERVED_TRUE */
    	        mSQL92_RESERVED_TRUE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 118:
    	    // OracleDMLLexer.g:1:2188: SQL92_RESERVED_UNION
    	    {
    	        /* 1:2188: SQL92_RESERVED_UNION */
    	        mSQL92_RESERVED_UNION();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 119:
    	    // OracleDMLLexer.g:1:2209: SQL92_RESERVED_UNIQUE
    	    {
    	        /* 1:2209: SQL92_RESERVED_UNIQUE */
    	        mSQL92_RESERVED_UNIQUE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 120:
    	    // OracleDMLLexer.g:1:2231: SQL92_RESERVED_UPDATE
    	    {
    	        /* 1:2231: SQL92_RESERVED_UPDATE */
    	        mSQL92_RESERVED_UPDATE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 121:
    	    // OracleDMLLexer.g:1:2253: SQL92_RESERVED_VALUES
    	    {
    	        /* 1:2253: SQL92_RESERVED_VALUES */
    	        mSQL92_RESERVED_VALUES();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 122:
    	    // OracleDMLLexer.g:1:2275: SQL92_RESERVED_VIEW
    	    {
    	        /* 1:2275: SQL92_RESERVED_VIEW */
    	        mSQL92_RESERVED_VIEW();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 123:
    	    // OracleDMLLexer.g:1:2295: PLSQL_RESERVED_VIEWS
    	    {
    	        /* 1:2295: PLSQL_RESERVED_VIEWS */
    	        mPLSQL_RESERVED_VIEWS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 124:
    	    // OracleDMLLexer.g:1:2316: SQL92_RESERVED_WHEN
    	    {
    	        /* 1:2316: SQL92_RESERVED_WHEN */
    	        mSQL92_RESERVED_WHEN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 125:
    	    // OracleDMLLexer.g:1:2336: SQL92_RESERVED_WHERE
    	    {
    	        /* 1:2336: SQL92_RESERVED_WHERE */
    	        mSQL92_RESERVED_WHERE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 126:
    	    // OracleDMLLexer.g:1:2357: SQL92_RESERVED_WITH
    	    {
    	        /* 1:2357: SQL92_RESERVED_WITH */
    	        mSQL92_RESERVED_WITH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 127:
    	    // OracleDMLLexer.g:1:2377: PLSQL_NON_RESERVED_CAST
    	    {
    	        /* 1:2377: PLSQL_NON_RESERVED_CAST */
    	        mPLSQL_NON_RESERVED_CAST();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 128:
    	    // OracleDMLLexer.g:1:2401: PLSQL_NON_RESERVED_MULTISET
    	    {
    	        /* 1:2401: PLSQL_NON_RESERVED_MULTISET */
    	        mPLSQL_NON_RESERVED_MULTISET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 129:
    	    // OracleDMLLexer.g:1:2429: PLSQL_NON_RESERVED_USING
    	    {
    	        /* 1:2429: PLSQL_NON_RESERVED_USING */
    	        mPLSQL_NON_RESERVED_USING();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 130:
    	    // OracleDMLLexer.g:1:2454: PLSQL_NON_RESERVED_MODEL
    	    {
    	        /* 1:2454: PLSQL_NON_RESERVED_MODEL */
    	        mPLSQL_NON_RESERVED_MODEL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 131:
    	    // OracleDMLLexer.g:1:2479: PLSQL_NON_RESERVED_ELSIF
    	    {
    	        /* 1:2479: PLSQL_NON_RESERVED_ELSIF */
    	        mPLSQL_NON_RESERVED_ELSIF();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 132:
    	    // OracleDMLLexer.g:1:2504: PLSQL_NON_RESERVED_PIVOT
    	    {
    	        /* 1:2504: PLSQL_NON_RESERVED_PIVOT */
    	        mPLSQL_NON_RESERVED_PIVOT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 133:
    	    // OracleDMLLexer.g:1:2529: PLSQL_NON_RESERVED_UNPIVOT
    	    {
    	        /* 1:2529: PLSQL_NON_RESERVED_UNPIVOT */
    	        mPLSQL_NON_RESERVED_UNPIVOT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 134:
    	    // OracleDMLLexer.g:1:2556: REGULAR_ID
    	    {
    	        /* 1:2556: REGULAR_ID */
    	        mREGULAR_ID();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 135:
    	    // OracleDMLLexer.g:1:2567: ZV
    	    {
    	        /* 1:2567: ZV */
    	        mZV();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */

}


/* End of code
 * =============================================================================
 */
